"use strict";(self.webpackChunkliquid_docs=self.webpackChunkliquid_docs||[]).push([[3546],{7889:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(3117),r=(n(7294),n(3905));const o={},i="Custom Loaders",l={unversionedId:"guides/custom-loaders",id:"guides/custom-loaders",title:"Custom Loaders",description:"Loaders are responsible for finding a template's source text given a name or identifier. Built-in loaders include a FileSystemLoader, a FileExtensionLoader, a ChoiceLoader and a DictLoader. You might want to write a custom loader to load templates from a database or add extra meta data to the template context, for example.",source:"@site/docs/guides/custom-loaders.md",sourceDirName:"guides",slug:"/guides/custom-loaders",permalink:"/liquid/guides/custom-loaders",draft:!1,editUrl:"https://github.com/jg-rp/liquid/tree/docs/docs/guides/custom-loaders.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Custom Tags",permalink:"/liquid/guides/custom-tags"},next:{title:"Security",permalink:"/liquid/guides/security"}},s={},p=[{value:"Loading Sections and Snippets",id:"loading-sections-and-snippets",level:2},{value:"Loading with Context",id:"loading-with-context",level:2},{value:"Front Matter Loader",id:"front-matter-loader",level:2},{value:"Async Database Loader",id:"async-database-loader",level:2},{value:"File Extension Loader",id:"file-extension-loader",level:2}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"custom-loaders"},"Custom Loaders"),(0,r.kt)("p",null,"Loaders are responsible for finding a template's source text given a name or identifier. Built-in loaders include a ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/filesystemloader"},(0,r.kt)("inlineCode",{parentName:"a"},"FileSystemLoader")),", a ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/fileextensionloader"},(0,r.kt)("inlineCode",{parentName:"a"},"FileExtensionLoader")),", a ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/choiceloader"},(0,r.kt)("inlineCode",{parentName:"a"},"ChoiceLoader"))," and a ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/dictloader"},(0,r.kt)("inlineCode",{parentName:"a"},"DictLoader")),". You might want to write a custom loader to load templates from a database or add extra meta data to the template context, for example."),(0,r.kt)("p",null,"Write a custom loader class by inheriting from ",(0,r.kt)("inlineCode",{parentName:"p"},"liquid.loaders.BaseLoader")," and implementing its\n",(0,r.kt)("inlineCode",{parentName:"p"},"get_source")," method. Then pass an instance of your loader to a ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/Environment"},"liquid.Environment")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"loader")," argument."),(0,r.kt)("p",null,"We could implement our own version of ",(0,r.kt)("inlineCode",{parentName:"p"},"DictLoader")," like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="myloaders.py"',title:'"myloaders.py"'},"from typing import TYPE_CHECKING\nfrom typing import Dict\n\nfrom liquid.loaders import BaseLoader\nfrom liquid.loaders import TemplateSource\nfrom liquid.exceptions import TemplateNotFound\n\nif TYPE_CHECKING:\n    from liquid import Environment\n\nclass DictLoader(BaseLoader):\n    def __init__(self, templates: Dict[str, str]):\n        self.templates = templates\n\n    def get_source(self, _: Environment, template_name: str) -> TemplateSource:\n        try:\n            source = self.templates[template_name]\n        except KeyError as err:\n            raise TemplateNotFound(template_name) from err\n\n        return TemplateSource(source, template_name, None)\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"TemplateSource")," is a named tuple containing the template source as a string, its name and an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"uptodate")," callable. If ",(0,r.kt)("inlineCode",{parentName:"p"},"uptodate")," is not ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," it should be a callable that returns ",(0,r.kt)("inlineCode",{parentName:"p"},"False")," if the template needs to be loaded again, or ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," otherwise."),(0,r.kt)("p",null,"You could then use ",(0,r.kt)("inlineCode",{parentName:"p"},"DictLoader")," like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from liquid import Environment\nfrom myloaders import DictLoader\n\nsnippets = {\n    "greeting": "Hello {{ user.name }}",\n    "row": """\n        <div class="row"\'\n            <div class="col">\n            {{ row_content }}\n            </div>\n        </div>\n        """,\n}\n\nenv = Environment(loader=DictLoader(snippets))\n\ntemplate = env.from_string("""\n    <html>\n        {% include \'greeting\' %}\n        {% for i in (1..3) %}\n        {% include \'row\' with i as row_content %}\n        {% endfor %}\n    </html>\n""")\n\nprint(template.render(user={"name": "Brian"}))\n')),(0,r.kt)("h2",{id:"loading-sections-and-snippets"},"Loading Sections and Snippets"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"New in version 1.1.3"))),(0,r.kt)("p",null,"Custom loaders can reference the name of the tag that's trying to load a template, if used from a tag like ",(0,r.kt)("inlineCode",{parentName:"p"},"{% include 'template_name' %}")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"{% render 'template_name' %}"),", or any custom tag that uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Context.get_template_with_context()"),"."),(0,r.kt)("p",null,'This is useful for situations where you want to load partial templates (or "snippets" or "sections") from sub folders within an existing search path, without requiring template authors to include sub folder names in every ',(0,r.kt)("inlineCode",{parentName:"p"},"include")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," tag."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BaseLoader.get_source_with_context()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseLoader.get_source_with_context_async()")," where added in Python Liquid version 1.1.3. These methods are similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"get_source()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"get_source_async()"),", but are passed the active render context instead of an environment, and arbitrary keyword arguments that can be used by a loader to modify its search space. Their default implementations ignore context and keyword arguments, simply delegating to ",(0,r.kt)("inlineCode",{parentName:"p"},"get_source()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"get_source_async()"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"Context.get_template_with_context()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Context.get_template_with_context_async()")," do not use the default template cache. The environment that manages the default template cache does not know what context variables and keyword arguments might be used to manipulate the search space or loaded template.")),(0,r.kt)("p",null,"This example extends ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/fileextensionloader"},(0,r.kt)("inlineCode",{parentName:"a"},"FileExtensionLoader")),", making ",(0,r.kt)("inlineCode",{parentName:"p"},".liquid")," optional, and searches ",(0,r.kt)("inlineCode",{parentName:"p"},"./snippets/")," (relative to the loaders search path) for templates when rendering with the built-in ",(0,r.kt)("inlineCode",{parentName:"p"},"include")," tag."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from pathlib import Path\n\nfrom liquid import Context\nfrom liquid.loaders import TemplateSource\nfrom liquid.loaders import FileExtensionLoader\n\nclass SnippetsFileSystemLoader(FileExtensionLoader):\n    def get_source_with_context(\n        self,\n        context: Context,\n        template_name: str,\n        **kwargs: str,\n    ) -> TemplateSource:\n        if kwargs.get("tag") == "include":\n            section = Path("snippets").joinpath(template_name)\n            return self.get_source(context.env, str(section))\n        return self.get_source(context.env, template_name)\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"tag")," being parse as a keyword argument is a convention used by the built-in ",(0,r.kt)("a",{parentName:"p",href:"/liquid/language/tags#include"},(0,r.kt)("inlineCode",{parentName:"a"},"{% include %}"))," and ",(0,r.kt)("a",{parentName:"p",href:"/liquid/language/tags#render"},(0,r.kt)("inlineCode",{parentName:"a"},"{% render %}"))," tags. Custom tags are free to pass whatever keyword arguments they wish to ",(0,r.kt)("inlineCode",{parentName:"p"},"Context.get_template_with_context()"),", and they will be passed on to ",(0,r.kt)("inlineCode",{parentName:"p"},"get_source_with_context()")," of the configured loader."),(0,r.kt)("p",null,"This example leaves the ",(0,r.kt)("inlineCode",{parentName:"p"},"include")," tag's search path alone, instead defining a ",(0,r.kt)("inlineCode",{parentName:"p"},"section")," tag that inherits from ",(0,r.kt)("inlineCode",{parentName:"p"},"include")," and searches for templates in the ",(0,r.kt)("inlineCode",{parentName:"p"},"sections/")," subfolder of ",(0,r.kt)("inlineCode",{parentName:"p"},"templates/"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from pathlib import Path\n\nfrom liquid import Context\nfrom liquid import Environment\nfrom liquid.loaders import FileExtensionLoader\nfrom liquid.loaders import TemplateSource\nfrom liquid.builtin.tags.include_tag import IncludeNode\nfrom liquid.builtin.tags.include_tag import IncludeTag\n\nclass SectionNode(IncludeNode):\n    tag = "section"\n\nclass SectionTag(IncludeTag):\n    name = "section"\n    node_class = SectionNode\n\nclass SectionFileSystemLoader(FileExtensionLoader):\n    def get_source_with_context(\n        self,\n        context: Context,\n        template_name: str,\n        **kwargs: str,\n    ) -> TemplateSource:\n        if kwargs.get("tag") == "section":\n            section = Path("sections").joinpath(template_name)\n            return self.get_source(context.env, str(section))\n        return self.get_source(context.env, template_name)\n\nenv = Environment(loader=SectionFileSystemLoader(search_path="templates/"))\nenv.add_tag(SectionTag)\n')),(0,r.kt)("h2",{id:"loading-with-context"},"Loading with Context"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"New in version 1.1.3"))),(0,r.kt)("p",null,"When using Liquid in multi-user applications, a loader might need to narrow its search space depending on the current user. The classic example being Shopify, where, to be able to find the appropriate template, the loader must know what the current store ID is."),(0,r.kt)("p",null,"A loader can reference the current render context by implementing ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseLoader.get_source_with_context()")," and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseLoader.get_source_with_context_async()"),". This example gets a ",(0,r.kt)("inlineCode",{parentName:"p"},"site_id")," from the active render context and uses it in combination with the template's name to query an SQLite database. It assumes a table called ",(0,r.kt)("inlineCode",{parentName:"p"},"templates")," exists with columns ",(0,r.kt)("inlineCode",{parentName:"p"},"source"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"updated"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"site_id"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import sqlite3\nimport functools\n\nfrom liquid import Context\nfrom liquid.loaders import BaseLoader\nfrom liquid.loaders import TemplateSource\nfrom liquid.exceptions import TemplateNotFound\n\nclass SQLiteLoader(BaseLoader):\n    def __init__(self, con: sqlite3.Connection):\n        self.con = con\n\n    def get_source_with_context(\n        self, context: Context, template_name: str, **kwargs: str\n    ) -> TemplateSource:\n        site_id = context.resolve("site_id")\n        cur = self.con.cursor()\n        cur.execute(\n            "SELECT source, updated "\n            "FROM templates "\n            "WHERE name = ? "\n            "AND site_id = ?",\n            [template_name, site_id],\n        )\n\n        source = cur.fetchone()\n        if not source:\n            raise TemplateNotFound(template_name)\n\n        return TemplateSource(\n            source=source[0],\n            filename=template_name,\n            uptodate=functools.partial(\n                self._is_site_up_to_date,\n                name=template_name,\n                site_id=site_id,\n                updated=source[1],\n            ),\n        )\n\n    def get_source(self, env: Environment, template_name: str) -> TemplateSource:\n        cur = self.con.cursor()\n        cur.execute(\n            "SELECT source, updated FROM templates WHERE name = ?",\n            [template_name],\n        )\n\n        source = cur.fetchone()\n        if not source:\n            raise TemplateNotFound(template_name)\n\n        return TemplateSource(\n            source=source[0],\n            filename=template_name,\n            uptodate=functools.partial(\n                self._is_up_to_date,\n                name=template_name,\n                updated=source[1],\n            ),\n        )\n\n    def _is_site_up_to_date(self, name: str, site_id: int, updated: str) -> bool:\n        cur = self.con.cursor()\n        cur.execute(\n            "SELECT updated FROM templates WHERE name = ? AND site_id = ?",\n            [name, site_id],\n        )\n\n        row = cur.fetchone()\n        if not row:\n            return False\n        return updated == row[0]\n\n    def _is_up_to_date(self, name: str, updated: str) -> bool:\n        cur = self.con.cursor()\n        cur.execute(\n            "SELECT updated FROM templates WHERE name = ?",\n            [name],\n        )\n\n        row = cur.fetchone()\n        if not row:\n            return False\n        return updated == row[0]\n')),(0,r.kt)("h2",{id:"front-matter-loader"},"Front Matter Loader"),(0,r.kt)("p",null,"Loaders can add to a template's render context using the ",(0,r.kt)("inlineCode",{parentName:"p"},"matter")," argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"TemplateSource"),". This example implements a Jekyll style front matter loader."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import re\nimport yaml  # Assumes pyyaml is installed\n\nfrom liquid import Environment\nfrom liquid.loaders import FileSystemLoader\nfrom liquid.loaders import TemplateSource\n\nRE_FRONT_MATTER = re.compile(r"\\s*---\\s*(.*?)\\s*---\\s*", re.MULTILINE | re.DOTALL)\n\n\nclass FrontMatterFileSystemLoader(FileSystemLoader):\n    def get_source(\n        self,\n        env: Environment,\n        template_name: str,\n    ) -> TemplateSource:\n        source, filename, uptodate, matter = super().get_source(env, template_name)\n        match = RE_FRONT_MATTER.search(source)\n\n        if match:\n            # Should add some yaml error handling here.\n            matter = yaml.load(match.group(1), Loader=yaml.Loader)\n            source = source[match.end() :]\n\n        return TemplateSource(\n            source,\n            filename,\n            uptodate,\n            matter,\n        )\n')),(0,r.kt)("h2",{id:"async-database-loader"},"Async Database Loader"),(0,r.kt)("p",null,"Template loaders can implement ",(0,r.kt)("inlineCode",{parentName:"p"},"get_source_async()"),". When a template is rendered by awaiting ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/BoundTemplate#renderasync"},(0,r.kt)("inlineCode",{parentName:"a"},"BoundTemplate.render_async()"))," instead of calling ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/BoundTemplate#render"},(0,r.kt)("inlineCode",{parentName:"a"},"BoundTemplate.render()")),", ",(0,r.kt)("inlineCode",{parentName:"p"},"{% render %}")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"{% include %}")," tags will use ",(0,r.kt)("inlineCode",{parentName:"p"},"get_template_async")," of the bound ",(0,r.kt)("a",{parentName:"p",href:"/liquid/api/Environment"},(0,r.kt)("inlineCode",{parentName:"a"},"Environment")),", which delegates to ",(0,r.kt)("inlineCode",{parentName:"p"},"get_source_async")," of the configured loader."),(0,r.kt)("p",null,"For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncDatabaseLoader")," will load templates from a PostgreSQL database using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/MagicStack/asyncpg"},"asyncpg"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import datetime\nimport functools\n\nimport asyncpg\n\nfrom liquid import Environment\nfrom liquid.exceptions import TemplateNotFound\nfrom liquid.loaders import BaseLoader\nfrom liquid.loaders import TemplateSource\n\n\nclass AsyncDatabaseLoader(BaseLoader):\n    def __init__(self, pool: asyncpg.Pool) -> None:\n        self.pool = pool\n\n    def get_source(self, env: Environment, template_name: str) -> TemplateSource:\n        raise NotImplementedError("async only loader")\n\n    async def _is_up_to_date(self, name: str, updated: datetime.datetime) -> bool:\n        async with self.pool.acquire() as connection:\n            return updated == await connection.fetchval(\n                "SELECT updated FROM templates WHERE name = $1", name\n            )\n\n    async def get_source_async(\n        self, env: Environment, template_name: str\n    ) -> TemplateSource:\n        async with self.pool.acquire() as connection:\n            source = await connection.fetchrow(\n                "SELECT source, updated FROM templates WHERE name = $1", template_name\n            )\n\n        if not source:\n            raise TemplateNotFound(template_name)\n\n        return TemplateSource(\n            source=source["source"],\n            filename=template_name,\n            uptodate=functools.partial(\n                self._is_up_to_date, name=template_name, updated=source["updated"]\n            ),\n        )\n')),(0,r.kt)("h2",{id:"file-extension-loader"},"File Extension Loader"),(0,r.kt)("p",null,"This example extends ",(0,r.kt)("inlineCode",{parentName:"p"},"FileSystemLoader")," to automatically append a file extension if one is missing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from pathlib import Path\n\nfrom typing import Union\nfrom typing import Iterable\n\nfrom liquid.loaders import FileSystemLoader\n\n\nclass FileExtensionLoader(FileSystemLoader):\n    """A file system loader that adds a file name extension if one is missing."""\n\n    def __init__(\n        self,\n        search_path: Union[str, Path, Iterable[Union[str, Path]]],\n        encoding: str = "utf-8",\n        ext: str = ".liquid",\n    ):\n        super().__init__(search_path, encoding=encoding)\n        self.ext = ext\n\n    def resolve_path(self, template_name: str) -> Path:\n        template_path = Path(template_name)\n\n        if not template_path.suffix:\n            template_path = template_path.with_suffix(self.ext)\n\n        # Don\'t allow "../" to escape the search path.\n        if os.path.pardir in template_path.parts:\n            raise TemplateNotFound(template_name)\n\n        for path in self.search_path:\n            source_path = path.joinpath(template_path)\n\n            if not source_path.exists():\n                continue\n            return source_path\n        raise TemplateNotFound(template_name)\n')))}m.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=r,f=u["".concat(s,".").concat(c)]||u[c]||m[c]||o;return n?a.createElement(f,i(i({ref:t},d),{},{components:n})):a.createElement(f,i({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);