"use strict";(self.webpackChunkliquid_docs=self.webpackChunkliquid_docs||[]).push([[8870],{1732:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>a});var s=i(5893),r=i(1151);const t={title:"Compatibility",description:"Known incompatibilities between Python Liquid and Ruby Liquid",hide_table_of_contents:!1},l="Known Issues",d={type:"mdx",permalink:"/liquid/known_issues",source:"@site/src/pages/known_issues.md",title:"Compatibility",description:"Known incompatibilities between Python Liquid and Ruby Liquid",frontMatter:{title:"Compatibility",description:"Known incompatibilities between Python Liquid and Ruby Liquid",hide_table_of_contents:!1},unlisted:!1},o={},a=[{value:"Coercing Strings to Integers Inside Filters",id:"coercing-strings-to-integers-inside-filters",level:2},{value:"Comment Parsing",id:"comment-parsing",level:2},{value:"Counters",id:"counters",level:2},{value:"Cycle Arguments",id:"cycle-arguments",level:2},{value:"Cycle Groups",id:"cycle-groups",level:2},{value:"The Date Filter",id:"the-date-filter",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Extra Else Blocks",id:"extra-else-blocks",level:2},{value:"Floats in Ranges",id:"floats-in-ranges",level:2},{value:"The Split Filter",id:"the-split-filter",level:2},{value:"Indexable Strings",id:"indexable-strings",level:2},{value:"Iterating Strings",id:"iterating-strings",level:2},{value:"Summing Floats",id:"summing-floats",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.useMDXComponents)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"known-issues",children:"Known Issues"}),"\n",(0,s.jsxs)(n.p,{children:["This page documents known compatibility issues between Python Liquid's default ",(0,s.jsx)(n.a,{href:"/api/Environment",children:(0,s.jsx)(n.code,{children:"Environment"})})," and the ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/liquid/",children:"reference implementation"})," of Liquid, written in Ruby. We strive to be 100% compatible with the reference implementation. That is, given an equivalent render context, a template rendered with Python Liquid should produce the same output as when rendered with Ruby Liquid."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["Python Liquid version 1.7.0 introduced ",(0,s.jsx)(n.a,{href:"/api/future-environment",children:(0,s.jsx)(n.code,{children:"liquid.future.Environment"})})," as an alternative to the default ",(0,s.jsx)(n.a,{href:"/api/Environment",children:(0,s.jsx)(n.code,{children:"Environment"})}),". This alternative environment is intended to transition Python Liquid towards greater compatibility with Ruby Liquid, without changing template rendering behavior for existing Python Liquid users."]}),(0,s.jsxs)(n.p,{children:["Some of the issues described below have been resolved with ",(0,s.jsx)(n.code,{children:"liquid.future.Environment"}),". To use it, simply import ",(0,s.jsx)(n.code,{children:"Environment"})," from ",(0,s.jsx)(n.code,{children:"liquid.future"})," instead of ",(0,s.jsx)(n.code,{children:"liquid"}),"."]})]}),"\n",(0,s.jsx)(n.h2,{id:"coercing-strings-to-integers-inside-filters",children:"Coercing Strings to Integers Inside Filters"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.em,{children:["See issue ",(0,s.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/issues/49",children:"#49"})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Many filters built in to Liquid will automatically convert a string representation of a number to an integer or float as needed. When converting integers, Ruby Liquid uses ",(0,s.jsx)(n.a,{href:"https://ruby-doc.org/core-3.1.1/String.html#method-i-to_i",children:"Ruby's String.to_i method"}),", which will disregard trailing non-digit characters. In the following example, ",(0,s.jsx)(n.code,{children:"'7,42'"})," is converted to ",(0,s.jsx)(n.code,{children:"7"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"template:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-liquid",children:"{{ 3.14 | plus: '7,42' }}\n{{ '123abcdef45' | plus: '1,,,,..!@qwerty' }}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"output"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"10.14\n124\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Python Liquid currently falls back to ",(0,s.jsx)(n.code,{children:"0"})," for any string that can't be converted to an integer in its entirety. As is the case in Ruby Liquid for strings without leading digits."]}),"\n",(0,s.jsx)(n.p,{children:"This does not apply to parsing of integer literals, only converting strings to integers (not floats) inside filters."}),"\n",(0,s.jsx)(n.h2,{id:"comment-parsing",children:"Comment Parsing"}),"\n",(0,s.jsxs)(n.p,{children:["Python Liquid will raise a ",(0,s.jsx)(n.code,{children:"LiquidSyntaxError"})," if it finds the string ",(0,s.jsx)(n.code,{children:"{% endcomment %}"})," inside a comment block. Ruby Liquid, on the other hand, will successfully parse fully-formed nested comment blocks, but will fail to parse a comment block containing either a ",(0,s.jsx)(n.code,{children:"{% comment %}"})," or ",(0,s.jsx)(n.code,{children:"{% endcomment %}"})," on its own."]}),"\n",(0,s.jsx)(n.h2,{id:"counters",children:"Counters"}),"\n",(0,s.jsxs)(n.p,{children:["In Ruby Liquid, the built-in ",(0,s.jsx)(n.a,{href:"/language/tags#increment",children:(0,s.jsx)(n.code,{children:"increment"})})," and ",(0,s.jsx)(n.a,{href:"/language/tags#decrement",children:(0,s.jsx)(n.code,{children:"decrement"})}),' tags can, in some cases, mutate "global" context and keep named counters alive between renders. Although not difficult to implement, I can\'t quite bring myself to do it.']}),"\n",(0,s.jsx)(n.h2,{id:"cycle-arguments",children:"Cycle Arguments"}),"\n",(0,s.jsxs)(n.p,{children:["Python Liquid will accept ",(0,s.jsx)(n.a,{href:"/language/tags#cycle",children:(0,s.jsx)(n.code,{children:"cycle"})}),' arguments of any type, including identifiers to be resolved, this behavior is considered "unintended" or "undefined" in Ruby Liquid (see ',(0,s.jsx)(n.a,{href:"https://github.com/Shopify/liquid/issues/1519",children:"issue #1519"}),"). If you need interoperability between Python Liquid and Ruby Liquid, only use strings or numbers as arguments to ",(0,s.jsx)(n.code,{children:"cycle"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"cycle-groups",children:"Cycle Groups"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.em,{children:["See issue ",(0,s.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/issues/43",children:"#43"})]})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"Fixed in version 1.7.0"})})," with ",(0,s.jsx)(n.a,{href:"/api/future-environment",children:(0,s.jsx)(n.code,{children:"liquid.future.Environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.a,{href:"/language/tags#cycle",children:(0,s.jsx)(n.code,{children:"cycle"})})," tag is given a name, Python Liquid will use that name and all other arguments to distinguish one cycle from another. Ruby Liquid will disregard all other arguments when given a name. For example."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-liquid",children:'{% cycle a: 1, 2, 3 %}\n{% cycle a: "x", "y", "z" %}\n{% cycle a: 1, 2, 3 %}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ruby Liquid Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"1\ny\n3\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Python Liquid Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"1\nx\n2\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-date-filter",children:"The Date Filter"}),"\n",(0,s.jsxs)(n.p,{children:["The built-in ",(0,s.jsx)(n.a,{href:"/language/filters#date",children:(0,s.jsx)(n.code,{children:"date"})})," filter uses ",(0,s.jsx)(n.a,{href:"https://dateutil.readthedocs.io/en/stable/",children:"dateutil"})," for parsing strings to ",(0,s.jsx)(n.code,{children:"datetime"}),"s, and ",(0,s.jsx)(n.code,{children:"strftime"})," for formatting. There are likely to be some inconsistencies between this and the reference implementation's equivalent parsing and formatting of dates and times."]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Python Liquid might not handle syntax or type errors in the same way as the reference implementation. We might fail earlier or later, and will almost certainly produce a different error message."}),"\n",(0,s.jsxs)(n.p,{children:['Python Liquid does not have a "lax" parser, like Ruby Liquid. Upon finding an error, Python Liquid\'s ',(0,s.jsx)(n.a,{href:"/introduction/strictness",children:"lax mode"})," simply discards the current block and continues to parse/render the next block, if one is available. Also, Python Liquid will never inject error messages into an output document. Although this can be achieved by extending ",(0,s.jsx)(n.a,{href:"/api/BoundTemplate",children:(0,s.jsx)(n.code,{children:"BoundTemplate"})})," and overriding ",(0,s.jsx)(n.a,{href:"/api/BoundTemplate#render_with_context",children:(0,s.jsx)(n.code,{children:"render_with_context()"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"extra-else-blocks",children:"Extra Else Blocks"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"Fixed in version 1.12.1"})})," with ",(0,s.jsx)(n.a,{href:"/api/future-environment",children:(0,s.jsx)(n.code,{children:"liquid.future.Environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Shopify/Liquid will silently ignore superfluous ",(0,s.jsx)(n.code,{children:"{% else %}"})," tag expressions (anything between ",(0,s.jsx)(n.code,{children:"else"})," and the closing tag delimiter ",(0,s.jsx)(n.code,{children:"%}"}),") and superfluous ",(0,s.jsx)(n.code,{children:"{% elsif %}"})," and ",(0,s.jsx)(n.code,{children:"{% else %}"})," blocks after the first ",(0,s.jsx)(n.code,{children:"{% else %}"})," block."]}),"\n",(0,s.jsxs)(n.p,{children:["Python Liquid's default behavior is to raise a ",(0,s.jsx)(n.code,{children:"LiquidSyntaxError"})," in such cases."]}),"\n",(0,s.jsx)(n.h2,{id:"floats-in-ranges",children:"Floats in Ranges"}),"\n",(0,s.jsxs)(n.p,{children:["If a range literal uses a float literal as its start or stop value, the float literal must have something after the decimal point. This is OK ",(0,s.jsx)(n.code,{children:"(1.0..3)"}),". This is not ",(0,s.jsx)(n.code,{children:"(1...3)"}),". Ruby Liquid will accept either, resulting in a sequence of ",(0,s.jsx)(n.code,{children:"[1,2,3]"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"the-split-filter",children:"The Split Filter"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.em,{children:["See issue ",(0,s.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/issues/134",children:"#134"})]})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"Fixed in version 1.10.2"})})," with ",(0,s.jsx)(n.a,{href:"/api/future-environment",children:(0,s.jsx)(n.code,{children:"liquid.future.Environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When given an empty string to split or when the string and the delimiter are equal, we used Python's ",(0,s.jsx)(n.code,{children:"str.split()"})," behavior of producing one or two element lists containing empty strings. Shopify/Liquid returns an empty list/array in such cases."]}),"\n",(0,s.jsx)(n.h2,{id:"indexable-strings",children:"Indexable Strings"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.em,{children:["See issue ",(0,s.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/issues/90",children:"#90"})]})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"Fixed in version 1.7.0"})})," with ",(0,s.jsx)(n.a,{href:"/api/future-environment",children:(0,s.jsx)(n.code,{children:"liquid.future.Environment"})}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The reference implementation does not allow us to access characters in a string by their index. Python Liquid does."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Template"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-liquid",children:"{% assign x = 'foobar' -%}\n{{ x[0] }}\n{{ x[1] }}\n{{ x[-1] }}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Python Liquid output"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"f\no\nr\n"})}),"\n",(0,s.jsx)(n.p,{children:"Shopify/liquid will throw an error (in strict mode) for each attempt at accessing a character by its index."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"<Liquid::UndefinedVariable: Liquid error: undefined variable 0>\n<Liquid::UndefinedVariable: Liquid error: undefined variable 1>\n<Liquid::UndefinedVariable: Liquid error: undefined variable -1>\n"})}),"\n",(0,s.jsx)(n.h2,{id:"iterating-strings",children:"Iterating Strings"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.em,{children:["See issue ",(0,s.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/issues/102",children:"#102"})]})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"Fixed in version 1.8.0"})})," with ",(0,s.jsx)(n.a,{href:"/api/future-environment",children:(0,s.jsx)(n.code,{children:"liquid.future.Environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When looping over strings with the ",(0,s.jsx)(n.code,{children:"{% for %}"})," tag, the reference implementation of Liquid will iterate over a one element array, where the first and only element is the string. Python Liquid will iterate through characters in the string."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Template:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-liquid",children:"{% assign foo = 'hello world' %}\n{% for x in foo %}{{ x }} / {% endfor %}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ruby Liquid Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"hello world /\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Python Liquid Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"h / e / l / l / o /   / w / o / r / l / d /\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It appears that this is unintended behavior for Ruby Liquid. Previously, Ruby Liquid would iterate over lines in a string, also not intended behavior. See ",(0,s.jsx)(n.a,{href:"https://github.com/Shopify/liquid/pull/1667",children:"https://github.com/Shopify/liquid/pull/1667"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"summing-floats",children:"Summing Floats"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.em,{children:["See ",(0,s.jsx)(n.a,{href:"https://github.com/Shopify/liquid/issues/1725",children:"Shopify/Liquid#1725"})]})})}),"\n",(0,s.jsxs)(n.p,{children:["When given one or more floats as input, the reference implementation's standard ",(0,s.jsx)(n.code,{children:"sum"})," filter will return a ",(0,s.jsx)(n.code,{children:"BigDecimal"}),", which is rendered in scientific notation (or similar). Python Liquid will coerce the result to a float, and render that, without an exponent."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Template:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-liquid",children:'{% assign a = "0.1,0.2,0.3" | split: "," %}\n{{ a | sum }}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ruby Liquid Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"0.6e0\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Python Liquid Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"0.6\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.useMDXComponents)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,i)=>{i.r(n),i.d(n,{MDXProvider:()=>d,useMDXComponents:()=>l});var s=i(7294);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);