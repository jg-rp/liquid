"use strict";(self.webpackChunkliquid_docs=self.webpackChunkliquid_docs||[]).push([[2802],{3048:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/static-template-analysis","title":"Static Template Analysis","description":"_New in version 1.2.0_","source":"@site/docs/guides/static-template-analysis.md","sourceDirName":"guides","slug":"/guides/static-template-analysis","permalink":"/liquid/guides/static-template-analysis","draft":false,"unlisted":false,"editUrl":"https://github.com/jg-rp/liquid/tree/docs/docs/guides/static-template-analysis.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Security","permalink":"/liquid/guides/security"},"next":{"title":"Contextual Template Analysis","permalink":"/liquid/guides/contextual-template-analysis"}}');var l=a(4848),t=a(8453);const s={},r="Static Template Analysis",o={},d=[{value:"Variables",id:"variables",level:2},{value:"Global Variables",id:"global-variables",level:3},{value:"Local Variables",id:"local-variables",level:3},{value:"Filters",id:"filters",level:2},{value:"Tags",id:"tags",level:2},{value:"Analyzing Partial Templates",id:"analyzing-partial-templates",level:2},{value:"Analyzing Custom Tags",id:"analyzing-custom-tags",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.useMDXComponents)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"static-template-analysis",children:"Static Template Analysis"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.em,{children:"New in version 1.2.0"})})}),"\n",(0,l.jsxs)(n.p,{children:["Use the ",(0,l.jsx)(n.a,{href:"/liquid/api/BoundTemplate#analyze",children:(0,l.jsx)(n.code,{children:"analyze()"})})," or ",(0,l.jsx)(n.a,{href:"/liquid/api/BoundTemplate#analyze_async",children:(0,l.jsx)(n.code,{children:"analyze_async()"})})," methods of a Liquid ",(0,l.jsx)(n.a,{href:"/liquid/api/BoundTemplate",children:(0,l.jsx)(n.code,{children:"Template"})})," to traverse its abstract syntax tree and report template tag, filter and variable usage."]}),"\n",(0,l.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,l.jsxs)(n.p,{children:["The object returned from ",(0,l.jsx)(n.code,{children:"analyze()"})," is an instance of ",(0,l.jsx)(n.a,{href:"/liquid/api/template-analysis",children:(0,l.jsx)(n.code,{children:"TemplateAnalysis"})}),". Its ",(0,l.jsx)(n.code,{children:"variables"})," property is a dictionary mapping template variable names to a list of two-tuples. Each tuple is the template name and line number where the variable was found."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Template\n\ntemplate = Template("""\\\n{% assign people = "Sally, John, Brian, Sue" | split: ", " %}\n{{ people }}\n{% for name in people %}\n    {{ forloop.index }} - {{ greeting }}, {{ name }}!\n{% endfor %}\n""")\n\nanalysis = template.analyze()\nprint(list(analysis.variables))\n\nfor name, location in analysis.variables.items():\n    for template_name, line_number in location:\n        print(f"\'{name}\' found in \'{template_name}\' on line {line_number}")\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:'title="output"',children:"['people', 'forloop.index', 'greeting', 'name']\n'people' found in '<string>' on line 2\n'people' found in '<string>' on line 3\n'forloop.index' found in '<string>' on line 4\n'greeting' found in '<string>' on line 4\n'name' found in '<string>' on line 4\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.em,{children:"New in version 1.6.0"})})}),"\n",(0,l.jsxs)(n.p,{children:["Variable names - the keys of ",(0,l.jsx)(n.code,{children:"TemplateAnalysis.variables"}),", and others - are a ",(0,l.jsx)(n.code,{children:"str"})," subclass that includes a ",(0,l.jsx)(n.code,{children:"parts"})," property, being a tuple representation of a variable's parts."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from liquid import Template\n\ntemplate = Template(\"{{ data.some[thing['foo.bar']] }}\")\n\nfor var, location in template.analyze().variables.items():\n    for template_name, line_number in location:\n        print(f\"{var.parts} found in '{template_name}' on line {line_number}\")\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:'title="output"',children:"('data', 'some', ('thing', 'foo.bar')) found in '<string>' on line 1\n('thing', 'foo.bar') found in '<string>' on line 1\n"})}),"\n",(0,l.jsx)(n.h3,{id:"global-variables",children:"Global Variables"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"global_variables"})," property of ",(0,l.jsx)(n.a,{href:"/liquid/api/template-analysis",children:(0,l.jsx)(n.code,{children:"TemplateAnalysis"})})," is similar to ",(0,l.jsx)(n.code,{children:"variables"}),", but only includes those variables that are not in scope from previous ",(0,l.jsx)(n.code,{children:"assign"})," or ",(0,l.jsx)(n.code,{children:"capture"})," tags, or added to a block's scope by a block tag."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Template\n\ntemplate = Template("""\\\n{% assign people = "Sally, John, Brian, Sue" | split: ", " %}\n{{ people }}\n{% for name in people %}\n    {{ forloop.index }} - {{ greeting }}, {{ name }}!\n{% endfor %}\n""")\n\nanalysis = template.analyze()\nprint("all variables: ", list(analysis.variables))\nprint("global variables: ", list(analysis.global_variables))\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:'title="output"',children:"all variables:  ['people', 'forloop.index', 'greeting', 'name']\nglobal variables:  ['greeting']\n"})}),"\n",(0,l.jsxs)(n.p,{children:["While ",(0,l.jsx)(n.code,{children:"greeting"})," is assumed to be global (that is, provided by application developers rather than a template author), Python Liquid knows that ",(0,l.jsx)(n.code,{children:"forloop"})," is in scope for the duration of the ",(0,l.jsx)(n.code,{children:"for"})," block. If ",(0,l.jsx)(n.code,{children:"people"})," were referenced before being assigned, we'd see an entry in the ",(0,l.jsx)(n.code,{children:"people"})," list for each location where it is out of scope."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Template\n\ntemplate = Template("""\\\n{{ people }}\n{% assign people = "Sally, John, Brian, Sue" | split: ", " %}\n{{ people }}\n""")\n\nanalysis = template.analyze()\n\nfor name, location in analysis.global_variables.items():\n    for template_name, line_number in location:\n        print(f"\'{name}\' is out of scope in \'{template_name}\' on line {line_number}")\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:'title="output"',children:"'people' is out of scope in '<string>' on line 1\n"})}),"\n",(0,l.jsx)(n.h3,{id:"local-variables",children:"Local Variables"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"local_variables"})," property of ",(0,l.jsx)(n.a,{href:"/liquid/api/template-analysis",children:(0,l.jsx)(n.code,{children:"TemplateAnalysis"})})," is, again, a dictionary mapping template variable names to their locations. Each entry is the location of an ",(0,l.jsx)(n.code,{children:"assign"}),", ",(0,l.jsx)(n.code,{children:"capture"}),", ",(0,l.jsx)(n.code,{children:"increment"}),", or ",(0,l.jsx)(n.code,{children:"decrement"})," tag (or any custom tag that introduces names into the template local namespace) that initializes or updates the variable."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Template\n\ntemplate = Template("""\\\n{% assign people = "Sally, John, Brian, Sue" | split: ", " %}\n{% assign people = "Bob, Frank" | split: ", " %}\n""")\n\nanalysis = template.analyze()\n\nfor name, location in analysis.local_variables.items():\n    for template_name, line_number in location:\n        print(f"\'{name}\' assigned in \'{template_name}\' on line {line_number}")\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:'title="output"',children:"'people' assigned in '<string>' on line 1\n'people' assigned in '<string>' on line 2\n"})}),"\n",(0,l.jsx)(n.h2,{id:"filters",children:"Filters"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.em,{children:"New in version 1.7.0"})})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"filters"})," property of ",(0,l.jsx)(n.a,{href:"/liquid/api/template-analysis",children:(0,l.jsx)(n.code,{children:"TemplateAnalysis"})})," is a dictionary mapping Liquid ",(0,l.jsx)(n.a,{href:"/liquid/language/introduction#filters",children:"filter"})," names to their locations. Undefined filters will be included in ",(0,l.jsx)(n.code,{children:"TemplateAnalysis.filters"}),", regardless of whether ",(0,l.jsx)(n.a,{href:"/liquid/introduction/strictness#undefined-filters",children:(0,l.jsx)(n.code,{children:"strict_filters"})})," is set or not."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Template\n\ntemplate = Template(\n    """\\\n{% assign people = "Sally, John, Brian, Sue" | split: ", " %}\n{% for person in people %}\n  - {{ person | upcase | prepend: \'Hello, \' }}\n{% endfor %}\n"""\n)\n\nanalysis = template.analyze()\n\nfor filter_name, location in analysis.filters.items():\n    for template_name, line_number in location:\n        print(f"\'{filter_name}\' found in \'{template_name}\' on line {line_number}")\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:'title="output"',children:"'split' found in '<string>' on line 1\n'upcase' found in '<string>' on line 3\n'prepend' found in '<string>' on line 3\n"})}),"\n",(0,l.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.em,{children:"New in version 1.7.0"})})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"tags"})," property of ",(0,l.jsx)(n.a,{href:"/liquid/api/template-analysis",children:(0,l.jsx)(n.code,{children:"TemplateAnalysis"})})," is a dictionary mapping Liquid ",(0,l.jsx)(n.a,{href:"/liquid/language/introduction#tags",children:"tag"})," names to their locations. Note that ",(0,l.jsx)(n.a,{href:"/liquid/language/tags#raw",children:(0,l.jsx)(n.code,{children:"{% raw %} tags"})})," will never be included in ",(0,l.jsx)(n.code,{children:"TemplateAnalysis.tags"}),". This is because the lexer converts them to template text before we get a chance to analyze them."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Template\n\ntemplate = Template(\n    """\\\n{% assign people = "Sally, John, Brian, Sue" | split: ", " %}\n{% for person in people %}\n  - {{ person | upcase | prepend: \'Hello, \' }}\n{% endfor %}\n"""\n)\n\nanalysis = template.analyze()\n\nfor tag_name, location in analysis.tags.items():\n    for template_name, line_number in location:\n        print(f"\'{tag_name}\' found in \'{template_name}\' on line {line_number}")\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:"title=output",children:"'assign' found in '<string>' on line 1\n'for' found in '<string>' on line 2\n"})}),"\n",(0,l.jsx)(n.h2,{id:"analyzing-partial-templates",children:"Analyzing Partial Templates"}),"\n",(0,l.jsxs)(n.p,{children:["When the ",(0,l.jsx)(n.code,{children:"follow_partials"})," argument to ",(0,l.jsx)(n.a,{href:"/liquid/api/BoundTemplate#analyze",children:(0,l.jsx)(n.code,{children:"BoundTemplate.analyze()"})})," is ",(0,l.jsx)(n.code,{children:"True"})," (the default), Python Liquid will attempt to load and analyze templates from ",(0,l.jsx)(n.code,{children:"include"})," and ",(0,l.jsx)(n.code,{children:"render"})," tags. In the case of ",(0,l.jsx)(n.code,{children:"include"}),", this is only possible when the template name is a string literal."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from pprint import pprint\nfrom liquid import Environment, DictLoader\n\ntemplates = {\n    "layout": """\\\n        {% include \'nav\', title: page_name %}\n        {% render \'foot\' with website as site_name %}\n    """,\n    "nav": "{{ title }} nav bar",\n    "foot": "a footer for {{ site_name }}",\n}\n\nenv = Environment(loader=DictLoader(templates))\nlayout = env.get_template("layout")\n\nanalysis = layout.analyze(follow_partials=True)\npprint(analysis.variables)\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:'title="output"',children:"{'page_name': [('layout', 1)],\n 'site_name': [('foot', 1)],\n 'title': [('nav', 1)],\n 'website': [('layout', 2)]}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["When the ",(0,l.jsx)(n.code,{children:"raise_for_failures"})," argument is ",(0,l.jsx)(n.code,{children:"True"})," (the default), we should expect a ",(0,l.jsx)(n.a,{href:"/liquid/api/exceptions#liquidexceptionstemplatetraversalerror",children:(0,l.jsx)(n.code,{children:"TemplateTraversalError"})})," to be raised if a partial template can not be loaded. If ",(0,l.jsx)(n.code,{children:"raise_for_failures"})," is ",(0,l.jsx)(n.code,{children:"False"}),", a dictionary of unloadable ",(0,l.jsx)(n.code,{children:"include"}),"/",(0,l.jsx)(n.code,{children:"render"})," tags is available as ",(0,l.jsx)(n.code,{children:"TemplateAnalysis.unloadable_partials"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Environment, DictLoader\n\ntemplates = {\n    "layout": """\\\n        {% include \'nav\', title: page_name %}\n        {% render \'foot\' with website as site_name %}\n    """,\n}\n\nenv = Environment(loader=DictLoader(templates))\nlayout = env.get_template("layout")\n\nanalysis = layout.analyze(follow_partials=True, raise_for_failures=False)\nprint(analysis.unloadable_partials)\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:"title=output",children:"{'foot': [('layout', 2)], 'nav': [('layout', 1)]}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"analyzing-custom-tags",children:"Analyzing Custom Tags"}),"\n",(0,l.jsxs)(n.p,{children:["All built-in tags (the tag's ",(0,l.jsx)(n.code,{children:"Node"})," and ",(0,l.jsx)(n.code,{children:"Expression"})," classes) implement a ",(0,l.jsx)(n.code,{children:"children()"})," method. When analyzing a custom tag that does not implement ",(0,l.jsx)(n.code,{children:"children()"}),", and with the ",(0,l.jsx)(n.code,{children:"raise_for_failures"})," argument set to ",(0,l.jsx)(n.code,{children:"True"})," (the default), Python Liquid will raise a ",(0,l.jsx)(n.a,{href:"/liquid/api/exceptions#liquidexceptionstemplatetraversalerror",children:(0,l.jsx)(n.code,{children:"TemplateTraversalError"})}),". When ",(0,l.jsx)(n.code,{children:"raise_for_failures"})," is ",(0,l.jsx)(n.code,{children:"False"}),", a dictionary of unvisitable AST nodes and expressions is available as ",(0,l.jsx)(n.code,{children:"TemplateAnalysis.failed_visits"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from liquid import Environment, DictLoader\nfrom liquid.ast import Node\nfrom liquid.tag import Tag\n\nclass ExampleNode(Node):\n    def __init__(self, token: Token) -> None:\n        self.tok = token\n\n    def render_to_output(self, context: Context, buffer: TextIO) -> Optional[bool]:\n        buffer.write("example node")\n\n    async def render_to_output_async(\n        self, context: Context, buffer: TextIO\n    ) -> Optional[bool]:\n        buffer.write("example node")\n\n\nclass ExampleTag(Tag):\n    block = False\n    name = "example"\n\n    def parse(self, stream: TokenStream) -> Node:\n        return ExampleNode(stream.current)\n\n\ntemplates = {\n    "layout": "{% example %}"\n}\n\nenv = Environment(loader=DictLoader(templates))\nenv.add_tag(ExampleTag)\nlayout = env.get_template("layout")\n\nanalysis = layout.analyze(follow_partials=True, raise_for_failures=False)\nprint(analysis.failed_visits)\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plain",metastring:"title=output",children:"{'ExampleNode': [('layout', 1)]}\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"liquid.ast.Node.children()"})," should return a list of ",(0,l.jsx)(n.code,{children:"liquid.ast.ChildNode"})," objects. Each ",(0,l.jsx)(n.code,{children:"ChildNode"})," includes a child ",(0,l.jsx)(n.code,{children:"Expression"})," and/or ",(0,l.jsx)(n.code,{children:"Node"}),", plus any names the tag adds to the template local scope or subsequent block scope. Please see ",(0,l.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/tree/main/liquid/builtin/tags",children:"liquid/builtin/tags"})," for examples."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"liquid.expression.Expression.children()"})," is expected to return a list of child ",(0,l.jsx)(n.code,{children:"Expressions"}),". For example, ",(0,l.jsx)(n.code,{children:"liquid.expression.RangeLiteral"})," returns a list containing expressions for its ",(0,l.jsx)(n.code,{children:"start"})," and ",(0,l.jsx)(n.code,{children:"stop"})," properties. Please see ",(0,l.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/blob/main/liquid/expression.py",children:"liquid/expression.py"})," for examples."]})]})}function p(e={}){const{wrapper:n}={...(0,t.useMDXComponents)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.r(n),a.d(n,{MDXProvider:()=>r,useMDXComponents:()=>s});var i=a(6540);const l={},t=i.createContext(l);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);