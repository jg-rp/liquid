"use strict";(self.webpackChunkliquid_docs=self.webpackChunkliquid_docs||[]).push([[9321],{3844:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>c});var i=s(4848),t=s(8453);const d={id:"BoundTemplate"},r="liquid.BoundTemplate",l={id:"api/BoundTemplate",title:"liquid.BoundTemplate",description:"A liquid template that has been parsed and is bound to a liquid.Environment.",source:"@site/docs/api/bound-template.md",sourceDirName:"api",slug:"/api/BoundTemplate",permalink:"/liquid/api/BoundTemplate",draft:!1,unlisted:!1,editUrl:"https://github.com/jg-rp/liquid/tree/docs/docs/api/bound-template.md",tags:[],version:"current",frontMatter:{id:"BoundTemplate"},sidebar:"apiSidebar",previous:{title:"liquid.Environment",permalink:"/liquid/api/Environment"},next:{title:"liquid.loaders.CachingFileSystemLoader",permalink:"/liquid/api/cachingfilesystemloader"}},a={},c=[{value:"<code>BoundTemplate</code>",id:"boundtemplate",level:2},{value:"Properties",id:"properties",level:2},{value:"<code>name</code>",id:"name",level:3},{value:"<code>globals</code>",id:"globals",level:3},{value:"<code>matter</code>",id:"matter",level:3},{value:"<code>is_up_to_date</code>",id:"is_up_to_date",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>analyze</code>",id:"analyze",level:3},{value:"<code>analyze_async</code>",id:"analyze_async",level:3},{value:"<code>analyze_with_context</code>",id:"analyze_with_context",level:3},{value:"<code>analyze_with_context_async</code>",id:"analyze_with_context_async",level:3},{value:"<code>render</code>",id:"render",level:3},{value:"<code>render_async</code>",id:"render_async",level:3},{value:"<code>render_with_context</code>",id:"render_with_context",level:3},{value:"<code>render_with_context_async</code>",id:"render_with_context_async",level:3},{value:"<code>is_up_to_date_async</code>",id:"is_up_to_date_async",level:3}];function o(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.useMDXComponents)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"liquidboundtemplate",children:"liquid.BoundTemplate"}),"\n",(0,i.jsxs)(n.p,{children:["A liquid template that has been parsed and is bound to a ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment",children:(0,i.jsx)(n.code,{children:"liquid.Environment"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["You probably don't want to instantiate ",(0,i.jsx)(n.code,{children:"BoundTemplate"})," directly. Use ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment#from_string",children:(0,i.jsx)(n.code,{children:"liquid.Environment.from_string()"})})," or ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment#get_template",children:(0,i.jsx)(n.code,{children:"liquid.Environment.get_template()"})})," instead."]}),"\n",(0,i.jsx)(n.h2,{id:"boundtemplate",children:(0,i.jsx)(n.code,{children:"BoundTemplate"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"class BoundTemplate(env, parse_tree, [options])"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"env: liquid.Environment"})," - The environment this template is bound to."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"parse_tree: liquid.ast.ParseTree"})," - The parse tree representing this template."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"name: str"})," - Optional name of the template. Defaults to an empty string."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"path: Optional[Union[str, Path]]"})," - Optional origin path or identifier for the template."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"globals: Optional[Dict[str, object]]"})," - An optional mapping of context variables made available every time the resulting template is rendered. Defaults to ",(0,i.jsx)(n.code,{children:"None"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"matter: Optional[Mapping[str, object]]"}),' - Optional mapping containing variables associated with the template. Could be "front matter" or other meta data.']}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"uptodate: Optional[Callable[[], bool]]"})," - Optional callable that will return ",(0,i.jsx)(n.code,{children:"True"})," if the template is up to date, or ",(0,i.jsx)(n.code,{children:"False"})," if it needs to be reloaded. Defaults to ",(0,i.jsx)(n.code,{children:"None"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,i.jsx)(n.h3,{id:"name",children:(0,i.jsx)(n.code,{children:"name"})}),"\n",(0,i.jsxs)(n.p,{children:["The template's name. As it would been passed to ",(0,i.jsx)(n.a,{href:"Environment#get_template",children:(0,i.jsx)(n.code,{children:"liquid.Environment.get_template()"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type"}),": ",(0,i.jsx)(n.code,{children:"str"})]}),"\n",(0,i.jsx)(n.h3,{id:"globals",children:(0,i.jsx)(n.code,{children:"globals"})}),"\n",(0,i.jsx)(n.p,{children:"A dictionary of context variables made available every time this template is rendered."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type"}),": ",(0,i.jsx)(n.code,{children:"Dict[str, object]"})]}),"\n",(0,i.jsx)(n.h3,{id:"matter",children:(0,i.jsx)(n.code,{children:"matter"})}),"\n",(0,i.jsxs)(n.p,{children:["Similar to ",(0,i.jsx)(n.code,{children:"globals"}),", a dictionary of context variables made available every time this template is rendered. ",(0,i.jsx)(n.code,{children:"globals"})," is usually passed down from the environment, ",(0,i.jsx)(n.code,{children:"matter"})," usually originates from a template loader. They are kept separate so subclasses can choose how to merge them."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type"}),": ",(0,i.jsx)(n.code,{children:"Mapping[str, object]"})]}),"\n",(0,i.jsx)(n.h3,{id:"is_up_to_date",children:(0,i.jsx)(n.code,{children:"is_up_to_date"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"True"})," if the template is up to date, ",(0,i.jsx)(n.code,{children:"False"})," otherwise."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type"}),": ",(0,i.jsx)(n.code,{children:"bool"})]}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"analyze",children:(0,i.jsx)(n.code,{children:"analyze"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"analyze(follow_partials, raise_for_failures)"})}),"\n",(0,i.jsx)(n.p,{children:"Statically analyze the template and any included/rendered templates."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"follow_partials: bool"})," - If ",(0,i.jsx)(n.code,{children:"True"}),", we will try to load partial templates and analyze those templates too. Default's to ",(0,i.jsx)(n.code,{children:"True"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"raise_for_failures: bool"})," - If ",(0,i.jsx)(n.code,{children:"True"}),", will raise an exception if an ",(0,i.jsx)(n.code,{children:"ast.Node"})," or ",(0,i.jsx)(n.code,{children:"expression.Expression"})," does not define a ",(0,i.jsx)(n.code,{children:"children()"})," method, or if a partial template can not be loaded. When ",(0,i.jsx)(n.code,{children:"False"}),", no exception is raised and a mapping of failed nodes and expressions is available as the ",(0,i.jsx)(n.code,{children:"failed_visits"})," property. A mapping of unloadable partial templates is stored in the ",(0,i.jsx)(n.code,{children:"unloadable_partials"})," property."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": An object containing analysis results.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.a,{href:"/liquid/api/template-analysis",children:(0,i.jsx)(n.code,{children:"liquid.template.TemplateAnalysis"})})]}),"\n",(0,i.jsx)(n.h3,{id:"analyze_async",children:(0,i.jsx)(n.code,{children:"analyze_async"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"async analyze_async(follow_partials, raise_for_failures)"})}),"\n",(0,i.jsx)(n.p,{children:"Statically analyze the template and any included/rendered templates."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"follow_partials: bool"})," - If ",(0,i.jsx)(n.code,{children:"True"}),", we will try to load partial templates and analyze those templates too. Default's to ",(0,i.jsx)(n.code,{children:"True"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"raise_for_failures: bool"})," - If ",(0,i.jsx)(n.code,{children:"True"}),", will raise an exception if an ",(0,i.jsx)(n.code,{children:"ast.Node"})," or ",(0,i.jsx)(n.code,{children:"expression.Expression"})," does not define a ",(0,i.jsx)(n.code,{children:"children()"})," method, or if a partial template can not be loaded. When ",(0,i.jsx)(n.code,{children:"False"}),", no exception is raised and a mapping of failed nodes and expressions is available as the ",(0,i.jsx)(n.code,{children:"failed_visits"})," property. A mapping of unloadable partial templates is stored in the ",(0,i.jsx)(n.code,{children:"unloadable_partials"})," property."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": An object containing analysis results.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.a,{href:"/liquid/api/template-analysis",children:(0,i.jsx)(n.code,{children:"liquid.template.TemplateAnalysis"})})]}),"\n",(0,i.jsx)(n.h3,{id:"analyze_with_context",children:(0,i.jsx)(n.code,{children:"analyze_with_context"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"analyze_with_context(*args, **kwargs)"})}),"\n",(0,i.jsxs)(n.p,{children:["Analyze a path through this template's syntax tree given some context data. Accepts the same arguments as ",(0,i.jsx)(n.a,{href:"#render",children:(0,i.jsx)(n.code,{children:"render"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": Contextual analysis results\n",(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.a,{href:"/liquid/api/contextual-template-analysis",children:(0,i.jsx)(n.code,{children:"liquid.template.ContextualTemplateAnalysis"})})]}),"\n",(0,i.jsx)(n.h3,{id:"analyze_with_context_async",children:(0,i.jsx)(n.code,{children:"analyze_with_context_async"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"async analyze_with_context_async(*args, **kwargs)"})}),"\n",(0,i.jsxs)(n.p,{children:["Analyze a path through this template's syntax tree given some context data. Accepts the same arguments as ",(0,i.jsx)(n.a,{href:"#render",children:(0,i.jsx)(n.code,{children:"render"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": Contextual analysis results\n",(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.a,{href:"/liquid/api/contextual-template-analysis",children:(0,i.jsx)(n.code,{children:"liquid.template.ContextualTemplateAnalysis"})})]}),"\n",(0,i.jsx)(n.h3,{id:"render",children:(0,i.jsx)(n.code,{children:"render"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"render(*args, **kwargs) -> str"})}),"\n",(0,i.jsxs)(n.p,{children:["Render the template with ",(0,i.jsx)(n.code,{children:"args"})," and ",(0,i.jsx)(n.code,{children:"kwargs"})," included in the render context. Accepts the same arguments as ",(0,i.jsx)(n.code,{children:"dict()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": The rendered template as a string.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.code,{children:"str"})]}),"\n",(0,i.jsx)(n.h3,{id:"render_async",children:(0,i.jsx)(n.code,{children:"render_async"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"async render_async(*args, **kwargs) -> str"})}),"\n",(0,i.jsxs)(n.p,{children:["An async version of ",(0,i.jsx)(n.a,{href:"#render",children:(0,i.jsx)(n.code,{children:"liquid.BoundTemplate.render()"})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": The rendered template as a string.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.code,{children:"str"})]}),"\n",(0,i.jsx)(n.h3,{id:"render_with_context",children:(0,i.jsx)(n.code,{children:"render_with_context"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"render_with_context(context, buffer, *args, **kwargs) -> None"})}),"\n",(0,i.jsxs)(n.p,{children:["Render the template using an existing ",(0,i.jsx)(n.a,{href:"/liquid/api/context",children:(0,i.jsx)(n.code,{children:"liquid.Context"})})," and output buffer. ",(0,i.jsx)(n.code,{children:"args"})," and ",(0,i.jsx)(n.code,{children:"kwargs"})," are passed to ",(0,i.jsx)(n.code,{children:"dict()"}),". The resulting dictionary is added to the render context."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"context: liquid.Context"})," - A render context."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"buffer: TextIO"})," - File-like object to which rendered text is written."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.code,{children:"None"})]}),"\n",(0,i.jsx)(n.h3,{id:"render_with_context_async",children:(0,i.jsx)(n.code,{children:"render_with_context_async"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"async render_with_context_async(context, buffer, *args, **kwargs) -> None"})}),"\n",(0,i.jsxs)(n.p,{children:["An async version of ",(0,i.jsx)(n.a,{href:"#render_with_context",children:(0,i.jsx)(n.code,{children:"liquid.BoundTemplate.render_with_context()"})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return Type"}),": ",(0,i.jsx)(n.code,{children:"None"})]}),"\n",(0,i.jsx)(n.h3,{id:"is_up_to_date_async",children:(0,i.jsx)(n.code,{children:"is_up_to_date_async"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"async is_up_to_date_async() -> bool"})}),"\n",(0,i.jsxs)(n.p,{children:["Return ",(0,i.jsx)(n.code,{children:"True"})," if the template is up to date, ",(0,i.jsx)(n.code,{children:"False"})," otherwise."]})]})}function h(e={}){const{wrapper:n}={...(0,t.useMDXComponents)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.r(n),s.d(n,{MDXProvider:()=>l,useMDXComponents:()=>r});var i=s(6540);const t={},d=i.createContext(t);function r(e){const n=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(d.Provider,{value:n},e.children)}}}]);