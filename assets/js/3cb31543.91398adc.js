"use strict";(self.webpackChunkliquid_docs=self.webpackChunkliquid_docs||[]).push([[133],{241:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=t(5893),r=t(1151);const s={},a="Custom Tags",o={id:"guides/custom-tags",title:"Custom Tags",description:"A Liquid tag is defined by a pair of Python classes. One a subclass of liquid.tag.Tag and one a subclass of liquid.ast.Node. The required parse() method of a Tag is responsible for parsing a tag's expression and returning a Node, which will be added to a template's parse tree.",source:"@site/docs/guides/custom-tags.md",sourceDirName:"guides",slug:"/guides/custom-tags",permalink:"/liquid/guides/custom-tags",draft:!1,unlisted:!1,editUrl:"https://github.com/jg-rp/liquid/tree/docs/docs/guides/custom-tags.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Custom Filters",permalink:"/liquid/guides/custom-filters"},next:{title:"Custom Loaders",permalink:"/liquid/guides/custom-loaders"}},d={},l=[{value:"Add a Tag",id:"add-a-tag",level:2},{value:"Example Tag",id:"example-tag",level:3},{value:"Example Node",id:"example-node",level:3},{value:"Example Tag Usage",id:"example-tag-usage",level:3},{value:"Replace a Tag",id:"replace-a-tag",level:2},{value:"Remove a Tag",id:"remove-a-tag",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.useMDXComponents)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"custom-tags",children:"Custom Tags"}),"\n",(0,i.jsxs)(n.p,{children:["A Liquid ",(0,i.jsx)(n.a,{href:"/liquid/language/introduction#tags",children:"tag"})," is defined by a pair of Python classes. One a subclass of ",(0,i.jsx)(n.a,{href:"/liquid/api/Tag",children:(0,i.jsx)(n.code,{children:"liquid.tag.Tag"})})," and one a subclass of ",(0,i.jsx)(n.a,{href:"/liquid/api/node",children:(0,i.jsx)(n.code,{children:"liquid.ast.Node"})}),". The required ",(0,i.jsx)(n.code,{children:"parse()"})," method of a ",(0,i.jsx)(n.code,{children:"Tag"})," is responsible for parsing a tag's expression and returning a ",(0,i.jsx)(n.code,{children:"Node"}),", which will be added to a template's parse tree."]}),"\n",(0,i.jsxs)(n.p,{children:["You can add to, remove or modify Liquid's built-in tags to suit your needs by registering tags with an ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment",children:(0,i.jsx)(n.code,{children:"Environment"})}),", then rendering your templates from that environment."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["All built-in tags are implemented in this way, so have a look in ",(0,i.jsx)(n.a,{href:"https://github.com/jg-rp/liquid/tree/main/liquid/builtin/tags",children:"liquid/builtin/tags/"})," for examples."]})}),"\n",(0,i.jsx)(n.h2,{id:"add-a-tag",children:"Add a Tag"}),"\n",(0,i.jsxs)(n.p,{children:["Taking inspiration from ",(0,i.jsx)(n.a,{href:"https://docs.djangoproject.com/en/3.2/ref/templates/builtins/#with",children:"Django's Template Language"}),", lets implement a ",(0,i.jsx)(n.code,{children:"with"})," tag, which extends the local scope for the duration of its block. Our ",(0,i.jsx)(n.code,{children:"with"})," tag's expressions consists of one or more named arguments separated by commas. Each argument is a variable name, followed by a colon, then a Liquid keyword, string, integer, float, range expression or identifier."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plain",children:"{% with <identifier>: <object> [, <identifier>: <object> ... ] %}\n  <literal,statement,tag> ...\n{% endwith %}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This implementation keeps any variables set inside the ",(0,i.jsx)(n.code,{children:"with"})," block (using ",(0,i.jsx)(n.code,{children:"assign"})," or ",(0,i.jsx)(n.code,{children:"capture"}),") alive after the block has been rendered."]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["You can find an alternative implementation of the ",(0,i.jsx)(n.code,{children:"with"})," tag in ",(0,i.jsx)(n.a,{href:"https://gist.github.com/jg-rp/4ee5a864b57ea756800786833e4af1ee",children:"this gist"}),". It uses ",(0,i.jsx)(n.a,{href:"https://github.com/dabeaz/sly",children:"SLY"})," to tokenize and parse ",(0,i.jsx)(n.code,{children:"with"})," expressions."]}),(0,i.jsx)(n.p,{children:"While this alternative implementation is arguably easier to understand and maintain, it does not lend itself to static type checking and is slower than the approach used by Python Liquid's built-in tags."})]}),"\n",(0,i.jsx)(n.h3,{id:"example-tag",children:"Example Tag"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.a,{href:"/liquid/api/Tag",children:(0,i.jsx)(n.code,{children:"Tag"})})," is free to parse its expression any way it chooses. Built in tags use regular expressions to generate a stream of tokens, then step through those tokens yielding ",(0,i.jsx)(n.code,{children:"Expression"})," objects."]}),"\n",(0,i.jsxs)(n.p,{children:["Here we'll reuse the tokenizer from the ",(0,i.jsx)(n.a,{href:"/liquid/language/tags#include",children:(0,i.jsx)(n.code,{children:"include"})})," tag, as it, too, accepts any number of comma separated named arguments. We will, however, supply a different set of allowed keywords to the tokenizer function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="with_tag.py"',children:'from __future__ import annotations\n\nimport sys\n\nfrom functools import partial\n\nfrom typing import TYPE_CHECKING\nfrom typing import Dict\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import TextIO\n\nfrom liquid.ast import Node\nfrom liquid.ast import BlockNode\n\nfrom liquid.context import Context\nfrom liquid.expression import Expression\n\nfrom liquid.lex import include_expression_rules\nfrom liquid.lex import _compile_rules\nfrom liquid.lex import _tokenize\n\nfrom liquid.parse import expect\nfrom liquid.parse import get_parser\nfrom liquid.parse import parse_expression\nfrom liquid.parse import parse_unchained_identifier\n\nfrom liquid.stream import TokenStream\nfrom liquid.tag import Tag\n\nfrom liquid.token import Token\nfrom liquid.token import TOKEN_TAG\nfrom liquid.token import TOKEN_EXPRESSION\nfrom liquid.token import TOKEN_TRUE\nfrom liquid.token import TOKEN_FALSE\nfrom liquid.token import TOKEN_NIL\nfrom liquid.token import TOKEN_NULL\nfrom liquid.token import TOKEN_COLON\nfrom liquid.token import TOKEN_AS\nfrom liquid.token import TOKEN_EOF\nfrom liquid.token import TOKEN_COMMA\n\n\nif TYPE_CHECKING:\n    from liquid import Environment\n\nTAG_WITH = sys.intern("with")\nTAG_ENDWITH = sys.intern("endwith")\n\nwith_expression_keywords = frozenset(\n    [\n        TOKEN_TRUE,\n        TOKEN_FALSE,\n        TOKEN_NIL,\n        TOKEN_NULL,\n        TOKEN_AS,\n    ]\n)\n\ntokenize_with_expression = partial(\n    _tokenize,\n    rules=_compile_rules(include_expression_rules),\n    keywords=with_expression_keywords,\n)\n\n\nclass WithKeywordArg(NamedTuple):\n    name: str\n    expr: Expression\n\n# ...\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/liquid/api/Tag#parse",children:(0,i.jsx)(n.code,{children:"parse()"})})," method of a ",(0,i.jsx)(n.code,{children:"Tag"})," object receives a ",(0,i.jsx)(n.code,{children:"TokenStream"})," as its only argument. This stream of tokens includes template literals, output statements, tags and unparsed tag expressions."]}),"\n",(0,i.jsxs)(n.p,{children:["The current token in the stream will always be of the type ",(0,i.jsx)(n.code,{children:"TOKEN_TAG"}),", representing the start of the tag we're parsing. By convention, this token is used to populate the ",(0,i.jsx)(n.code,{children:"token"})," property of the associated ",(0,i.jsx)(n.code,{children:"Node"})," object. If the tag has an expression (anything after the tag's name), it will immediately follow the ",(0,i.jsx)(n.code,{children:"TOKEN_TAG"})," in the stream as a ",(0,i.jsx)(n.code,{children:"TOKEN_EXPRESSION"}),". In the example bellow we use ",(0,i.jsx)(n.code,{children:"expect()"})," to confirm that an expression has been provided."]}),"\n",(0,i.jsxs)(n.p,{children:["We retrieve a ",(0,i.jsx)(n.code,{children:"Parser"})," from the active ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment",children:(0,i.jsx)(n.code,{children:"Environment"})}),", then use its ",(0,i.jsx)(n.code,{children:"parse_block"})," method parse our ",(0,i.jsx)(n.code,{children:"with"})," tag's block, which could contain any number of other tags and output statements. Every block tag is expected to leave the stream with it's \"end\" tag as the current token."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"parse_argument"})," is an implementation detail and not a required method of ",(0,i.jsx)(n.a,{href:"/liquid/api/Tag",children:(0,i.jsx)(n.code,{children:"liquid.tag.Tag"})}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="with_tag.py (continued)"',children:"class WithTag(Tag):\n    name = TAG_WITH\n    end = TAG_ENDWITH\n\n    def __init__(self, env: Environment):\n        super().__init__(env)\n        self.parser = get_parser(self.env)\n\n    def parse(self, stream: TokenStream) -> Node:\n        expect(stream, TOKEN_TAG, value=TAG_WITH)\n        tok = stream.current\n\n        stream.next_token()\n        expect(stream, TOKEN_EXPRESSION)\n        expr_stream = TokenStream(tokenize_with_expression(stream.current.value))\n\n        # A dictionary to help handle duplicate keywords.\n        args = {}\n\n        while expr_stream.current.type != TOKEN_EOF:\n            key, expr = self.parse_argument(expr_stream)\n            args[key] = expr\n\n            if expr_stream.current.type == TOKEN_COMMA:\n                expr_stream.next_token()  # Eat comma\n\n        stream.next_token()\n        block = self.parser.parse_block(stream, (TAG_ENDWITH, TOKEN_EOF))\n        expect(stream, TOKEN_TAG, value=TAG_ENDWITH)\n\n        return WithNode(tok=tok, args=args, block=block)\n\n    def parse_argument(self, stream: TokenStream) -> WithKeywordArg:\n        key = str(parse_unchained_identifier(stream))\n        stream.next_token()\n\n        expect(stream, TOKEN_COLON)\n        stream.next_token()  # Eat colon\n\n        val = parse_expression(stream)\n        stream.next_token()\n\n        return WithKeywordArg(key, val)\n\n# ...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-node",children:"Example Node"}),"\n",(0,i.jsxs)(n.p,{children:["Every ",(0,i.jsx)(n.a,{href:"/liquid/api/node",children:(0,i.jsx)(n.code,{children:"Node"})})," must implement a ",(0,i.jsx)(n.a,{href:"/liquid/api/node#render_to_output",children:(0,i.jsx)(n.code,{children:"render_to_output()"})})," method and, optionally, a ",(0,i.jsx)(n.a,{href:"/liquid/api/node#render_to_output_async",children:(0,i.jsx)(n.code,{children:"render_to_output_async()"})})," method. By referencing its ",(0,i.jsx)(n.code,{children:"Expression"}),"'s and the active render context, ",(0,i.jsx)(n.code,{children:"render_to_output()"})," is responsible for writing text to the output buffer."]}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"WithNode"})," simply evaluates each of its arguments and uses the results to extend the scope of the active render context before rendering its block."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="with_tag.py (continued)"',children:"class WithNode(Node):\n    def __init__(self, tok: Token, args: Dict[str, Expression], block: BlockNode):\n        self.tok = tok\n        self.args = args\n        self.block = block\n\n    def render_to_output(self, context: Context, buffer: TextIO) -> Optional[bool]:\n        namespace = {k: v.evaluate(context) for k, v in self.args.items()}\n\n        with context.extend(namespace):\n            self.block.render(context, buffer)\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-tag-usage",children:"Example Tag Usage"}),"\n",(0,i.jsxs)(n.p,{children:["We can add ",(0,i.jsx)(n.code,{children:"WithTag"})," tag to an ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment",children:(0,i.jsx)(n.code,{children:"Environment"})})," like this. Notice that ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment#add_tag",children:(0,i.jsx)(n.code,{children:"Environment.add_tag()"})})," takes a class, not a class instance."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from liquid import Environment\nfrom with_tag import WithTag\n\nenv = Environment()\nenv.add_tag(WithTag)\n\ntemplate = env.from_string(\n    "{% with greeting: \'Hello\', name: \'Sally\' -%}"\n    "  {{ greeting }}, {{ name }}!"\n    "{%- endwith %}"\n)\n\nprint(template.render()) # Hello, Sally\n'})}),"\n",(0,i.jsx)(n.h2,{id:"replace-a-tag",children:"Replace a Tag"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/liquid/api/Environment#add_tag",children:"Environment.add_tag()"})," registers a tag using the ",(0,i.jsx)(n.code,{children:"name"})," property\ndefined on the ",(0,i.jsx)(n.code,{children:"Tag"})," class. If you register a tag with the same name as an existing tag, it will be replaced without warning."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, the non-standard ",(0,i.jsx)(n.a,{href:"/liquid/extra/tags#if-not",children:"if (not)"})," tag is a drop-in replacement for the standard ",(0,i.jsx)(n.code,{children:"if"})," tag."]}),"\n",(0,i.jsx)(n.h2,{id:"remove-a-tag",children:"Remove a Tag"}),"\n",(0,i.jsxs)(n.p,{children:["Remove a tag, either built-in or custom, by deleting it from ",(0,i.jsx)(n.a,{href:"/liquid/api/Environment",children:"Environment.tags"}),". It's a regular dictionary mapping tag names to ",(0,i.jsx)(n.code,{children:"Tag"})," classes."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from liquid import Environment\nfrom liquid.builtin.tags.ifchanged_tag import IfChangedTag\n\nenv = Environment()\ndel env.filters[IfChangedTag.name]\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.useMDXComponents)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.r(n),t.d(n,{MDXProvider:()=>o,useMDXComponents:()=>a});var i=t(7294);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);