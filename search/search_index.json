{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Liquid","text":"<p>Python Liquid is a Python engine for Liquid, the safe, customer-facing template language. We follow Shopify/Liquid closely and test against the Golden Liquid test suite.</p> <p>Note</p> <p>This is the documentation for the latest version of Python Liquid (GitHub). Find archived documentation for Python Liquid version 1.x here.</p>"},{"location":"#install","title":"Install","text":"<p>Install Python Liquid from PyPi using pip:</p> <pre><code>python -m pip install python-liquid\n</code></pre> <p>Or Pipenv:</p> <pre><code>pipenv install -u python-liquid\n</code></pre> <p>Or poetry</p> <pre><code>poetry add python-liquid\n</code></pre> <p>Or from conda-forge:</p> <pre><code>conda install -c conda-forge python-liquid\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#render","title":"<code>render()</code>","text":"<p>This example renders a template from a string of text with the package-level <code>render()</code> function. The template has just one placeholder variable <code>you</code>, which we've given the value <code>\"World\"</code>.</p> <pre><code>from liquid import render\n\nprint(render(\"Hello, {{ you }}!\", you=\"World\"))\n# Hello, World!\n</code></pre>"},{"location":"#parse","title":"<code>parse()</code>","text":"<p>Often you'll want to render the same template several times with different variables. We can parse source text without immediately rendering it using the <code>parse()</code> function. <code>parse()</code> returns a <code>BoundTemplate</code> instance with a <code>render()</code> method.</p> <pre><code>from liquid import parse\n\ntemplate = parse(\"Hello, {{ you }}!\")\nprint(template.render(you=\"World\"))  # Hello, World!\nprint(template.render(you=\"Liquid\"))  # Hello, Liquid!\n</code></pre>"},{"location":"#configure","title":"Configure","text":"<p>Both <code>parse()</code> and <code>render()</code> are convenience functions that use the default Liquid environment. For all but the simplest cases you'll want to configure an instance of <code>Environment</code>, then load and render templates from that.</p> <pre><code>from liquid import CachingFileSystemLoader\nfrom liquid import Environment\n\nenv = Environment(\n    autoescape=True,\n    loader=CachingFileSystemLoader(\"./templates\"),\n)\n</code></pre> <p>Then, using <code>env.parse()</code> or <code>env.get_template()</code>, we can create a <code>BoundTemplate</code> from a string or read from the file system, respectively.</p> <pre><code># ... continued from above\ntemplate = env.parse(\"Hello, {{ you }}!\")\nprint(template.render(you=\"World\"))  # Hello, World!\n\n# Try to load \"./templates/index.html\"\nanother_template = env.get_template(\"index.html\")\ndata = {\"some\": {\"thing\": [1, 2, 3]}}\nresult = another_template.render(**data)\n</code></pre> <p>Unless you happen to have a relative folder called <code>templates</code> with a file called <code>index.html</code> within it, we would expect a <code>TemplateNotFoundError</code> to be raised when running the example above.</p>"},{"location":"#whats-next","title":"What's next?","text":"<p>Read more about configuring Liquid environments, template loaders and managing render context data.</p>"},{"location":"babel/","title":"Internationalization and localization","text":"<p>This page covers i18n and l10n filter and tag configuration, and how we support translations and translation message catalogs. See the filter reference and tag reference for usage examples.</p>"},{"location":"babel/#currency","title":"Currency","text":"<p>The <code>currency</code> filter returns the input number formatted as currency for the current locale. For usage examples see <code>currency</code> in the filter reference.</p>"},{"location":"babel/#options","title":"Options","text":"<p><code>currency</code> defaults to looking for a locale in a render context variable called <code>locale</code>, and a currency code in a render context variable called <code>currency_code</code>. It outputs in the locale's standard format and falls back to <code>en_US</code> and <code>USD</code> if those context variables don't exist.</p> <pre><code>from liquid import parse\n\ntemplate = parse(\"{{ 100457.99 | currency }}\")\n\nprint(template.render())\nprint(template.render(currency_code=\"GBP\"))\nprint(template.render(locale=\"de\", currency_code=\"CAD\"))\n</code></pre> output<pre><code>$100,457.99\n\u00a3100,457.99\n100.457,99\u00a0CA$\n</code></pre> <p>To configure <code>currency</code>, register a new instance of <code>Currency</code> with an <code>Environment</code>, then render your templates from that. See the API reference for details of all arguments accepted by <code>Currency</code>.</p> <pre><code>from liquid.extra import Currency\nfrom liquid import Environment\n\nenv = Environment()\nenv.filters[\"currency\"] = Currency(default_locale=\"de\")\n</code></pre>"},{"location":"babel/#money","title":"Money","text":"<p>For convenience, some \"money\" filters are defined that mimic Shopify's money filter behavior. These are instances of <code>Currency()</code> with specific default formats. All other currency options are set to their defaults.</p> <pre><code>from liquid import parse\n\ntemplate = parse(\"\"\"\\\n{% assign amount = 10 %}\n{{ amount | money }}\n{{ amount | money_with_currency }}\n{{ amount | money_without_currency }}\n{{ amount | money_without_trailing_zeros }}\"\"\")\n\nprint(template.render(currency_code=\"CAD\", locale=\"en_CA\"))\n</code></pre> output<pre><code>$10.00\n$10.00 CAD\n10.00\n$10\n</code></pre>"},{"location":"babel/#datetime","title":"DateTime","text":"<p>The <code>datetime</code> filter returns the input datetime formatted for the current locale. For usage examples see <code>datetime</code> in the filter reference.</p>"},{"location":"babel/#options_1","title":"Options","text":"<p><code>datetime</code> defaults to looking for a timezone in a render context variable called <code>timezone</code>, a locale in a render context variable called <code>locale</code> and a datetime format in a render context variable called <code>datetime_format</code>.</p> <pre><code>from liquid import parse\n\ntemplate = parse(\"{{ 'Apr 1, 2007, 3:30:00 PM' | datetime }}\")\n\nprint(template.render())\nprint(template.render(locale=\"de\", datetime_format=\"long\"))\nprint(template.render(locale=\"de\", timezone=\"CET\", datetime_format=\"short\"))\n</code></pre> output<pre><code>Apr 1, 2007, 3:30:00 PM\n1. April 2007 um 15:30:00 UTC\n01.04.07, 17:30\n</code></pre> <p>To configure <code>datetime</code>, register a new instance of <code>DateTime</code> with an <code>Environment</code>, then render your templates from that. See the API reference for details of all arguments accepted by <code>DateTime</code>.</p> <pre><code>from liquid.extra import DateTime\nfrom liquid import Environment\n\nenv = Environment()\nenv.filters[\"datetime\"] = DateTime(timezone_var=\"tz\")\n</code></pre>"},{"location":"babel/#decimal","title":"Decimal","text":"<p>The <code>decimal</code> filter returns the input number formatted as a decimal for the current locale. For usage examples see <code>decimal</code> in the filter reference.</p>"},{"location":"babel/#options_2","title":"Options","text":"<p><code>decimal</code> defaults to looking for a locale in a render context variable called <code>locale</code>. It uses the locale's standard format and falls back to <code>en_US</code> if that variable does not exist.</p> <pre><code>from liquid import parse\n\n# Parse a number from a string in the default (en_US) input locale.\ntemplate = parse(\"\"\"\\\n{{ '10,000.23' | decimal }}\n{{ '10,000.23' | decimal: group_separator: false }}\n\"\"\")\n\nprint(template.render(locale=\"de\"))\nprint(template.render(locale=\"en_GB\"))\n</code></pre> output<pre><code>10.000,23\n10000,23\n\n10,000.23\n10000.23\n</code></pre> <p>To configure <code>decimal</code>, register a new instance of <code>Number</code> with an <code>Environment</code>, then render your templates from that.</p> <pre><code>from liquid.extra import Number\nfrom liquid import Environment\n\nenv = Environment()\nenv.filters[\"decimal\"] = Number(default_locale=\"en_GB\")\n</code></pre>"},{"location":"babel/#unit","title":"Unit","text":"<p>The <code>unit</code> filter returns he input number formatted with the given units according to the current locale. For usage examples see <code>unit</code> in the filter reference.</p>"},{"location":"babel/#options_3","title":"Options","text":"<p><code>unit</code> defaults to looking for a locale in a render context variable called <code>locale</code>, a length in a render context variable called <code>unit_length</code>, and a decimal format in a render context variable called <code>unit_format</code>.</p> <pre><code>from liquid import parse\n\ntemplate = parse(\"\"\"\\\n{{ 12 | unit: 'length-meter', format: '#,##0.00' }}\n{{ 150 | unit: 'kilowatt', denominator_unit: 'hour' }}\n\"\"\")\n\nprint(template.render(unit_length=\"long\"))\nprint(template.render(locale=\"de\", unit_length=\"long\"))\n</code></pre> output<pre><code>12.00 meters\n150 kilowatts per hour\n\n12,00 Meter\n150 Kilowatt pro Stunde\n</code></pre> <p>To configure <code>unit</code>, register a new instance of <code>Unit</code> with an <code>Environment</code>, then render your templates from that.</p> <pre><code>from liquid.extra import Unit\nfrom liquid import Environment\n\nenv = Environment()\nenv.filters[\"unit\"] = Unit(locale_var=\"_locale\")\n</code></pre>"},{"location":"babel/#translations","title":"Translations","text":"<p>Liquid Babel includes <code>gettext</code>, <code>ngettext</code>, <code>pgettext</code> and <code>npgettext</code> filter equivalents to the functions found in Python's gettext module. Application developers can choose to use any of these filters, possibly using more user friendly filter names, and/or the more general <code>t (translate)</code> filter.</p> <p>The <code>t</code> filter can behave like any of the *gettext filters, depending on the arguments it is given. Where the *gettext filters require positional arguments for <code>context</code>, <code>count</code> and <code>plural</code>, <code>t</code> reserves optional <code>count</code> and <code>plural</code> keyword arguments.</p> <p>Liquid Babel also offers a <code>{% translate %}</code> tag. This is similar to the <code>{% trans %}</code> tag found in Jinja or the <code>{% blocktranslate %}</code> tag found in Django's template language. Again, application developers can configure and customize the included <code>translate</code> tag to suit an application's needs.</p>"},{"location":"babel/#filters","title":"Filters","text":"<p><code>gettext</code>, <code>ngettext</code>, <code>npgettext</code>, <code>pgettext</code> and <code>t</code> filters all default to looking for translations in a render context variable called <code>translations</code>, falling back to an instance of <code>NullTranslations</code> if <code>translations</code> can not be resolved.</p> <pre><code>from liquid import parse\n\n# You'll need to load an appropriate Translations object.\n# `get_translations()` is defined elsewhere.\ntranslations = get_translations(locale=\"de\")\n\ntemplate = parse(\"{{ 'Hello, World!' | t }}\")\nprint(template.render(translations=translations))  # Hallo Welt!\n</code></pre> <p>To configure <code>gettext</code>, <code>ngettext</code>, <code>npgettext</code>, <code>pgettext</code> or <code>t</code>, register a new instance of <code>GetText</code>, <code>NGetText</code>, <code>NPGetText</code>, <code>PGetText</code> or <code>Translate</code> with an <code>Environment</code>, then render your templates from that. All of these classes inherit from <code>BaseTranslateFilter</code> and accept the same constructor arguments.</p>"},{"location":"babel/#message-catalogs","title":"Message catalogs","text":"<p>By default, all translation filters and tags will look for a render context variable called <code>translations</code>, which must be an object implementing the <code>Translations</code> protocol. It is the application developer's responsibility to provide a <code>Translations</code> object, being the interface between Liquid and a message catalog.</p> <p>The <code>Translations</code> protocol is defined as follows. It is simply a subset of the <code>NullTranslations</code> class found in the gettext module.</p> <pre><code>class Translations(Protocol):\n    def gettext(self, message: str) -&gt; str:\n        ...\n\n    def ngettext(self, singular: str, plural: str, n: int) -&gt; str:\n        ...\n\n    def pgettext(self, context: str, message: str) -&gt; str:\n        ...\n\n    def npgettext(self, context: str, singular: str, plural: str, n: int) -&gt; str:\n        ...\n</code></pre> <p>It could be a <code>GNUTranslations</code> instance, a Babel <code>Translations</code> instance, or any object implementing <code>gettext</code>, <code>ngettext</code>, <code>pgettext</code> and <code>npgettext</code> methods.</p>"},{"location":"babel/#message-variables","title":"Message variables","text":"<p>Translatable message text can contain placeholders for variables. When using variables in strings to be translated by filters, variables are defined using percent-style formatting. Only the <code>s</code> modifier is supported and every variable must have a name. In this example <code>you</code> is the variable name.</p> <pre><code>{{ \"Hello, %(you)s!\" | t }}\n</code></pre> <p>Filter keyword arguments are merged with the current render context before being used to replace variables in message text. All variables are converted to their string representation before substitution. Dotted property/attribute access is not supported inside message variables.</p> <pre><code>{{ \"Hello, %(you)s!\" | t: you: user.name }}\n</code></pre> <p>The <code>translate</code> block tag recognizes simplified Liquid output statements as translation message variables. These variables must be valid identifiers without dotted or bracketed property/attribute access, and no filters.</p> <pre><code>{% translate %}\n    Hello, {{ you }}!\n{% endtranslate %}\n</code></pre> <p>Keyword arguments passed to the <code>translate</code> tag will be merged with the current render context before being used to replace variables in message text.</p> <pre><code>{% translate you: user.name, count: users.size %}\n    Hello, {{ you }}!\n{% plural %}\n    Hello, {{ you }}s!\n{% endtranslate %}\n</code></pre>"},{"location":"babel/#message-extraction","title":"Message Extraction","text":"<p>Use the <code>extract_from_templates()</code> function to build a message catalog from one or more templates. You are then free to make use of Babel's PO file features, or convert the catalog to a more convenient internal representation.</p> <pre><code>import io\n\nfrom babel.messages.pofile import write_po\n\nfrom liquid import parse\nfrom liquid.messages import extract_from_templates\n\nsource = \"\"\"\n{% # Translators: some comment %}\n{{ 'Hello, World!' | t }}\n{% comment %}Translators: other comment{% endcomment %}\n{% translate count: 2 %}\n    Hello, {{ you }}!\n{% plural %}\n    Hello, all!\n{% endtranslate %}\n\"\"\"\n\ntemplate = parse(source, name=\"something.liquid\")\ncatalog = extract_from_templates(template)\n\nbuf = io.BytesIO()\nwrite_po(buf, catalog, omit_header=True)\nprint(buf.getvalue().decode(\"utf-8\"))\n</code></pre> output<pre><code>#. Translators: some comment\n#: something.liquid:3\nmsgid \"Hello, World!\"\nmsgstr \"\"\n\n#. Translators: other comment\n#: something.liquid:5\n#, python-format\nmsgid \"Hello, %(you)s!\"\nmsgid_plural \"Hello, all!\"\nmsgstr[0] \"\"\nmsgstr[1] \"\"\n</code></pre>"},{"location":"babel/#translator-comments","title":"Translator Comments","text":"<p>When a Liquid comment tag immediately precedes a translatable filter or tag, and the comment starts with a string in <code>comment_tags</code>, that comment will be included as a translator comment with the message. Use the <code>comment_tags</code> argument to <code>extract_liquid()</code>, or <code>extract_from_templates()</code> to change translator comment prefixes. The default is <code>[\"Translators:\"]</code>.</p> <pre><code>from liquid import parse\nfrom liquid.messages import extract_from_templates\n\nsource = \"\"\"\n{% # Translators: some comment %}\n{{ 'Hello, World!' | t }}\n{% comment %}Translators: other comment{% endcomment %}\n{% translate count: 2 %}\n    Hello, {{ you }}!\n{% plural %}\n    Hello, all!\n{% endtranslate %}\n\"\"\"\n\ntemplate = parse(source, name=\"something.liquid\")\ncatalog = extract_from_templates(template, strip_comment_tags=True)\n\nmessage = catalog.get(\"Hello, World!\")\nprint(message.auto_comments[0])  # some comment\n</code></pre>"},{"location":"custom_filters/","title":"Custom filters","text":"<p>Filters are usually implemented as simple Python functions. When rendered, Liquid will find the function in <code>Environment.filters</code>, then call it, passing the input value as the first argument, followed by positional and keyword arguments given by the template author. The function's return value then becomes the result of the filtered expression.</p> <p>Filters can actually be any Python callable. Implementing a filter as a class with a <code>__call__</code> method or as a closure can be useful if you want to configure the filter before registering it with an <code>Environment</code>.</p> <p>Also see the filter helpers API documentation.</p> <p>Tip</p> <p>See liquid/builtin/filters for lots of examples.</p>"},{"location":"custom_filters/#add-a-filter","title":"Add a filter","text":"<p>To add a filter, add an item to <code>Environment.filters</code>. It's a regular dictionary mapping filter names to callables.</p> <p>In this example we add <code>ends_with</code>, a filter that delegates to Python's <code>str.endswith</code>. The <code>@string_filter</code> decorator coerces the input value to a string, if it is not one already.</p> <pre><code>from liquid import Environment\nfrom liquid.filter import string_filter\n\n\n@string_filter\ndef ends_with(left: str, val: str) -&gt; bool:\n    return left.endswith(val)\n\n\nenv = Environment()\nenv.filters[\"ends_with\"] = ends_with\n\nsource = \"\"\"\\\n{% assign foo = \"foobar\" | ends_with: \"bar\" %}\n{% if foo %}\n    do something\n{% endif %}\"\"\"\n\ntemplate = env.from_string(source)\nprint(template.render())\n</code></pre>"},{"location":"custom_filters/#with-context","title":"With context","text":"<p>Sometimes a filter will need access to the current render context. Use the <code>@with_context</code> decorator to have an instance of <code>RenderContext</code> passed to your filter callable as a keyword argument named <code>context</code>.</p> <p>Here we use the render context to resolve a variable called \"handle\".</p> <pre><code>from liquid import Environment\nfrom liquid.filter import string_filter\nfrom liquid.filter import with_context\n\n\n@string_filter\n@with_context\ndef link_to_tag(label, tag, *, context):\n    handle = context.resolve(\"handle\", default=\"\")\n    return (\n        f'&lt;a title=\"Show tag {tag}\" href=\"/collections/{handle}/{tag}\"&gt;{label}&lt;/a&gt;'\n    )\n\nclass MyEnvironment(Environment):\n    def register_tags_and_filters(self):\n        super().register_tags_and_filters()\n        self.filters[\"link_to_tag\"] = link_to_tag\n\nenv = MyEnvironment()\n# ...\n</code></pre>"},{"location":"custom_filters/#with-environment","title":"With environment","text":"<p>Use the <code>@with_environment</code> decorator to have the current <code>Environment</code> passed to your filter callable as a keyword argument named <code>environment</code>.</p> <pre><code>import re\n\nfrom markupsafe import Markup\nfrom markupsafe import escape as markupsafe_escape\n\nfrom liquid import Environment\nfrom liquid.filter import string_filter\nfrom liquid.filter import with_environment\n\nRE_LINETERM = re.compile(r\"\\r?\\n\")\n\n\n@with_environment\n@string_filter\ndef strip_newlines(val: str, *, environment: Environment) -&gt; str:\n    if environment.autoescape:\n        val = markupsafe_escape(val)\n        return Markup(RE_LINETERM.sub(\"\", val))\n    return RE_LINETERM.sub(\"\", val)\n\n# ...\n</code></pre>"},{"location":"custom_filters/#replace-a-filter","title":"Replace a filter","text":"<p>To replace a default filter implementation with your own, simply update the <code>filters</code> dictionary on your Liquid Environment.</p> <p>Here we replace the default <code>slice</code> filter with one which uses start and stop values instead of start and length, and is a bit more forgiving in terms of allowed inputs.</p> <pre><code>from liquid import Environment\nfrom liquid.filter import int_arg\nfrom liquid.filter import sequence_filter\n\n@sequence_filter\ndef myslice(val, start, stop=None):\n    start = int_arg(start)\n\n    if stop is None:\n        return val[start]\n\n    stop = int_arg(stop)\n    return val[start:stop]\n\n\nenv = Environment()\nenv.filters[\"slice\"] = myslice\n# ...\n</code></pre>"},{"location":"custom_filters/#remove-a-filter","title":"Remove a filter","text":"<p>Remove a built-in filter by deleting it from your environment's <code>filters</code> dictionary.</p> <pre><code>from liquid import Environment\n\nenv = Environment()\ndel env.filters[\"safe\"]\n\n# ...\n</code></pre> <p>Tip</p> <p>You can add, remove and replace filters on <code>liquid.DEFAULT_ENVIRONMENT</code> too. Convenience functions <code>parse()</code> and <code>render()</code> use <code>DEFAULT_ENVIRONMENT</code></p>"},{"location":"custom_tags/","title":"Custom tags","text":"<p>A Liquid tag is defined by a class extending <code>Tag</code>. It has just one abstract method, <code>parse()</code>, which takes an instance of <code>TokenStream</code> and returns a <code>Node</code>. The returned node will be added to a template's abstract syntax tree and, when rendered, its <code>render_to_output()</code> method will be called.</p> <p><code>render_to_output()</code> receives the active render context and an output buffer. It is responsible for either updating the render context or writing to the buffer, or both.</p> <p>Tip</p> <p>See liquid/builtin/tags for lots of examples.</p>"},{"location":"custom_tags/#add-a-tag","title":"Add a tag","text":"<p>This example implements the <code>with</code> tag, which allows template authors to define block scoped variables. <code>{% with %}</code> is a block tag. It has a start tag, an end tag (<code>{% endwith %}</code>), and Liquid markup in between. We should ensure that we leave the closing tag token at the head of the stream.</p>"},{"location":"custom_tags/#the-tag","title":"The tag","text":"with_tag.py<pre><code>from typing import TextIO\n\nfrom liquid import BlockNode\nfrom liquid import Node\nfrom liquid import RenderContext\nfrom liquid import Tag\nfrom liquid import Token\nfrom liquid import TokenStream\nfrom liquid.builtin.expressions import KeywordArgument\nfrom liquid.parser import get_parser\nfrom liquid.token import TOKEN_EOF\nfrom liquid.token import TOKEN_TAG\n\n\nclass WithTag(Tag):\n\n    name = \"with\"\n    block = True\n\n    def parse(self, stream: TokenStream) -&gt; Node:\n        # Assert that the token at the head of the stream is a tag token\n        # and consume it.\n        token = stream.eat(TOKEN_TAG)\n\n        # Using the KeywordArgument.parse static method ensure consistent\n        # parsing behavior between tags.\n        args = KeywordArgument.parse(self.env, stream.into_inner(tag=token))\n\n        # Parse Liquid markup until we reach a tag called \"endwith\" or the end\n        # of the stream\n        block = get_parser(self.env).parse_block(stream, (\"endwith\", TOKEN_EOF))\n\n        # Assert that the token at the head of the stream is a tag token\n        # called \"endwith\".\n        stream.expect(TOKEN_TAG, value=\"endwith\")\n\n        return WithNode(token, args, block)\n</code></pre> <p>When <code>parse()</code> is called, the token at the head of the stream is guaranteed to be of type <code>TOKEN_TAG</code>, representing the start of our tag. For block tags, like <code>{% with %}</code>, we use <code>TokenStream.eat()</code> to both assert the current token type and consume it.</p> <p><code>{% with %}</code> expects one or more arguments in the form of key/value pairs. <code>TokenStream.into_inner()</code> asserts that the next token is of type <code>TOKEN_EXPRESSION</code> and returns a new stream of tokens over the tag's expression. Here we've passed it straight to <code>KeywordArgument.parse()</code> because we only want to accepts key/value arguments in this example.</p> <p>Next we get an instance of <code>Parser</code> and use it to parse a block of Liquid markup until we reach a tag called \"endwith\". <code>TokenStream.expect()</code> asserts that we did find an \"endwith\" tag an not reach the end of the stream.</p>"},{"location":"custom_tags/#the-node","title":"The node","text":"with_tag.py (continued)<pre><code>class WithNode(Node):\n    __slots__ = (\"args\", \"block\")\n\n    def __init__(self, token: Token, args: list[KeywordArgument], block: BlockNode):\n        super().__init__(token)\n        self.args = args\n        self.block = block\n        self.blank = self.block.blank\n\n    def render_to_output(self, context: RenderContext, buffer: TextIO) -&gt; int:\n        namespace = dict(arg.evaluate(context) for arg in self.args)\n\n        with context.extend(namespace):\n            return self.block.render(context, buffer)\n</code></pre> <p><code>WithNode.render_to_output()</code> evaluates its arguments, extends the render context and renders its block to the output buffer. The <code>RenderContext.extend</code> context manager is used to ensure the variables added by our tag go out of scope after the block has been rendered.</p>"},{"location":"custom_tags/#usage","title":"Usage","text":"<p>We can now register <code>WithTag</code> with a Liquid environment using <code>Environment.add_tag</code>.</p> <pre><code>from liquid import Environment\n\nfrom .with_tag import WithTag\n\nenv = Environment()\nenv.add_tag(WithTag)\n\ntemplate = env.from_string(\n\"{% with greeting: 'Hello', name: 'Sally' -%}\"\n\"  {{ greeting }}, {{ name }}!\"\n\"{%- endwith %}\"\n)\n\nprint(template.render()) # Hello, Sally\n</code></pre>"},{"location":"custom_tags/#replace-a-tag","title":"Replace a tag","text":"<p><code>Environment.add_tag</code> uses the <code>name</code> class attribute of its argument when registering tags. If your custom tag has a name matching a builtin tag, <code>add_tag()</code> will replace it without warning.</p> <pre><code>from liquid import Environment\nfrom .my_tag import MyTag\n\nenv = Environment()\nenv.add_tag(MyTag)\n\n# ...\n</code></pre>"},{"location":"custom_tags/#remove-a-tag","title":"Remove a tag","text":"<p>Remove a built-in tag by deleting it from your environment's <code>tags</code> dictionary. The example removes the builtin <code>ifchanged</code> tag</p> <pre><code>from liquid import Environment\n\nenv = Environment()\ndel env.tags[\"ifchanged\"]\n\n# ...\n</code></pre> <p>Tip</p> <p>You can add, remove and replace tags on <code>liquid.DEFAULT_ENVIRONMENT</code> too. Convenience functions <code>parse()</code> and <code>render()</code> use <code>DEFAULT_ENVIRONMENT</code></p>"},{"location":"environment/","title":"Liquid environments","text":"<p>Template parsing and rendering behavior is configured using an instance of <code>Environment</code>. Once configured, you'd parse templates with <code>Environment.from_string()</code> or <code>Environment.get_template()</code>, both of which return an instance of <code>BoundTemplate</code>.</p>"},{"location":"environment/#the-default-environment","title":"The default environment","text":"<p>The default environment, <code>liquid.DEFAULT_ENVIRONMENT</code>, and an instance of <code>Environment</code> without any arguments are equivalent to the following <code>Environment</code> subclass and constructor arguments.</p> <pre><code>from liquid import BoundTemplate\nfrom liquid import DictLoader\nfrom liquid import Environment\nfrom liquid import Mode\nfrom liquid import Undefined\nfrom liquid import builtin\n\n\nclass MyLiquidEnvironment(Environment):\n    context_depth_limit = 30\n    loop_iteration_limit = None\n    local_namespace_limit = None\n    output_stream_limit = None\n    template_class = BoundTemplate\n    suppress_blank_control_flow_blocks = True\n    shorthand_indexes = False\n    string_sequences = False\n    string_first_and_last = False\n    logical_not_operator = False\n    logical_parentheses = False\n    ternary_expressions = False\n    keyword_assignment = False\n\n    def setup_tags_and_filters(self):\n        builtin.register(self)\n\n\nenv = MyLiquidEnvironment(\n    autoescape=False,\n    comment_end_string=\"#}\",\n    comment_start_string=\"{#\",\n    extra=False,\n    globals=None,\n    loader=DictLoader({}),\n    statement_end_string=r\"}}\",\n    statement_start_string=r\"{{\",\n    strict_filters=True,\n    tag_end_string=r\"%}\",\n    tag_start_string=r\"{%\",\n    template_comments=False,\n    tolerance=Mode.STRICT,\n    undefined=Undefined,\n)\n</code></pre>"},{"location":"environment/#managing-tags-and-filters","title":"Managing tags and filters","text":"<p><code>liquid.builtin.register()</code> registers all the default tags and filters with the environment. You are encouraged to override <code>setup_tags_and_filters()</code> in your <code>Environment</code> subclasses to add optional or custom tags and filters, remove unwanted default tags and filters, and possibly replace default implementation with your own.</p> <p>It's also OK to manipulate <code>Environment.tags</code> and <code>Environment.filters</code> directly after an <code>Environment</code> instance has been created. They are just dictionaries mapping tag names to instances of <code>Tag</code> and filter names to callables, respectively.</p> <pre><code>from liquid import Environment\n\nenv = Environment()\ndel env.tags[\"include\"]\n</code></pre>"},{"location":"environment/#extra-tags-and-filters","title":"Extra tags and filters","text":"<p>Python Liquid includes some extra tags and extra filters that are not enabled by default. If you want to enable them all, pass <code>extra=True</code> when constructing a Liquid <code>Environment</code>.</p> <pre><code>from liquid import Environment\n\nenv = Environment(extra=True)\nprint(env.render(\"{{ 100457.99 | money }}\"))\n# $100,457.99\n</code></pre>"},{"location":"environment/#managing-global-variables","title":"Managing global variables","text":"<p>By default, global template variables attached to instances of <code>BoundTemplate</code> take priority over global template variables attached to an <code>Environment</code>. You can change this priority or otherwise manipulate the <code>globals</code> dictionary for a <code>BoundTemplate</code> by overriding <code>Environment.make_globals()</code>.</p> <p>Also see Render context data.</p> <pre><code>from typing import Mapping\nfrom liquid import Environment\n\nclass MyLiquidEnvironment(Environment):\n\n    def make_globals(\n        self,\n        globals: Mapping[str, object] | None = None,\n    ) -&gt; dict[str, object]:\n        \"\"\"Combine environment globals with template globals.\"\"\"\n        if globals:\n            # Template globals take priority over environment globals.\n            return {**self.globals, **globals}\n        return dict(self.globals)\n</code></pre>"},{"location":"environment/#tolerance","title":"Tolerance","text":"<p>Templates are parsed and rendered in strict mode by default. Where syntax and render-time type errors raise an exception as soon as possible. You can change the error tolerance mode with the <code>tolerance</code> argument to <code>Environment</code>.</p> <p>Available modes are <code>Mode.STRICT</code>, <code>Mode.WARN</code> and <code>Mode.LAX</code>.</p> <pre><code>from liquid import Environment\nfrom liquid import FileSystemLoader\nfrom liquid import Mode\n\nenv = Environment(\n    loader=FileSystemLoader(\"templates/\"),\n    tolerance=Mode.LAX,\n)\n</code></pre>"},{"location":"environment/#html-auto-escape","title":"HTML auto escape","text":"<p>When <code>autoescape</code> is <code>True</code>, render context variables will be automatically escaped to produce HTML-safe strings on output.</p> <p>You can be explicitly mark strings as safe by wrapping them in <code>Markup()</code> and drops can implement the special <code>__html__()</code> method.</p> <pre><code>from markupsafe import Markup\nfrom liquid import Environment\n\nenv = Environment(autoescape=True)\ntemplate = env.from_string(\"&lt;p&gt;Hello, {{ you }}&lt;/p&gt;\")\nprint(template.render(you=Markup(\"&lt;em&gt;World!&lt;/em&gt;\")))\n</code></pre>"},{"location":"environment/#resource-limits","title":"Resource limits","text":"<p>For deployments where template authors are untrusted, you can set limits on some resources to avoid malicious templates from consuming too much memory or too many CPU cycles. Limits are set by subclassing <code>Environment</code> and setting some class attributes.</p> <pre><code>from liquid import Environment\n\nclass MyEnvironment(Environment):\n    context_depth_limit = 30\n    local_namespace_limit = 2000\n    loop_iteration_limit = 1000\n    output_stream_limit = 15000\n\n\nenv = MyEnvironment()\n\ntemplate = env.from_string(\"\"\"\\\n{% for x in (1..1000000) %}\n{% for y in (1..1000000) %}\n    {{ x }},{{ y }}\n{% endfor %}\n{% endfor %}\n\"\"\")\n\ntemplate.render()\n# liquid.exceptions.LoopIterationLimitError: loop iteration limit reached\n</code></pre>"},{"location":"environment/#context-depth-limit","title":"Context depth limit","text":"<p><code>context_depth_limit</code> is the maximum number of times a render context can be extended or wrapped before a <code>ContextDepthError</code> is raised. This helps us guard against recursive use of the <code>include</code> and <code>render</code> tags. The default context depth limit is 30.</p> <pre><code>from liquid import Environment\nfrom liquid import DictLoader\n\nenv = Environment(\n    loader=DictLoader(\n        {\n            \"foo\": \"{% render 'bar' %}\",\n            \"bar\": \"{% render 'foo' %}\",\n        }\n    )\n)\n\ntemplate = env.from_string(\"{% render 'foo' %}\")\ntemplate.render()\n# liquid.exceptions.ContextDepthError: maximum context depth reached, possible recursive render\n#   -&gt; '{% render 'bar' %}' 1:3\n#   |\n# 1 | {% render 'bar' %}\n#   |    ^^^^^^ maximum context depth reached, possible recursive render\n</code></pre>"},{"location":"environment/#local-namespace-limit","title":"Local Namespace Limit","text":"<p><code>local_namespace_limit</code> is the maximum number of bytes (according to <code>sys.getsizeof()</code>) allowed in a template's local namespace, per render, before a <code>LocalNamespaceLimitError</code> exception is raised. Note that we only count the size of the local namespace values, not its keys.</p> <p>The default <code>local_namespace_limit</code> is <code>None</code>, meaning there is no limit.</p> <pre><code>from liquid import Environment\n\nclass MyEnvironment(Environment):\n    local_namespace_limit = 50  # Very low, for demonstration purposes.\n\nenv = MyEnvironment()\n\ntemplate = env.from_string(\"\"\"\\\n{% assign x = \"Nunc est nulla, pellentesque ac dui id erat curae.\" %}\n\"\"\")\n\ntemplate.render()\n# liquid.exceptions.LocalNamespaceLimitError: local namespace limit reached\n</code></pre> <p>Warning</p> <p>PyPy does not implement <code>sys.getsizeof</code>. Instead of a size in bytes, when run with PyPy, <code>local_namespace_limit</code> will degrade to being the number of distinct values in a template's local namespace.</p>"},{"location":"environment/#loop-iteration-limit","title":"Loop Iteration Limit","text":"<p><code>loop_iteration_limit</code> is the maximum number of loop iterations allowed before a <code>LoopIterationLimitError</code> is raised.</p> <p>The default <code>loop_iteration_limit</code> is <code>None</code>, meaning there is no limit.</p> <pre><code>from liquid import Environment\n\nclass MyEnvironment(Environment):\n    loop_iteration_limit = 999\n\n\nenv = MyEnvironment()\n\ntemplate = env.from_string(\"\"\"\\\n{% for x in (1..100) %}\n{% for y in (1..100) %}\n    {{ x }},{{ y }}\n{% endfor %}\n{% endfor %}\n\"\"\")\n\ntemplate.render()\n# liquid.exceptions.LoopIterationLimitError: loop iteration limit reached\n</code></pre> <p>Other built in tags that contribute to the loop iteration counter are <code>render</code>, <code>include</code> (when using their <code>{% render 'thing' for some.thing %}</code> syntax) and <code>tablerow</code>. If a partial template is rendered within a <code>for</code> loop, the loop counter is carried over to the render context of the partial template.</p>"},{"location":"environment/#output-stream-limit","title":"Output Stream Limit","text":"<p>The maximum number of bytes that can be written to a template's output stream, per render, before an <code>OutputStreamLimitError</code> exception is raised. The default <code>output_stream_limit</code> is <code>None</code>, meaning there is no limit.</p> <pre><code>from liquid import Environment\n\nclass MyEnvironment(Environment):\n    output_stream_limit = 20  # Very low, for demonstration purposes.\n\n\nenv = MyEnvironment()\n\ntemplate = env.from_string(\"\"\"\\\n{% if false %}\nthis is never rendered, so will not contribute the the output byte counter\n{% endif %}\nHello, {{ you }}!\n\"\"\")\n\ntemplate.render(you=\"World\")\n# '\\nHello, World!\\n'\n\ntemplate.render(you=\"something longer that exceeds our limit\")\n# liquid.exceptions.OutputStreamLimitError: output stream limit reached\n</code></pre>"},{"location":"environment/#string-sequences","title":"String sequences","text":"<p>By default, strings in Liquid can not be looped over with the <code>{% for %}</code> tag and characters in a string can not be selected by index.</p> <p>Setting the <code>string_sequences</code> class attribute to <code>True</code> tells Python Liquid to treat strings as sequences, meaning we can loop over Unicode characters in a string or retrieve a Unicode \"character\" by its index.</p>"},{"location":"environment/#string-first-and-last","title":"String first and last","text":"<p>Strings don't respond to the special <code>.first</code> and <code>.last</code> properties by default. Set <code>string_first_and_last</code> to <code>True</code> to enable <code>.first</code> and <code>.last</code> for strings.</p>"},{"location":"environment/#logical-not-operator","title":"Logical not operator","text":"<p>The logical <code>not</code> operator is disabled by default. Set the <code>logical_not_operator</code> class attribute to <code>True</code> to enable <code>not</code> inside <code>{% if %}</code>, <code>{% unless %}</code> and ternary expressions.</p>"},{"location":"environment/#logical-parentheses","title":"Logical parentheses","text":"<p>By default, terms in <code>{% if %}</code> tag expressions can not be grouped to control precedence. Set the <code>logical_parentheses</code> class attribute to <code>True</code> to enable grouping terms with parentheses.</p>"},{"location":"environment/#ternary-expressions","title":"Ternary expressions","text":"<p>Enable ternary expressions in output statements, assign tags and echo tags by setting the <code>ternary_expressions</code> class attribute to <code>True</code>.</p> <pre><code>{{ &lt;expression&gt; if &lt;expression&gt; else &lt;expression&gt; }}\n</code></pre> <p>Inline conditional expressions can be used as an alternative to the longer form <code>{% if %}</code> tag.</p> <pre><code>{{ \"bar\" if x.y == z else \"baz\" }}\n</code></pre> <p>Filters can be applied to either branch.</p> <pre><code>{{ \"bar\" | upcase if x else \"baz\" | capitalize }}\n</code></pre> <p>Or applied to the result of the conditional expression as a whole using tail filters. Notice the double pipe symbol (<code>||</code>).</p> <pre><code>{{ \"bar\" if x else \"baz\" || upcase | append: \"!\" }}\n</code></pre>"},{"location":"environment/#keyword-assignment","title":"Keyword assignment","text":"<p>By default, named arguments must separated names from values with a colon (<code>:</code>). Set the <code>keyword_assignment</code> class attribute to <code>True</code> to allow equals (<code>=</code>) or a colon between names and their values.</p>"},{"location":"environment/#whats-next","title":"What's next?","text":"<p>See loading templates for more information about configuring a template loader and undefined variables for information about managing undefined variables.</p>"},{"location":"filter_reference/","title":"Default filters","text":"<p>All the filters described here are enabled by default in Python Liquid.</p>"},{"location":"filter_reference/#abs","title":"abs","text":"<pre><code>&lt;number&gt; | abs\n</code></pre> <p>Return the absolute value of a number. Works on integers, floats and string representations of integers or floats.</p> <pre><code>{{ -42 | abs }}\n{{ 7.5 | abs }}\n{{ '42.0' | abs }}\n</code></pre> output<pre><code>42\n7.5\n42.0\n</code></pre> <p>Given a value that can't be cast to an integer or float, <code>0</code> will be returned.</p> <pre><code>{{ 'hello' | abs }}\n{{ nosuchthing | abs }}\n</code></pre> output<pre><code>0\n0\n</code></pre>"},{"location":"filter_reference/#append","title":"append","text":"<pre><code>&lt;string&gt; | append: &lt;string&gt;\n</code></pre> <p>Return the input value concatenated with the argument value.</p> <pre><code>{{ 'Hello, ' | append: 'World!' }}\n</code></pre> output<pre><code>Hello, World!\n</code></pre> <p>If either the input value or argument are not a string, they will be coerced to a string before concatenation.</p> <pre><code>{% assign a_number = 7.5 -%}\n{{ 42 | append: a_number }}\n{{ nosuchthing | append: 'World!' }}\n</code></pre> output<pre><code>427.5\nWorld!\n</code></pre>"},{"location":"filter_reference/#at_least","title":"at_least","text":"<pre><code>&lt;number&gt; | at_least: &lt;number&gt;\n</code></pre> <p>Return the maximum of the filter's input value and its argument. If either input value or argument are string representations of an integer or float, they will be cast to an integer or float prior to comparison.</p> <pre><code>{{ -5.1 | at_least: 8 }}\n{{ 8 | at_least: '5' }}\n</code></pre> output<pre><code>8\n8\n</code></pre> <p>If either input value or argument can not be cast to an integer or float, <code>0</code> will be used instead.</p> <pre><code>{{ \"hello\" | at_least: 2 }}\n{{ \"hello\" | at_least: -2 }}\n{{ -1 | at_least: \"abc\" }}\n</code></pre> output<pre><code>2\n0\n0\n</code></pre>"},{"location":"filter_reference/#at_most","title":"at_most","text":"<pre><code>&lt;number&gt; | at_most: &lt;number&gt;\n</code></pre> <p>Return the minimum of the filter's input value and its argument. If either input value or argument are string representations of an integer or float, they will be cast to an integer or float prior to comparison.</p> <pre><code>{{ 5 | at_most: 8 }}\n{{ '8' | at_most: 5 }}\n</code></pre> output<pre><code>5\n5\n</code></pre> <p>If either input value or argument can not be cast to an integer or float, <code>0</code> will be used instead.</p> <pre><code>{{ \"hello\" | at_most: 2 }}\n{{ \"hello\" | at_most: -2 }}\n{{ -1 | at_most: \"abc\" }}\n</code></pre> output<pre><code>0\n-2\n-1\n</code></pre>"},{"location":"filter_reference/#capitalize","title":"capitalize","text":"<pre><code>&lt;string&gt; | capitalize\n</code></pre> <p>Return the input string with the first character in upper case and the rest lowercase.</p> <pre><code>{{ 'heLLO, World!' | capitalize }}\n</code></pre> output<pre><code>Hello, world!\n</code></pre> <p>If the input value is not a string, it will be converted to a string.</p> <pre><code>{{ 42 | capitalize }}\n</code></pre> output<pre><code>42\n</code></pre>"},{"location":"filter_reference/#ceil","title":"ceil","text":"<pre><code>&lt;number&gt; | ceil\n</code></pre> <p>Round the input value up to the nearest whole number. The input value will be converted to a number if it is not an integer or float.</p> <pre><code>{{ 5.1 | ceil }}\n{{ 5.0 | ceil }}\n{{ 5 | ceil }}\n{{ '5.4' | ceil }}\n</code></pre> output<pre><code>6\n5\n5\n5\n</code></pre> <p>If the input is undefined or can't be converted to a number, <code>0</code> is returned.</p> <pre><code>{{ 'hello' | ceil }}\n{{ nosuchthing | ceil }}\n</code></pre> output<pre><code>0\n0\n</code></pre>"},{"location":"filter_reference/#compact","title":"compact","text":"<pre><code>&lt;array&gt; | compact[: &lt;string&gt;]\n</code></pre> <p>Remove <code>nil</code>/<code>null</code> (or <code>None</code> in Python) values from an array-like object. If given, the argument should be the name of a property that exists on each item (hash, dict etc.) in the array-like sequence.</p> <p>For example, ff <code>pages</code> is an array of objects, some of which have a <code>category</code> property:</p> data<pre><code>{\n  \"pages\": [\n    { \"category\": \"business\" },\n    { \"category\": \"celebrities\" },\n    {},\n    { \"category\": \"lifestyle\" },\n    { \"category\": \"sports\" },\n    {},\n    { \"category\": \"technology\" }\n  ]\n}\n</code></pre> <p>Without <code>compact</code>, iterating those categories will include <code>nil</code>/<code>null</code> values.</p> <pre><code>{% assign categories = pages | map: \"category\" -%}\n\n{% for category in categories -%}\n- {{ category }}\n{%- endfor %}\n</code></pre> output<pre><code>- business\n- celebrities\n-\n- lifestyle\n- sports\n-\n- technology\n</code></pre> <p>With <code>compact</code>, we can remove those missing categories before the loop.</p> <pre><code>{% assign categories = pages | map: \"category\" | compact %}\n\n{% for category in categories %}\n- {{ category }}\n{% endfor %}\n</code></pre> output<pre><code>- business\n- celebrities\n- lifestyle\n- sports\n- technology\n</code></pre> <p>Using the optional argument to <code>compact</code>, we could avoid using <code>map</code> and create an array of pages with a <code>category</code> property, rather than an array of categories.</p> <pre><code>{% assign pages_with_category = pages | compact: \"category\" %}\n\n{% for page in pages_with_category %}\n- {{ page.category }}\n{% endfor %}\n</code></pre> output<pre><code>- business\n- celebrities\n- lifestyle\n- sports\n- technology\n</code></pre>"},{"location":"filter_reference/#concat","title":"concat","text":"<pre><code>&lt;array&gt; | concat: &lt;array&gt;\n</code></pre> <p>Create a new array by joining one array-like object with another.</p> <pre><code>{% assign fruits = \"apples, oranges, peaches\" | split: \", \" %}\n{% assign vegetables = \"carrots, turnips, potatoes\" | split: \", \" %}\n\n{% assign everything = fruits | concat: vegetables %}\n\n{% for item in everything %}\n- {{ item }}\n{% endfor %}\n</code></pre> output<pre><code>- apples\n- oranges\n- peaches\n- carrots\n- turnips\n- potatoes\n</code></pre> <p>If the input value is not array-like, it will be converted to an array. No conversion is attempted for the argument value.</p> <pre><code>{% assign fruits = \"apples, oranges, peaches\" | split: \", \" -%}\n{% assign things = \"hello\" | concat: fruits -%}\n\n{% for item in things -%}\n- {{ item }}\n{% endfor %}\n</code></pre> output<pre><code>- h\n- e\n- l\n- l\n- o\n- apples\n- oranges\n- peaches\n</code></pre> <p>If the input is a nested array, it will be flattened before concatenation. The argument is not flattened.</p> data<pre><code>{\n  \"a\": [\n    [\"a\", \"x\"],\n    [\"b\", [\"y\", [\"z\"]]]\n  ],\n  \"b\": [\"c\", \"d\"]\n}\n</code></pre> <pre><code>{{ a | concat: b | join: '#' }}\n</code></pre> output<pre><code>a#x#b#y#z#c#d\n</code></pre>"},{"location":"filter_reference/#date","title":"date","text":"<pre><code>&lt;datetime&gt; | date: &lt;string&gt;\n</code></pre> <p>Format a date and/or time according the the given format string. The input can be a string, in which case the string will be parsed as a date/time before formatting.</p> <p>Warning</p> <p>Python Liquid uses dateutil for parsing strings to <code>datetimes</code>, and <code>strftime</code> for formatting. There are likely to be some inconsistencies between this and Ruby Liquid's Time.parse equivalent parsing and formatting of dates and times.</p> <p>In general, Python Liquid will raise an exception if the input value can not be converted to a date and/or time. Whereas Ruby Liquid will usually return something without erroring.</p> <pre><code>{{ \"March 14, 2016\" | date: \"%b %d, %y\" }}\n</code></pre> output<pre><code>Mar 14, 16\n</code></pre> <p>The special <code>'now'</code> or <code>'today'</code> input values can be used to get the current timestamp. <code>'today'</code> is an alias for <code>'now'</code>. Both include time information.</p> <pre><code>{{ \"now\" | date: \"%Y-%m-%d %H:%M\" }}\n</code></pre> output<pre><code>2021-12-02 10:17\n</code></pre> <p>If the input is undefined, an empty string is returned.</p> <pre><code>{{ nosuchthing | date: \"%Y-%m-%d %H:%M\" }}\n</code></pre> output<pre><code>\n</code></pre>"},{"location":"filter_reference/#default","title":"default","text":"<pre><code>&lt;expression&gt; | default[: &lt;object&gt;[, allow_false:&lt;bool&gt;]]\n</code></pre> <p>Return a default value if the input is undefined, <code>nil</code>/<code>null</code>, <code>false</code> or empty, or return the input unchanged otherwise.</p> <pre><code>{{ product_price | default: 2.99 }}\n\n{%- assign product_price = \"\" %}\n{{ product_price | default: 2.99 }}\n\n{%- assign product_price = 4.99 %}\n{{ product_price | default: 2.99 }}\n</code></pre> output<pre><code>2.99\n2.99\n4.99\n</code></pre> <p>If the optional <code>allow_false</code> argument is <code>true</code>, an input of <code>false</code> will not return the default. <code>allow_false</code> defaults to <code>false</code>.</p> <pre><code>{% assign product_reduced = false -%}\n{{ product_reduced | default: true, allow_false: true }}\n</code></pre> output<pre><code>false\n</code></pre> <p>If no argument is given, the default value will be an empty string.</p> <pre><code>{{ product_price | default }}\n</code></pre> output<pre><code>\n</code></pre> <p>Empty strings, arrays and objects all cause the default value to be returned. <code>0</code> does not.</p> <pre><code>{{ \"\" | default: \"hello\" }}\n{{ 0 | default: 99 }}\n</code></pre> output<pre><code>hello\n0\n</code></pre>"},{"location":"filter_reference/#divided_by","title":"divided_by","text":"<pre><code>&lt;number&gt; | divided_by: &lt;number&gt;\n</code></pre> <p>Divide a number by another number. The result is rounded down to the nearest integer if the divisor is an integer.</p> <pre><code>{{ 16 | divided_by: 4 }}\n{{ 5 | divided_by: 3 }}\n</code></pre> output<pre><code>4\n1\n</code></pre> <p>If you divide by a float, the result will be a float.</p> <pre><code>{{ 20 | divided_by: 7 }}\n{{ 20 | divided_by: 7.0 }}\n</code></pre> output<pre><code>2\n2.857142857142857\n</code></pre> <p>If either the input or argument are not an integer or float, Liquid will try to convert them to an integer or float. If the input can't be converted, <code>0</code> will be used instead. If the argument can't be converted, an exception is raised.</p> <pre><code>{{ \"20\" | divided_by: \"7\" }}\n{{ \"hello\" | divided_by: 2 }}\n</code></pre> output<pre><code>2\n0\n</code></pre>"},{"location":"filter_reference/#downcase","title":"downcase","text":"<pre><code>&lt;string&gt; | downcase\n</code></pre> <p>Return the input string with all characters in lowercase.</p> <pre><code>{{ 'Hello, World!' | downcase }}\n</code></pre> output<pre><code>hello, world!\n</code></pre> <p>If the input is not a string, Liquid will convert it to a string before forcing characters to lowercase.</p> <pre><code>{{ 5 | downcase }}\n</code></pre> output<pre><code>5\n</code></pre> <p>If the input is undefined, an empty string is returned.</p>"},{"location":"filter_reference/#escape","title":"escape","text":"<pre><code>&lt;string&gt; | escape\n</code></pre> <p>Return the input string with characters <code>&amp;</code>, <code>&lt;</code> and <code>&gt;</code> converted to HTML-safe sequences.</p> <pre><code>{{ \"Have you read 'James &amp; the Giant Peach'?\" | escape }}\n</code></pre> output<pre><code>Have you read &amp;#39;James &amp;amp; the Giant Peach&amp;#39;?\n</code></pre>"},{"location":"filter_reference/#escape_once","title":"escape_once","text":"<pre><code>&lt;string&gt; | escape_once\n</code></pre> <p>Return the input string with characters <code>&amp;</code>, <code>&lt;</code> and <code>&gt;</code> converted to HTML-safe sequences while preserving existing HTML escape sequences.</p> <pre><code>{{ \"Have you read 'James &amp;amp; the Giant Peach'?\" | escape_once }}\n</code></pre> output<pre><code>Have you read &amp;#39;James &amp;amp; the Giant Peach&amp;#39;?\n</code></pre>"},{"location":"filter_reference/#find","title":"find","text":"<pre><code>&lt;array&gt; | find: &lt;string&gt;[, &lt;object&gt;]\n</code></pre> <p>Return the first item in the input array that contains a property, given as the first argument, equal to the value given as the second argument. If no such item exists, <code>null</code> is returned.</p> <p>In this example we select the first page in the \"Programming\" category.</p> data<pre><code>{\n  \"pages\": [\n    {\n      \"id\": 1,\n      \"title\": \"Introduction to Cooking\",\n      \"category\": \"Cooking\",\n      \"tags\": [\"recipes\", \"beginner\", \"cooking techniques\"]\n    },\n    {\n      \"id\": 2,\n      \"title\": \"Top 10 Travel Destinations in Europe\",\n      \"category\": \"Travel\",\n      \"tags\": [\"Europe\", \"destinations\", \"travel tips\"]\n    },\n    {\n      \"id\": 3,\n      \"title\": \"Mastering JavaScript\",\n      \"category\": \"Programming\",\n      \"tags\": [\"JavaScript\", \"web development\", \"coding\"]\n    }\n  ]\n}\n</code></pre> <pre><code>{% assign page = pages | find: 'category', 'Programming' %}\n{{ page.title }}\n</code></pre> output<pre><code>Mastering JavaScript\n</code></pre>"},{"location":"filter_reference/#find_index","title":"find_index","text":"<p>Return the index of the first item in the input array that contains a property, given as the first argument, equal to the value given as the second argument. If no such item exists, <code>null</code> is returned.</p> <p>In this example we find the index for the first page in the \"Programming\" category.</p> data<pre><code>{\n  \"pages\": [\n    {\n      \"id\": 1,\n      \"title\": \"Introduction to Cooking\",\n      \"category\": \"Cooking\",\n      \"tags\": [\"recipes\", \"beginner\", \"cooking techniques\"]\n    },\n    {\n      \"id\": 2,\n      \"title\": \"Top 10 Travel Destinations in Europe\",\n      \"category\": \"Travel\",\n      \"tags\": [\"Europe\", \"destinations\", \"travel tips\"]\n    },\n    {\n      \"id\": 3,\n      \"title\": \"Mastering JavaScript\",\n      \"category\": \"Programming\",\n      \"tags\": [\"JavaScript\", \"web development\", \"coding\"]\n    }\n  ]\n}\n</code></pre> <pre><code>{% assign index = pages | find_index: 'category', 'Programming' %}\n{{ pages[index].title }}\n</code></pre> output<pre><code>Mastering JavaScript\n</code></pre>"},{"location":"filter_reference/#first","title":"first","text":"<pre><code>&lt;sequence&gt; | first\n</code></pre> <p>Return the first item of the input sequence. The input could be array-like or a mapping, but not a string.</p> <pre><code>{{ \"Ground control to Major Tom.\" | split: \" \" | first }}\n</code></pre> output<pre><code>Ground\n</code></pre> <p>If the input sequence is undefined, empty or not a sequence, <code>nil</code> is returned.</p>"},{"location":"filter_reference/#floor","title":"floor","text":"<pre><code>&lt;number&gt; | floor\n</code></pre> <p>Return the input down to the nearest whole number. Liquid tries to convert the input to a number before the filter is applied.</p> <pre><code>{{ 1.2 | floor }}\n{{ 2.0 | floor }}\n{{ 183.357 | floor }}\n{{ -5.4 | floor }}\n{{ \"3.5\" | floor }}\n</code></pre> output<pre><code>1\n2\n183\n-6\n3\n</code></pre> <p>If the input can't be converted to a number, <code>0</code> is returned.</p>"},{"location":"filter_reference/#has","title":"has","text":"<pre><code>&lt;array&gt; | has: &lt;string&gt;[, &lt;object&gt;]\n</code></pre> <p>Return <code>true</code> if the input array contains an object with a property identified by the first argument that is equal to the object given as the second argument. <code>false</code> is returned if none of the items in the input array contain such a property/value.</p> <p>In this example we test to see if any pages are in the \"Programming\" category.</p> data<pre><code>{\n  \"pages\": [\n    {\n      \"id\": 1,\n      \"title\": \"Introduction to Cooking\",\n      \"category\": \"Cooking\",\n      \"tags\": [\"recipes\", \"beginner\", \"cooking techniques\"]\n    },\n    {\n      \"id\": 2,\n      \"title\": \"Top 10 Travel Destinations in Europe\",\n      \"category\": \"Travel\",\n      \"tags\": [\"Europe\", \"destinations\", \"travel tips\"]\n    },\n    {\n      \"id\": 3,\n      \"title\": \"Mastering JavaScript\",\n      \"category\": \"Programming\",\n      \"tags\": [\"JavaScript\", \"web development\", \"coding\"]\n    }\n  ]\n}\n</code></pre> <pre><code>{% assign has_programming_page = pages | has: 'category', 'Programming' %}\n{{ has_programming_page }}\n</code></pre> output<pre><code>true\n</code></pre>"},{"location":"filter_reference/#join","title":"join","text":"<pre><code>&lt;array&gt; | join[: &lt;string&gt;]\n</code></pre> <p>Return the items in the input array as a single string, separated by the argument string. If the input is not an array, Liquid will convert it to one. If input array items are not strings, they will be converted to strings before joining.</p> <pre><code>{% assign beatles = \"John, Paul, George, Ringo\" | split: \", \" -%}\n\n{{ beatles | join: \" and \" }}\n</code></pre> output<pre><code>John and Paul and George and Ringo\n</code></pre> <p>If an argument string is not given, it defaults to a single space.</p> <pre><code>{% assign beatles = \"John, Paul, George, Ringo\" | split: \", \" -%}\n\n{{ beatles | join }}\n</code></pre> output<pre><code>John Paul George Ringo\n</code></pre>"},{"location":"filter_reference/#last","title":"last","text":"<pre><code>&lt;array&gt; | last\n</code></pre> <p>Return the last item in the array-like input.</p> <pre><code>{{ \"Ground control to Major Tom.\" | split: \" \" | last }}\n</code></pre> output<pre><code>Tom.\n</code></pre> <p>If the input is undefined, empty, string or a number, <code>nil</code> will be returned.</p>"},{"location":"filter_reference/#lstrip","title":"lstrip","text":"<pre><code>&lt;string&gt; | lstrip\n</code></pre> <p>Return the input string with all leading whitespace removed. If the input is not a string, it will be converted to a string before stripping whitespace.</p> <pre><code>{{ \"          So much room for activities          \" | lstrip }}!\n</code></pre> output<pre><code>So much room for activities          !\n</code></pre>"},{"location":"filter_reference/#map","title":"map","text":"<pre><code>&lt;array&gt; | map: &lt;string | lambda expression&gt;\n</code></pre> <p>Extract properties from an array of objects into a new array.</p> <p>For example, if <code>pages</code> is an array of objects with a <code>category</code> property:</p> data<pre><code>{\n  \"pages\": [\n    { \"category\": \"business\" },\n    { \"category\": \"celebrities\" },\n    { \"category\": \"lifestyle\" },\n    { \"category\": \"sports\" },\n    { \"category\": \"technology\" }\n  ]\n}\n</code></pre> <pre><code>{% assign categories = pages | map: \"category\" -%}\n\n{% for category in categories -%}\n- {{ category }}\n{%- endfor %}\n</code></pre> output<pre><code>- business\n- celebrities\n- lifestyle\n- sports\n- technology\n</code></pre>"},{"location":"filter_reference/#minus","title":"minus","text":"<pre><code>&lt;number&gt; | minus: &lt;number&gt;\n</code></pre> <p>Return the result of subtracting one number from another. If either the input or argument are not a number, Liquid will try to convert them to a number. If that conversion fails, <code>0</code> is used instead.</p> <pre><code>{{ 4 | minus: 2 }}\n{{ \"16\" | minus: 4 }}\n{{ 183.357 | minus: 12.2 }}\n{{ \"hello\" | minus: 10 }}\n</code></pre> output<pre><code>2\n12\n171.157\n-10\n</code></pre>"},{"location":"filter_reference/#modulo","title":"modulo","text":"<pre><code>&lt;number&gt; | modulo: &lt;number&gt;\n</code></pre> <p>Return the remainder from the division of the input by the argument.</p> <pre><code>{{ 3 | modulo: 2 }}\n{{ \"24\" | modulo: \"7\" }}\n{{ 183.357 | modulo: 12 }}\n</code></pre> output<pre><code>1\n3\n3.357\n</code></pre> <p>If either the input or argument are not an integer or float, Liquid will try to convert them to an integer or float. If the input can't be converted, <code>0</code> will be used instead. If the argument can't be converted, an exception is raised.</p>"},{"location":"filter_reference/#newline_to_br","title":"newline_to_br","text":"<pre><code>&lt;string&gt; | newline_to_br\n</code></pre> <p>Return the input string with <code>\\n</code> and <code>\\r\\n</code> replaced with <code>&lt;br /&gt;\\n</code>.</p> <pre><code>{% capture string_with_newlines %}\nHello\nthere\n{% endcapture %}\n\n{{ string_with_newlines | newline_to_br }}\n</code></pre> output<pre><code>&lt;br /&gt;\nHello&lt;br /&gt;\nthere&lt;br /&gt;\n</code></pre>"},{"location":"filter_reference/#plus","title":"plus","text":"<pre><code>&lt;number&gt; | plus: &lt;number&gt;\n</code></pre> <p>Return the result of adding one number to another. If either the input or argument are not a number, Liquid will try to convert them to a number. If that conversion fails, <code>0</code> is used instead.</p> <pre><code>{{ 4 | plus: 2 }}\n{{ \"16\" | plus: \"4\" }}\n{{ 183.357 | plus: 12 }}\n</code></pre> output<pre><code>6\n20\n195.357\n</code></pre>"},{"location":"filter_reference/#prepend","title":"prepend","text":"<pre><code>&lt;string&gt; | prepend: &lt;string&gt;\n</code></pre> <p>Return the argument concatenated with the filter input.</p> <pre><code>{{ \"apples, oranges, and bananas\" | prepend: \"Some fruit: \" }}\n</code></pre> output<pre><code>Some fruit: apples, oranges, and bananas\n</code></pre> <p>If either the input value or argument are not a string, they will be coerced to a string before concatenation.</p> <pre><code>{% assign a_number = 7.5 -%}\n{{ 42 | prepend: a_number }}\n{{ nosuchthing | prepend: 'World!' }}\n</code></pre> output<pre><code>7.542\nWorld!\n</code></pre>"},{"location":"filter_reference/#reject","title":"reject","text":"<pre><code>&lt;array&gt; | reject: &lt;string&gt;[, &lt;object&gt;]\n</code></pre> <p>Return a copy of the input array including only those objects that have a property, named with the first argument, that is not equal to a value, given as the second argument. If a second argument is not given, only elements with the named property that are falsy will be included.</p> data<pre><code>{\n  \"products\": [\n    { \"title\": \"Vacuum\", \"type\": \"house\", \"available\": true },\n    { \"title\": \"Spatula\", \"type\": \"kitchen\", \"available\": false },\n    { \"title\": \"Television\", \"type\": \"lounge\", \"available\": true },\n    { \"title\": \"Garlic press\", \"type\": \"kitchen\", \"available\": true }\n  ]\n}\n</code></pre> <pre><code>All products:\n{% for product in products -%}\n- {{ product.title }}\n{% endfor %}\n\n{%- assign kitchen_products = products | reject: \"type\", \"kitchen\" -%}\n\nNon kitchen products:\n{% for product in kitchen_products -%}\n- {{ product.title }}\n{% endfor %}\n\n{%- assign unavailable_products = products | reject: \"available\" -%}\n\nUnavailable products:\n{% for product in unavailable_products -%}\n- {{ product.title }}\n{% endfor %}\n</code></pre> output<pre><code>All products:\n- Vacuum\n- Spatula\n- Television\n- Garlic press\nNon kitchen products:\n- Vacuum\n- Television\nUnavailable products:\n- Spatula\n</code></pre>"},{"location":"filter_reference/#remove","title":"remove","text":"<pre><code>&lt;string&gt; | remove: &lt;string&gt;\n</code></pre> <p>Return the input with all occurrences of the argument string removed.</p> <pre><code>{{ \"I strained to see the train through the rain\" | remove: \"rain\" }}\n</code></pre> output<pre><code>I sted to see the t through the\n</code></pre> <p>If either the filter input or argument are not a string, they will be coerced to a string before substring removal.</p>"},{"location":"filter_reference/#remove_first","title":"remove_first","text":"<pre><code>&lt;string&gt; | remove_first: &lt;string&gt;\n</code></pre> <p>Return a copy of the input string with the first occurrence of the argument string removed.</p> <pre><code>{{ \"I strained to see the train through the rain\" | remove_first: \"rain\" }}\n</code></pre> output<pre><code>I sted to see the train through the rain\n</code></pre> <p>If either the filter input or argument are not a string, they will be coerced to a string before substring removal.</p>"},{"location":"filter_reference/#remove_last","title":"remove_last","text":"<pre><code>&lt;string&gt; | remove_last: &lt;string&gt;\n</code></pre> <p>Return a copy of the input string with the last occurrence of the argument string removed.</p> <pre><code>{{ \"I strained to see the train through the rain\" | remove_last: \"rain\" }}\n</code></pre> output<pre><code>I strained to see the train through the\n</code></pre> <p>If either the filter input or argument are not a string, they will be coerced to a string before substring removal.</p>"},{"location":"filter_reference/#replace","title":"replace","text":"<pre><code>&lt;string&gt; | replace: &lt;string&gt;[, &lt;string&gt;]\n</code></pre> <p>Return the input with all occurrences of the first argument replaced with the second argument. If the second argument is omitted, it will default to an empty string, making <code>replace</code> behave like <code>remove</code>.</p> <pre><code>{{ \"Take my protein pills and put my helmet on\" | replace: \"my\", \"your\" }}\n</code></pre> output<pre><code>Take your protein pills and put your helmet on\n</code></pre> <p>If either the filter input or argument are not a string, they will be coerced to a string before replacement.</p>"},{"location":"filter_reference/#replace_first","title":"replace_first","text":"<pre><code>&lt;string&gt; | replace_first: &lt;string&gt;[, &lt;string&gt;]\n</code></pre> <p>Return a copy of the input string with the first occurrence of the first argument replaced with the second argument. If the second argument is omitted, it will default to an empty string, making <code>replace_first</code> behave like <code>remove_first</code>.</p> <pre><code>{{ \"Take my protein pills and put my helmet on\" | replace_first: \"my\", \"your\" }}\n</code></pre> output<pre><code>Take your protein pills and put my helmet on\n</code></pre> <p>If either the filter input or argument are not a string, they will be coerced to a string before replacement.</p>"},{"location":"filter_reference/#replace_last","title":"replace_last","text":"<pre><code>&lt;string&gt; | replace_last: &lt;string&gt;, &lt;string&gt;\n</code></pre> <p>Return a copy of the input string with the last occurrence of the first argument replaced with the second argument.</p> <pre><code>{{ \"Take my protein pills and put my helmet on\" | replace_first: \"my\", \"your\" }}\n</code></pre> output<pre><code>Take my protein pills and put your helmet on\n</code></pre> <p>If either the filter input or argument are not a string, they will be coerced to a string before replacement.</p>"},{"location":"filter_reference/#reverse","title":"reverse","text":"<pre><code>&lt;array&gt; | reverse\n</code></pre> <p>Return a copy of the input array with the items in reverse order. If the filter input is a string, <code>reverse</code> will return the string unchanged.</p> <pre><code>{% assign my_array = \"apples, oranges, peaches, plums\" | split: \", \" -%}\n\n{{ my_array | reverse | join: \", \" }}\n</code></pre> output<pre><code>plums, peaches, oranges, apples\n</code></pre>"},{"location":"filter_reference/#round","title":"round","text":"<pre><code>&lt;number&gt; | round[: &lt;number&gt;]\n</code></pre> <p>Return the input number rounded to the given number of decimal places. The number of digits defaults to <code>0</code>.</p> <pre><code>{{ 1.2 | round }}\n{{ 2.7 | round }}\n{{ 183.357 | round: 2 }}\n</code></pre> output<pre><code>1\n3\n183.36\n</code></pre> <p>If either the filter input or its optional argument are not an integer or float, they will be converted to an integer or float before rounding.</p>"},{"location":"filter_reference/#rstrip","title":"rstrip","text":"<pre><code>&lt;string&gt; | rstrip\n</code></pre> <p>Return the input string with all trailing whitespace removed. If the input is not a string, it will be converted to a string before stripping whitespace.</p> <pre><code>{{ \"          So much room for activities          \" | rstrip }}!\n</code></pre> output<pre><code>          So much room for activities!\n</code></pre>"},{"location":"filter_reference/#safe","title":"safe","text":"<pre><code>&lt;string&gt; | safe\n</code></pre> <p>Return the input string marked as safe to use in an HTML or XML document. If the filter input is not a string, it will be converted to an HTML-safe string.</p> <p>With auto-escape enabled and the following global variables:</p> data<pre><code>{\n  \"username\": \"Sally\",\n  \"greeting\": \"&lt;/p&gt;&lt;script&gt;alert('XSS!');&lt;/script&gt;\"\n}\n</code></pre> template<pre><code>&lt;p&gt;{{ greeting }}, {{ username }}&lt;/p&gt;\n&lt;p&gt;{{ greeting | safe }}, {{ username }}&lt;/p&gt;\n</code></pre> output<pre><code>&lt;p&gt;&amp;lt;/p&amp;gt;&amp;lt;script&amp;gt;alert(&amp;#34;XSS!&amp;#34;);&amp;lt;/script&amp;gt;, Sally&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;script&gt;alert('XSS!');&lt;/script&gt;, Sally&lt;/p&gt;\n</code></pre>"},{"location":"filter_reference/#size","title":"size","text":"<pre><code>&lt;object&gt; | size\n</code></pre> <p>Return the size of the input object. Works on strings, arrays and hashes.</p> <pre><code>{{ \"Ground control to Major Tom.\" | size }}\n{{ \"apples, oranges, peaches, plums\" | split: \", \" | size }}\n</code></pre> output<pre><code>28\n4\n</code></pre>"},{"location":"filter_reference/#slice","title":"slice","text":"<pre><code>&lt;sequence&gt; | slice: &lt;int&gt;[, &lt;int&gt;]\n</code></pre> <p>Return a substring or subsequence of the input string or array. The first argument is the zero-based start index. The second, optional argument is the length of the substring or sequence, which defaults to <code>1</code>.</p> <pre><code>{{ \"Liquid\" | slice: 0 }}\n{{ \"Liquid\" | slice: 2 }}\n{{ \"Liquid\" | slice: 2, 5 }}\n{% assign beatles = \"John, Paul, George, Ringo\" | split: \", \" -%}\n{{ beatles | slice: 1, 2 | join: \" \" }}\n</code></pre> output<pre><code>L\nq\nquid\nPaul George\n</code></pre> <p>If the first argument is negative, the start index is counted from the end of the sequence.</p> <pre><code>{{ \"Liquid\" | slice: -3 }}\n{{ \"Liquid\" | slice: -3, 2 }}\n{% assign beatles = \"John, Paul, George, Ringo\" | split: \", \" -%}\n{{ beatles | slice: -2, 2 | join: \" \" }}\n</code></pre> output<pre><code>u\nui\nGeorge Ringo\n</code></pre>"},{"location":"filter_reference/#sort","title":"sort","text":"<pre><code>&lt;array&gt; | sort[: &lt;string&gt;]\n``\n\nReturn a copy of the input array with its elements sorted.\n\n```liquid\n{% assign my_array = \"zebra, octopus, giraffe, Sally Snake\" | split: \", \" -%}\n{{ my_array | sort | join: \", \" }}\n</code></pre> output<pre><code>Sally Snake, giraffe, octopus, zebra\n</code></pre> <p>The optional argument is a sort key. If given, it should be the name of a property and the filter's input should be an array of objects.</p> data<pre><code>{\n  \"collection\": {\n    \"products\": [\n      { \"title\": \"A Shoe\", \"price\": \"9.95\" },\n      { \"title\": \"A Tie\", \"price\": \"0.50\" },\n      { \"title\": \"A Hat\", \"price\": \"2.50\" }\n    ]\n  }\n}\n</code></pre> template<pre><code>{% assign products_by_price = collection.products | sort: \"price\" -%}\n{% for product in products_by_price %}\n  &lt;h4&gt;{{ product.title }}&lt;/h4&gt;\n{% endfor %}\n</code></pre> output<pre><code>&lt;h4&gt;A Tie&lt;/h4&gt;\n&lt;h4&gt;A Hat&lt;/h4&gt;\n&lt;h4&gt;A Shoe&lt;/h4&gt;\n</code></pre>"},{"location":"filter_reference/#sort_natural","title":"sort_natural","text":"<pre><code>&lt;array&gt; | sort_natural[: &lt;string&gt;]\n</code></pre> <p>Return a copy of the input array with its elements sorted case-insensitively. Array items will be compared by their string representations, forced to lowercase.</p> <pre><code>{% assign my_array = \"zebra, octopus, giraffe, Sally Snake\" | split: \", \" -%}\n{{ my_array | sort_natural | join: \", \" }}\n</code></pre> output<pre><code>giraffe, octopus, Sally Snake, zebra\n</code></pre> <p>The optional argument is a sort key. If given, it should be the name of a property and the filter's input should be an array of objects. Array elements are compared using the lowercase string representation of that property.</p> data<pre><code>{\n  \"collection\": {\n    \"products\": [\n      { \"title\": \"A Shoe\", \"company\": \"Cool Shoes\" },\n      { \"title\": \"A Tie\", \"company\": \"alpha Ties\" },\n      { \"title\": \"A Hat\", \"company\": \"Beta Hats\" }\n    ]\n  }\n}\n</code></pre> template<pre><code>{% assign products_by_company = collection.products | sort_natural: \"company\" %}\n{% for product in products_by_company %}\n  &lt;h4&gt;{{ product.title }}&lt;/h4&gt;\n{% endfor %}\n</code></pre> output<pre><code>&lt;h4&gt;A Tie&lt;/h4&gt;\n&lt;h4&gt;A Hat&lt;/h4&gt;\n&lt;h4&gt;A Shoe&lt;/h4&gt;\n</code></pre>"},{"location":"filter_reference/#split","title":"split","text":"<pre><code>&lt;string&gt; | split: &lt;string&gt;\n</code></pre> <p>Return an array of strings that are the input string split on the filter's argument string.</p> <pre><code>{% assign beatles = \"John, Paul, George, Ringo\" | split: \", \" -%}\n\n{% for member in beatles %}\n  {{- member }}\n{% endfor %}\n</code></pre> output<pre><code>John\nPaul\nGeorge\nRingo\n</code></pre> <p>If the argument is undefined or an empty string, the input will be split at every character.</p> <pre><code>{{ \"Hello there\" | split: nosuchthing | join: \"#\" }}\n</code></pre> output<pre><code>H#e#l#l#o# #t#h#e#r#e\n</code></pre>"},{"location":"filter_reference/#strip","title":"strip","text":"<pre><code>&lt;string&gt; | strip\n</code></pre> <p>Return the input string with all leading and trailing whitespace removed. If the input is not a string, it will be converted to a string before stripping whitespace.</p> <pre><code>{{ \"          So much room for activities          \" | strip }}!\n</code></pre> output<pre><code>So much room for activities!\n</code></pre>"},{"location":"filter_reference/#strip_html","title":"strip_html","text":"<pre><code>&lt;string&gt; | strip_html\n</code></pre> <p>Return the input string with all HTML tags removed.</p> <pre><code>{{ \"Have &lt;em&gt;you&lt;/em&gt; read &lt;strong&gt;Ulysses&lt;/strong&gt;?\" | strip_html }}\n</code></pre> output<pre><code>Have you read Ulysses?\n</code></pre>"},{"location":"filter_reference/#strip_newlines","title":"strip_newlines","text":"<pre><code>&lt;string&gt; | strip_newlines\n</code></pre> <p>Return the input string with <code>\\n</code> and <code>\\r\\n</code> removed.</p> <pre><code>{% capture string_with_newlines %}\nHello\nthere\n{% endcapture -%}\n\n{{ string_with_newlines | strip_newlines }}\n</code></pre> output<pre><code>Hellothere\n</code></pre>"},{"location":"filter_reference/#sum","title":"sum","text":"<pre><code>&lt;array&gt; | sum[: &lt;string&gt;]\n</code></pre> <p>Return the sum of all numeric elements in an array.</p> <pre><code>{% assign array = '1,2,3' | split: ',' -%}\n{{ array | sum }}\n</code></pre> output<pre><code>6\n</code></pre> <p>If the optional string argument is given, it is assumed that array items are hash/dict/mapping-like, and the argument should be the name of a property/key. The values at <code>array[property]</code> will be summed.</p>"},{"location":"filter_reference/#times","title":"times","text":"<pre><code>&lt;number&gt; | times: &lt;number&gt;\n</code></pre> <p>Return the product of the input number and the argument. If either the input or argument are not a number, Liquid will try to convert them to a number. If that conversion fails, <code>0</code> is used instead.</p> <pre><code>{{ 3 | times: 2 }}\n{{ \"24\" | times: \"7\" }}\n{{ 183.357 | times: 12 }}\n</code></pre> output<pre><code>6\n168\n2200.284\n</code></pre>"},{"location":"filter_reference/#truncate","title":"truncate","text":"<pre><code>&lt;string&gt; | truncate[: &lt;integer&gt;[, &lt;string&gt;]]\n</code></pre> <p>Return a truncated version of the input string. The first argument, length, defaults to <code>50</code>. The second argument defaults to an ellipsis (<code>...</code>).</p> <p>If the length of the input string is less than the given length (first argument), the input string will be truncated to <code>length</code> minus the length of the second argument, with the second argument appended.</p> <pre><code>{{ \"Ground control to Major Tom.\" | truncate: 20 }}\n{{ \"Ground control to Major Tom.\" | truncate: 25, \", and so on\" }}\n{{ \"Ground control to Major Tom.\" | truncate: 20, \"\" }}\n</code></pre> output<pre><code>Ground control to...\nGround control, and so on\nGround control to Ma\n</code></pre>"},{"location":"filter_reference/#truncatewords","title":"truncatewords","text":"<pre><code>&lt;string&gt; | truncatewords[: &lt;integer&gt;[, &lt;string&gt;]]\n</code></pre> <p>Return the input string truncated to the specified number of words, with the second argument appended. The number of words (first argument) defaults to <code>15</code>. The second argument defaults to an ellipsis (<code>...</code>).</p> <p>If the input string already has fewer than the given number of words, it is returned unchanged.</p> <pre><code>{{ \"Ground control to Major Tom.\" | truncatewords: 3 }}\n{{ \"Ground control to Major Tom.\" | truncatewords: 3, \"--\" }}\n{{ \"Ground control to Major Tom.\" | truncatewords: 3, \"\" }}\n</code></pre> output<pre><code>Ground control to...\nGround control to--\nGround control to\n</code></pre>"},{"location":"filter_reference/#uniq","title":"uniq","text":"<pre><code>&lt;array&gt; | uniq[: &lt;string&gt;]\n</code></pre> <p>Return a copy of the input array with duplicate elements removed.</p> <pre><code>{% assign my_array = \"ants, bugs, bees, bugs, ants\" | split: \", \" -%}\n{{ my_array | uniq | join: \", \" }}\n</code></pre> output<pre><code>ants, bugs, bees\n</code></pre> <p>If an argument is given, it should be the name of a property and the filter's input should be an array of objects.</p> data<pre><code>{\n  \"collection\": {\n    \"products\": [\n      { \"title\": \"A Shoe\", \"company\": \"Cool Shoes\" },\n      { \"title\": \"A Tie\", \"company\": \"alpha Ties\" },\n      { \"title\": \"Another Tie\", \"company\": \"alpha Ties\" },\n      { \"title\": \"A Hat\", \"company\": \"Beta Hats\" }\n    ]\n  }\n}\n</code></pre> template<pre><code>{% assign one_product_from_each_company = collections.products | uniq: \"company\" -%}\n{% for product in one_product_from_each_company -%}\n  - product.title\n{% endfor %}\n</code></pre> output<pre><code>- A Shoe\n- A Tie\n- A Hat\n</code></pre>"},{"location":"filter_reference/#upcase","title":"upcase","text":"<pre><code>&lt;string&gt; | upcase\n</code></pre> <p>Return the input string with all characters in uppercase.</p> <pre><code>{{ 'Hello, World!' | upcase }}\n</code></pre> output<pre><code>HELLO, WORLD!\n</code></pre>"},{"location":"filter_reference/#url_decode","title":"url_decode","text":"<pre><code>&lt;string&gt; | url_decode\n</code></pre> <p>Return the input string with <code>%xx</code> escapes replaced with their single-character equivalents. Also replaces <code>'+'</code> with <code>' '</code>.</p> <pre><code>{{ \"My+email+address+is+bob%40example.com%21\" | url_decode }}\n</code></pre> output<pre><code>My email address is bob@example.com!\n</code></pre>"},{"location":"filter_reference/#url_encode","title":"url_encode","text":"<pre><code>&lt;string&gt; | url_encode\n</code></pre> <p>Return the input string with URL reserved characters %-escaped. Also replaces <code>' '</code> with <code>'+'</code>.</p> <pre><code>{{ My email address is bob@example.com! | url_encode }}\n</code></pre> output<pre><code>My+email+address+is+bob%40example.com%21\n</code></pre>"},{"location":"filter_reference/#where","title":"where","text":"<pre><code>&lt;array&gt; | where: &lt;string&gt;[, &lt;object&gt;]\n</code></pre> <p>Return a copy of the input array including only those objects that have a property, named with the first argument, equal to a value, given as the second argument. If a second argument is not given, only elements with the named property that are truthy will be included.</p> data<pre><code>{\n  \"products\": [\n    { \"title\": \"Vacuum\", \"type\": \"house\", \"available\": true },\n    { \"title\": \"Spatula\", \"type\": \"kitchen\", \"available\": false },\n    { \"title\": \"Television\", \"type\": \"lounge\", \"available\": true },\n    { \"title\": \"Garlic press\", \"type\": \"kitchen\", \"available\": true }\n  ]\n}\n</code></pre> <pre><code>All products:\n{% for product in products -%}\n- {{ product.title }}\n{% endfor %}\n\n{%- assign kitchen_products = products | where: \"type\", \"kitchen\" -%}\n\nKitchen products:\n{% for product in kitchen_products -%}\n- {{ product.title }}\n{% endfor %}\n\n{%- assign available_products = products | where: \"available\" -%}\n\nAvailable products:\n{% for product in available_products -%}\n- {{ product.title }}\n{% endfor %}\n</code></pre> output<pre><code>All products:\n- Vacuum\n- Spatula\n- Television\n- Garlic press\n\nKitchen products:\n- Spatula\n- Garlic press\n\nAvailable product:\n- Vacuum\n- Television\n- Garlic press\n</code></pre>"},{"location":"known_issues/","title":"Known issues","text":"<p>This page documents known compatibility issues between Python Liquid's default <code>Environment</code> and Shopify/liquid, the reference implementation written in Ruby. We strive to be 100% compatible with Shopify/liquid. That is, given an equivalent render context, a template rendered with Python Liquid should produce the same output as when rendered with Ruby Liquid.</p>"},{"location":"known_issues/#coercing-strings-to-integers-inside-filters","title":"Coercing Strings to Integers Inside Filters","text":"<p>See issue #49</p> <p>Many filters built in to Liquid will automatically convert a string representation of a number to an integer or float as needed. When converting integers, Ruby Liquid uses Ruby's String.to_i method, which will disregard trailing non-digit characters. In the following example, <code>'7,42'</code> is converted to <code>7</code></p> <p>template:</p> <pre><code>{{ 3.14 | plus: '7,42' }}\n{{ '123abcdef45' | plus: '1,,,,..!@qwerty' }}\n</code></pre> <p>output</p> <pre><code>10.14\n124\n</code></pre> <p>Python Liquid currently falls back to <code>0</code> for any string that can't be converted to an integer in its entirety. As is the case in Ruby Liquid for strings without leading digits.</p> <p>This does not apply to parsing of integer literals, only converting strings to integers (not floats) inside filters.</p>"},{"location":"known_issues/#the-date-filter","title":"The Date Filter","text":"<p>The built-in <code>date</code> filter uses dateutil for parsing strings to <code>datetime</code>s, and <code>strftime</code> for formatting. There are likely to be some inconsistencies between this and the reference implementation's equivalent parsing and formatting of dates and times.</p>"},{"location":"known_issues/#orphaned-break-and-continue","title":"Orphaned <code>{% break %}</code> and <code>{% continue %}</code>","text":"<p>See issue #76</p> <p>Shopify/liquid shows some unintuitive behavior when <code>{% break %}</code> or <code>{% continue %}</code> are found outside a <code>{% for %}</code> tag block.</p> <pre><code>{%- if true -%}\nbefore\n{%- if true %}\nhello{% break %}goodbye\n{% endif -%}\nafter\n{%- endif -%}\n{% for x in (1..3) %}\n{{ x }}\n{% endfor %}\n{% for x in (1..3) %}\n{{ x }}\n{% endfor %}\n</code></pre> <p>Shopify/iquid output in both strict and lax modes:</p> <pre><code>before\nhello\n</code></pre> <p>Python Liquid raises a <code>LiquidSyntaxError</code> in strict mode and jumps over the entire outer <code>{% if %}</code> block in lax mode.</p> <pre><code>1\n\n2\n\n3\n\n\n1\n\n2\n\n3\n</code></pre>"},{"location":"loading_templates/","title":"Loading templates","text":"<p>A template loader is a class inheriting from <code>BaseLoader</code>. It is responsible for finding template source text given a name or identifier, and will be called upon whenever you or a tag call <code>Environment.get_template()</code> or await <code>Environment.get_template_async()</code>.</p> <p>To use one of the template loaders described here, pass an instance of your chosen loader as the <code>loader</code> argument when constructing a Liquid <code>Environment</code>.</p>"},{"location":"loading_templates/#built-in-loaders","title":"Built-in loaders","text":""},{"location":"loading_templates/#dictionary-loader","title":"Dictionary loader","text":"<p><code>DictLoader</code> is a template loader that stores template source text in memory using a dictionary. If you're experimenting with Liquid or if all your templates are known at application startup time and they all fit in RAM, then <code>DictLoader</code> is a good choice.</p> <p>Simply pass a dictionary mapping template names to template source text to the <code>DictLoader</code> constructor.</p> <pre><code>from liquid import DictLoader\nfrom liquid import Environment\n\nenv = Environment(\n    loader=DictLoader(\n        {\n            \"index\": \"{% render 'header' %}\\nbody\\n{% render 'footer' %}\",\n            \"header\": \"some header\",\n            \"footer\": \"a footer\",\n        }\n    )\n)\n\ntemplate = env.get_template(\"index\")\nprint(template.render())\n</code></pre> output<pre><code>some header\nbody\na footer\n</code></pre>"},{"location":"loading_templates/#caching-dictionary-loader","title":"Caching dictionary loader","text":"<p><code>CachingDictLoader</code> is a dictionary loader that maintains an in-memory LRU cache of parsed templates, so as to avoid parsing the same source text multiple times unnecessarily.</p> <p>As well as a dictionary mapping template names to template source text, the <code>CachingDictLoader</code> constructor takes an optional <code>capacity</code> argument to control the maximum size of the cache. The default capacity is 300 templates.</p> <pre><code>from liquid import CachingDictLoader\nfrom liquid import Environment\n\nenv = Environment(\n    loader=CachingDictLoader(\n        {\n            \"index\": \"{% render 'header' %}\\nbody\\n{% render 'footer' %}\",\n            \"header\": \"some header\",\n            \"footer\": \"a footer\",\n        }\n    )\n)\n\ntemplate = env.get_template(\"index\")\nassert env.get_template(\"index\") is template\n</code></pre>"},{"location":"loading_templates/#file-system-loader","title":"File system loader","text":"<p><code>FileSystemLoader</code> is a template loader that reads source text from files on a file system. Its first argument, <code>search_path</code>, is a path to a folder containing Liquid templates, either as a string or <code>pathlib.Path</code>. <code>search_path</code> can also be a list of paths to search in order.</p> <p>In this example, calls to <code>Environment.get_template()</code> will look for templates in a folder called <code>templates</code> relative to the current directory.</p> <pre><code>from liquid import Environment\nfrom liquid import FileSystemLoader\n\nenv = Environment(loader=FileSystemLoader(\"templates/\"))\n</code></pre> <p>If a file called <code>index.html</code> exists in <code>./templates</code>, we could render it with <code>{% render 'index.html' %}</code>. To avoid having to include <code>.html</code> in every <code>render</code> tag, we can give <code>FileSystemLoader</code> a default file extension. It should include a leading <code>.</code>.</p> <pre><code>from liquid import Environment\nfrom liquid import FileSystemLoader\n\nenv = Environment(loader=FileSystemLoader(\"templates/\", ext=\".html\"))\n</code></pre> <p>If your templates are organized in sub folders of <code>./templates</code>, you can include the relative path to a template in a <code>render</code> tag, <code>{% render 'snippets/footer' %}</code>, but you won't be allowed to escape out of <code>./templates</code>. This would raise a <code>TemplateNotFoundError</code>.</p> <pre><code>{% render '../../path/to/private/file' %}\n</code></pre>"},{"location":"loading_templates/#caching-file-system-loader","title":"Caching file system loader","text":"<p><code>CachingFileSystemLoader</code> is a file system loader that maintains an in-memory LRU cache of parsed templates, so as to avoid reading and parsing the same source text multiple times unnecessarily.</p> <p>As well as <code>search_path</code> and <code>ext</code> arguments covered in the file system loader section above, <code>CachingFileSystemLoader</code> takes optional <code>auto_reload</code> and <code>capacity</code> arguments.</p> <p><code>capacity</code> is the maximum number of templates that can fit in the cache and defaults to <code>300</code> templates.</p> <p><code>auto_reload</code> is a flag to indicate if the template loader should check to see if each cached template has been modified since it was last loaded. If <code>True</code> and template source text has been modified on-disk, that source text will automatically be read and parsed again. <code>auto_reload</code> defaults to <code>True</code>.</p> <pre><code>from liquid import Environment\nfrom liquid import CachingFileSystemLoader\n\nloader = CachingFileSystemLoader(\n    \"/var/www/templates/\",\n    ext=\".liquid\",\n    auto_reload=True,\n    capacity=1000,\n)\n\nenv = Environment(loader=loader)\n</code></pre>"},{"location":"loading_templates/#package-loader","title":"Package loader","text":"<p><code>PackageLoader</code> is a template loader that reads template source text from Python packages installed in your Python environment. You should pass the name of the package and, optionally, one or more paths to directories containing template source text within the package. The default <code>package_path</code> is <code>templates</code>.</p> <p>Just like <code>FileSystemLoader</code>, <code>PackageLoader</code> accepts a default file extension, <code>ext</code>. This time it defaults to <code>.liquid</code>.</p> <pre><code>from liquid import Environment\nfrom liquid import PackageLoader\n\nloader = PackageLoader(\n    \"awesome_templates\",\n    package_path=\"path/to/templates\",\n    ext=\".liquid\",\n)\n\nenv = Environment(loader=loader)\n</code></pre>"},{"location":"loading_templates/#choice-loader","title":"Choice loader","text":"<p><code>ChoiceLoader</code> and <code>CachingChoiceLoader</code> are template loaders that delegate to a list of other template loaders. Each one is tried in turn until a template is found.</p> <p>When using <code>CachingChoiceLoader</code>, you should probably avoid delegating to other caching loaders.</p> <pre><code>from liquid import CachingFileSystemLoader\nfrom liquid import ChoiceLoader\nfrom liquid import DictLoader\nfrom liquid import Environment\n\nbase_loader = DictLoader({\"foo\": \"some template source text\"})\noverlay_loader = CachingFileSystemLoader(\"templates/\")\nloader = ChoiceLoader([overlay_loader, base_loader])\n\nenv = Environment(loader=loader)\n</code></pre>"},{"location":"loading_templates/#custom-loaders","title":"Custom loaders","text":"<p>If you want to load templates from a database or over a network, you'll need to write your own template loader. Simply inherit from <code>BaseLoader</code> and implement <code>get_source()</code> and, possibly, <code>get_source_async()</code>.</p> <p><code>get_source()</code> should return an instance of <code>TemplateSource</code>, which is a named tuple containing source text, the template's name, an optional <code>uptodate</code> callable and any extra data you want bound to the template.</p> <p>Take a look at source code for the built-in loaders for examples.</p>"},{"location":"loading_templates/#load-context","title":"Load context","text":"<p><code>get_source()</code> takes an optional <code>context</code> argument. When <code>Environment.get_template()</code> is called from a tag, like <code>render</code>, the active render context will be passed along to <code>get_source()</code>. Loaders can then choose to use render context data to dynamically refine template names and loader search paths.</p> <p>Arbitrary keyword arguments can also be passed to <code>Environment.get_template()</code>. These too are passed along to <code>get_source()</code>, and can also be used by custom template loaders to refine the template source search space.</p> <p>For example, all built-in tags that call <code>Environment.get_template()</code> pass a keyword argument called <code>tag</code> set to the name of the calling tag. We can use the tag name to mimic Shopify's <code>snippets</code> convention, where <code>{% include %}</code> and <code>{% render %}</code> automatically load templates from a subfolder call <code>snippets</code>.</p> <pre><code>from pathlib import Path\n\nfrom liquid import CachingFileSystemLoader\nfrom liquid import Environment\nfrom liquid import RenderContext\nfrom liquid import TemplateSource\n\n\nclass SnippetsFileSystemLoader(CachingFileSystemLoader):\n    def get_source(\n        self,\n        env: Environment,\n        template_name: str,\n        *,\n        context: RenderContext | None = None,\n        **kwargs: object,\n    ) -&gt; TemplateSource:\n        if kwargs.get(\"tag\") in (\"include\", \"render\"):\n            snippet = Path(\"snippets\").joinpath(template_name)\n            return super().get_source(\n                env, template_name=str(snippet), context=context, **kwargs\n            )\n        return super().get_source(\n            env, template_name=template_name, context=context, **kwargs\n        )\n</code></pre>"},{"location":"loading_templates/#matter","title":"Matter","text":"<p>Sometimes template source text comes with associated data. This could be meta data read from a database or front matter read from the top of the file containing template source text. The <code>TemplateSource</code> object returned from <code>get_source()</code> facilitates these cases with <code>matter</code>, a dictionary mapping strings to arbitrary objects that will be merged with environment and template globals and bound to the resulting <code>Template</code> instance.</p> <p>Here's an example of a template loader that reads front matter in YAML format.</p> <pre><code>import re\n\nimport yaml\n\nfrom liquid import CachingFileSystemLoader\nfrom liquid import Environment\nfrom liquid import RenderContext\nfrom liquid import TemplateSource\n\nRE_FRONT_MATTER = re.compile(r\"\\s*---\\s*(.*?)\\s*---\\s*\", re.MULTILINE | re.DOTALL)\n\n\nclass FrontMatterLoader(CachingFileSystemLoader):\n    def get_source(\n        self,\n        env: Environment,\n        template_name: str,\n        *,\n        context: RenderContext | None = None,\n        **kwargs: object,\n    ) -&gt; TemplateSource:\n        source, filename, uptodate, matter = super().get_source(env, template_name)\n        match = RE_FRONT_MATTER.search(source)\n\n        if match:\n            # TODO: add some yaml error handling here.\n            matter = yaml.load(match.group(1), Loader=yaml.SafeLoader)\n            source = source[match.end() :]\n\n        return TemplateSource(\n            source,\n            filename,\n            uptodate,\n            matter,\n        )\n</code></pre>"},{"location":"loading_templates/#caching-mixin","title":"Caching mixin","text":"<p>Use <code>CachingLoaderMixin</code> to add in-memory LRU caching to your custom template loaders. For example, here's the definition of <code>CachingDictLoader</code>.</p> <pre><code>from liquid import CachingLoaderMixin\nfrom liquid import DictLoader\n\nclass CachingDictLoader(CachingLoaderMixin, DictLoader):\n    \"\"\"A `DictLoader` that caches parsed templates in memory.\"\"\"\n\n    def __init__(\n        self,\n        templates: dict[str, str],\n        *,\n        auto_reload: bool = True,\n        namespace_key: str = \"\",\n        capacity: int = 300,\n    ):\n        super().__init__(\n            auto_reload=auto_reload,\n            namespace_key=namespace_key,\n            capacity=capacity,\n        )\n\n        DictLoader.__init__(self, templates)\n</code></pre>"},{"location":"migration/","title":"Migration guide","text":"<p>This is the documentation for the latest version of Python Liquid (GitHub). Python Liquid strives for 100% compatibility with Shopify/liquid, the reference implementation.</p> <p>Python Liquid2, a Python implementation of Liquid2, is an alternative Liquid template engine that deliberately deviates from Shopify/liquid in its syntax and rendering behavior.</p> <p>Here we cover migrating from Python Liquid version 1.x to the latest version. See the Liquid2 migration guide if you're interested in switching to Liquid2.</p>"},{"location":"migration/#new-features","title":"New features","text":"<p>Other than improved error messages and some new standard filters (<code>has</code>, <code>find</code>, <code>find_index</code> and <code>reject</code>), there are no new features. Our goal with this release was to improve Python Liquid's API and improve compatibility with Shopify/liquid.</p> <p>If you're interested in new features, take a look at Liquid2.</p>"},{"location":"migration/#python-version-support-and-dependencies","title":"Python version support and dependencies","text":"<p>Support for Python versions 3.7 and 3.8 has been dropped. Both are now end of life.</p> <p>MarkupSafe is now a required dependency. Previously it was an optional dependency.</p> <p>Babel and pytz are now dependencies as internationalization and localization tags and filters are included in Python Liquid. They used to be available from a separate package.</p>"},{"location":"migration/#api-changes","title":"API changes","text":""},{"location":"migration/#package-level-functions","title":"Package-level functions","text":"<p><code>parse</code>, <code>render</code> and <code>render_async</code> are package-level functions that parse and render templates using the default environment. Where as before you might have done something like this:</p> <pre><code>from liquid import Template\nprint(Template(\"Hello, {{ you }}!\").render(you=\"World\"))\n</code></pre> <p>You can now do:</p> <pre><code>from liquid import render\nprint(render(\"Hello, {{ you }}!\", you=\"World\"))\n</code></pre>"},{"location":"migration/#environmentparse","title":"Environment.parse","text":"<p><code>Environment.from_string</code> is now aliased as <code>Environment.parse</code>. The old <code>parse</code> method, which returned a list of nodes instead of a template, is now private.</p> <pre><code>from liquid import Environment\n\nenv = Environment(extra=True)\ntemplate = env.parse(\"Hello, {{ you }}!\")\n</code></pre>"},{"location":"migration/#environmentrender","title":"Environment.render","text":"<p><code>Environment.render</code> and <code>Environment.render_async</code> parse and immediately render template source text without forcing you to explicitly create a new template.</p> <pre><code>from liquid import Environment\n\nenv = Environment(extra=True)\nprint(env.render(\"Hello, {{ you }}!\", you=\"World\"))\n</code></pre>"},{"location":"migration/#template-caching","title":"Template caching","text":"<p>The <code>cache_size</code> argument to <code>liquid.Environment</code> and <code>liquid.Template</code> has been removed. Template caching is now handled exclusively by template loaders. See <code>CachingFileSystemLoader</code> and <code>CachingLoaderMixin</code>.</p>"},{"location":"migration/#expression-caching","title":"Expression caching","text":"<p>The <code>expression_cache_size</code> argument to <code>liquid.Environment</code> and <code>liquid.Template</code> has been removed. Environment-level expression caching is no longer available as it does not play nicely with detailed error messages. If you need to cache parsing of Liquid expressions, it is now recommended to implement a cache per tag, where it makes sense to do so for your use case.</p>"},{"location":"migration/#template-loaders","title":"Template loaders","text":"<p><code>BaseLoader.get_source</code> and <code>BaseLoader.get_source_async</code> have been changed to accept an optional <code>context</code> argument and arbitrary keyword arguments as \"load context\". These new arguments replace methods <code>get_source_with_context</code> and <code>get_source_with_args</code>, which have been removed.</p> <p>The value returned from <code>get_source</code>, <code>TemplateSource</code>, has also changed to be a named tuple of the form <code>(text, name, uptodate, matter)</code>. It used to be <code>(source, filename, uptodate, matter)</code>.</p>"},{"location":"migration/#template-inheritance","title":"Template inheritance","text":"<p>We've added methods <code>variables()</code>, <code>variable_paths()</code>, <code>variable_segments()</code>, <code>global_variables()</code>, <code>global_variable_paths()</code>, <code>global_variable_segments()</code>, <code>filter_names()</code>, <code>tag_names()</code> and their async equivalents to <code>liquid.BoundTemplate</code>. These are convenience methods for reporting variables, tags and filters using static analysis.</p>"},{"location":"migration/#custom-tags","title":"Custom tags","text":"<p>We've Changed <code>Node.children()</code> to return a sequence of <code>Node</code> instance only, and added <code>expressions()</code>, <code>template_scope()</code>, <code>block_scope()</code> and <code>partial_scope()</code> methods.</p> <p>See liquid/builtin/tags for examples.</p>"},{"location":"migration/#exceptions","title":"Exceptions","text":"<p><code>liquid.exceptions.Error</code> has been renamed to <code>liquid.exceptions.LiquidError</code>.</p> <p><code>liquid.exceptions.TemplateNotFound</code> has been renamed to <code>liquid.exceptions.TemplateNotFoundError</code>.</p> <p><code>liquid.exceptions.NoSuchFilterFunc</code> has been renamed to <code>liquid.exceptions.UnknownFilterError</code>.</p>"},{"location":"migration/#render-context","title":"Render context","text":"<p><code>liquid.Context</code> has been renamed to <code>liquid.RenderContext</code> and it's constructor arguments changed to require a instance of <code>BoundTemplate</code> as its only positional argument instead of an instance of <code>Environment</code>. All other arguments are now keyword only.</p>"},{"location":"migration/#tokens-streams-and-expressions","title":"Tokens, streams and expressions","text":"<p>All tokens are now named tuples of the form <code>(kind, value, start_index, source)</code>. They used to be <code>(linenum, type, value)</code>, and sometimes standard tuples instead of named tuples.</p> <p>The <code>liquid.expressions</code> module has been removed in favour of a single <code>TokenStream</code> interface (there used to be two) and more sane expression parsing functions or static methods. Here's a summary mapping from old expression parsing functions to the recommended new parsing functions/methods.</p> Old New <code>tokenize_common_expression(str, linenum)</code> <code>liquid.builtin.expressions.tokenize(source, parent_token)</code> <code>*.tokenize(source, linenum)</code> <code>liquid.builtin.expressions.tokenize(source, parent_token)</code> <code>parse_common_expression(stream)</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>parse_keyword_arguments(expr, linenum)</code> <code>liquid.builtin.expressions.KeywordArgument.parse(env, stream)</code> <code>parse_identifier(stream)</code> <code>liquid.builtin.expressions.Path.parse(env, stream)</code> <code>parse_unchained_identifier(stream)</code> <code>liquid.builtin.expressions.parse_identifier(env, stream)</code> <code>parse_string_or_identifier</code> <code>liquid.builtin.expressions.parse_string_or_path(env, stream)</code> <code>parse_unchained_identifier</code> <code>liquid.builtin.expressions.parse_name(env, stream)</code> <code>parse_boolean</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>parse_nil</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>parse_empty</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>parse_blank</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>parse_string_literal</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>parse_integer_literal</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>parse_float_literal</code> <code>liquid.builtin.expressions.parse_primitive(env, stream)</code> <code>Environment.parse_boolean_expression</code> <code>liquid.builtin.expressions.BooleanExpression.parse(env, stream)</code> <code>Environment.parse_filtered_expression</code> <code>liquid.builtin.expressions.FilteredExpression.parse(env, stream)</code> <code>Environment.parse_loop_expression</code> <code>liquid.builtin.expressions.LoopExpression.parse(env, stream)</code>"},{"location":"optional_filters/","title":"Extra filters","text":"<p>The filters described on this page are not enabled by default. You can enable all extra tags and filters, or import and register just the filters you need individually by updating <code>Environment.filters</code>.</p> <p>If we were to import and register all extra filters manually, it would look like this.</p> <pre><code>from liquid import Environment\nfrom liquid.extra import JSON\nfrom liquid.extra import Currency\nfrom liquid.extra import DateTime\nfrom liquid.extra import GetText\nfrom liquid.extra import NGetText\nfrom liquid.extra import NPGetText\nfrom liquid.extra import Number\nfrom liquid.extra import PGetText\nfrom liquid.extra import Translate\nfrom liquid.extra import Unit\nfrom liquid.extra import index\nfrom liquid.extra import script_tag\nfrom liquid.extra import sort_numeric\nfrom liquid.extra import stylesheet_tag\n\nenv = Environment()\nenv.filters[\"index\"] = index\nenv.filters[\"json\"] = JSON()\nenv.filters[\"script_tag\"] = script_tag\nenv.filters[\"sort_numeric\"] = sort_numeric\nenv.filters[\"stylesheet_tag\"] = stylesheet_tag\nenv.filters[GetText.name] = GetText()\nenv.filters[NGetText.name] = NGetText()\nenv.filters[NPGetText.name] = NPGetText()\nenv.filters[PGetText.name] = PGetText()\nenv.filters[Translate.name] = Translate()\nenv.filters[\"currency\"] = Currency()\nenv.filters[\"money\"] = Currency()\nenv.filters[\"money_with_currency\"] = Currency(default_format=\"\u00a4#,##0.00 \u00a4\u00a4\")\nenv.filters[\"money_without_currency\"] = Currency(default_format=\"#,##0.00\")\nenv.filters[\"money_without_trailing_zeros\"] = Currency(\n    default_format=\"\u00a4#,###\",\n    currency_digits=False,\n)\nenv.filters[\"datetime\"] = DateTime()\nenv.filters[\"decimal\"] = Number()\nenv.filters[\"unit\"] = Unit()\n</code></pre>"},{"location":"optional_filters/#currency","title":"currency","text":"<pre><code>&lt;number&gt; | currency[: group_separator: &lt;boolean&gt;] -&gt; &lt;string&gt;\n</code></pre> <p>Currency (aka money) formatting. Return the input number formatted as currency for the current locale. See also <code>money</code>.</p> <pre><code>{{ 100457.99 | currency }}\n</code></pre> output<pre><code>$100,457.99\n</code></pre> <p>Use the <code>group_separator</code> argument to control the output of the current locale's group separators.</p> <pre><code>{{ 100457.99 | currency: group_separator: false }}\n</code></pre> output<pre><code>$100457.99\n</code></pre> <p>If the input number is a string, it will be parsed to a decimal according to the current input locale.</p> <pre><code>{% with input_locale: \"de\", locale: \"en_CA\" %}\n  {{ \"100.457,99\" | currency }}\n{% endwith %}\n</code></pre> output<pre><code>US$100,457.99\n</code></pre>"},{"location":"optional_filters/#datetime","title":"datetime","text":"<pre><code>&lt;datetime&gt; | datetime[: format: &lt;string&gt;] -&gt; &lt;string&gt;\n</code></pre> <p>Date and time formatting. Return the input datetime formatted according to the current locale. If <code>dt</code> is a <code>datetime.datetime</code> object <code>datetime.datetime(2007, 4, 1, 15, 30)</code>.</p> <pre><code>{{ dt | datetime }}\n</code></pre> output<pre><code>Apr 1, 2007, 3:30:00 PM\n</code></pre> <p>The optional <code>format</code> argument can be one of <code>'short'</code>, <code>'medium'</code>, <code>'long'</code>, <code>'full'</code> or a custom format string. <code>format</code> defaults to <code>'medium'</code>.</p> <pre><code>{% with timezone: 'America/New_York' %}\n  {{ dt | datetime: format: 'full' }}\n{% endwith %}\n</code></pre> output<pre><code>Sunday, April 1, 2007 at 11:30:00 AM Eastern Daylight Time\n</code></pre> <p>If the input datetime is a string, it will be parsed to a datetime object.</p> <pre><code>{% with locale: 'en_GB' %}\n  {{ \"Apr 1, 2007, 3:30:00 PM UTC+4\" | datetime: format: 'short' }}\n{% endwith %}\n</code></pre> output<pre><code>01/04/2007, 19:30\n</code></pre>"},{"location":"optional_filters/#decimal","title":"decimal","text":"<pre><code>&lt;number&gt; | decimal[: group_separator: &lt;boolean&gt;] -&gt; &lt;string&gt;\n</code></pre> <p>Decimal number formatting. Return the input number formatted as a decimal for the current locale.</p> <pre><code>{{ '10000.233' | decimal }}\n</code></pre> output<pre><code>10,000.233\n</code></pre> <p>Use the <code>group_separator</code> argument to control the output of the current locale's group separators.</p> <pre><code>{{ '10000.233' | decimal: group_separator: false }}\n</code></pre> output<pre><code>10000.233\n</code></pre> <p>If the input number is a string, it will be parsed to a decimal according to the current input locale.</p> <pre><code>{% with input_locale: \"de\" %}\n  {{ \"100.457,00\" | decimal }}\n{% endwith %}\n</code></pre> output<pre><code>100,457\n</code></pre>"},{"location":"optional_filters/#gettext","title":"gettext","text":"<pre><code>&lt;string&gt; | gettext[: &lt;identifier&gt;: &lt;object&gt; ... ]\n</code></pre> <p>Return the localized translation of the input message without pluralization or message context.</p> <pre><code>{{ \"Hello, World!\" | gettext }}\n</code></pre> output<pre><code>Hallo Welt!\n</code></pre> <p>Any keyword arguments are used to populate message variables. If <code>user.name</code> is <code>\"Sue\"</code>:</p> <pre><code>{{ \"Hello, %(you)s\" | gettext: you: user.name }}\n</code></pre> output<pre><code>Hallo Sue!\n</code></pre>"},{"location":"optional_filters/#json","title":"json","text":"<pre><code>&lt;object&gt; | json[: &lt;indent&gt;]\n</code></pre> <p>Return the input object serialized to a JSON (JavaScript Object Notation) string.</p> data<pre><code>{\n  \"product\": {\n    \"id\": 1234,\n    \"name\": \"Football\"\n  }\n}\n</code></pre> <pre><code>{{ product | json }}\n</code></pre> output<pre><code>{ \"id\": 1234, \"name\": \"Football\" }\n</code></pre>"},{"location":"optional_filters/#pretty-json","title":"Pretty JSON","text":"<p>If an argument is given, it should be an integer defining the amount of indentation that should be applied to a formatted JSON representation of the input object.</p> <pre><code>{{ product | json: indent=2 }}\n</code></pre> output<pre><code>{\n  \"id\": 1234,\n  \"name\": \"Football\"\n}\n</code></pre>"},{"location":"optional_filters/#money","title":"money","text":"<p><code>money</code> is an alias for <code>currency</code>.</p>"},{"location":"optional_filters/#money_with_currency","title":"money_with_currency","text":"<p><code>money_with_currency</code> is an alias for <code>currency</code> with the default format set to <code>\"\u00a4#,##0.00 \u00a4\u00a4\"</code>.</p>"},{"location":"optional_filters/#money_without_currency","title":"money_without_currency","text":"<p><code>money_without_currency</code> is an alias for <code>currency</code> with the default format set to <code>\"#,##0.00\u00a4\"</code>.</p>"},{"location":"optional_filters/#money_without_trailing_zeros","title":"money_without_trailing_zeros","text":"<p><code>money_without_trailing_zeros</code> is an alias for <code>currency</code> with the default format set to <code>\"\u00a4#,###\"</code> and <code>currency_digits</code> set to <code>False</code>.</p>"},{"location":"optional_filters/#ngettext","title":"ngettext","text":"<pre><code>&lt;string&gt; | ngettext: &lt;string&gt;, &lt;number&gt; [, &lt;identifier&gt;: &lt;object&gt; ... ]\n</code></pre> <p>Return the localized translation of the input message with pluralization. The first positional argument is the plural form of the message. The second is a number used to determine if the singular or plural message should be used.</p> <pre><code>{% assign count = \"Earth,Tatooine\" | split: \",\" | size %}\n{{ \"Hello, World!\" | ngetetxt: \"Hello, Worlds!\", count }}\n</code></pre> output<pre><code>Hallo Welten!\n</code></pre> <p>Any keyword arguments are used to populate message variables. If <code>user.name</code> is <code>\"Sue\"</code> and <code>count</code> is <code>1</code>:</p> <pre><code>{{ \"Hello, %(you)s\" | ngetetxt: \"Hello, everyone!\", count, you: user.name }}\n</code></pre> output<pre><code>Hallo Sue!\n</code></pre>"},{"location":"optional_filters/#npgettext","title":"npgettext","text":"<pre><code>&lt;string&gt; | npgettext: &lt;string&gt;, &lt;string&gt;, &lt;number&gt; [, &lt;identifier&gt;: &lt;object&gt; ... ]\n``\n\nReturn the localized translation of the input message with pluralization and a message context. The first positional argument is the message context string, the second is the plural form of the message, and the third is a number used to determine if the singular or plural message should be used.\n\n```liquid2\n{% assign count = \"Earth,Tatooine\" | split: \",\" | size %}\n{{ \"Hello, World!\" | ngetetxt: \"extra special greeting\", \"Hello, Worlds!\", count }}\n</code></pre> output<pre><code>Hallo Welten!\n</code></pre> <p>Any keyword arguments are used to populate message variables. If <code>user.name</code> is <code>\"Sue\"</code> and <code>count</code> is <code>1</code>:</p> <pre><code>{{ \"Hello, %(you)s\" | ngetetxt: \"extra special greeting\", \"Hello, everyone!\", count, you: user.name }}\n</code></pre> output<pre><code>Hallo Sue!\n</code></pre>"},{"location":"optional_filters/#pgettext","title":"pgettext","text":"<pre><code>&lt;string&gt; | pgettext: &lt;string&gt; [, &lt;identifier&gt;: &lt;object&gt; ... ]\n</code></pre> <p>Return the localized translation of the input message with additional message context. Message context is used to give translators extra information about where the messages is to be used.</p> <pre><code>{{ \"Hello, World!\" | pgettext: \"extra special greeting\" }}\n</code></pre> output<pre><code>Hallo Welt!\n</code></pre> <p>Any keyword arguments are used to populate message variables. If <code>user.name</code> is <code>\"Sue\"</code>:</p> <pre><code>{{ \"Hello, %(you)s\" | pgettext: \"extra special greeting\", you: user.name }}\n</code></pre> output<pre><code>Hallo Sue!\n</code></pre>"},{"location":"optional_filters/#sort_numeric","title":"sort_numeric","text":"<pre><code>&lt;sequence&gt; | sort_numeric[: &lt;string&gt;]\n</code></pre> <p>Return a new array/list with items from the input sequence sorted by any integers and/or floats found in the string representation of each item. Note the difference between <code>sort_numeric</code> and <code>sort</code> in this example.</p> <pre><code>{% assign foo = '1.2.1, v1.10.0, v1.1.0, v1.2.2' | split: ', ' -%}\n{{ foo | sort_numeric | join: ', ' }}\n{{ foo | sort | join: ', ' }}\n\n{% assign bar = '107, 12, 0001' | split: ', ' -%}\n{{ bar | sort_numeric | join: ', ' }}\n{{ bar | sort | join: ', ' }}\n</code></pre> output<pre><code>v1.1.0, 1.2.1, v1.2.2, v1.10.0\n1.2.1, v1.1.0, v1.10.0, v1.2.2\n\n0001, 12, 107\n0001, 107, 12\n</code></pre> <p>The optional string argument is the name of a key/property to use as the sort key. In which case each item in the input sequence should be a dict/hash/mapping, each with said key/property.</p> <p><code>sort_numeric</code> will work as expected when given arrays/lists/tuples of integers, floats and/or Decimals, but will be slower than using standard <code>sort</code>.</p> <p>If an input sequence contains strings (or arbitrary objects that get stringified) that do not have numeric characters, they will be pushed to the end of the resulting list, probably in the same order as in the input sequence.</p>"},{"location":"optional_filters/#t","title":"t","text":"<pre><code>&lt;string&gt; | t[: &lt;string&gt;[, &lt;identifier&gt;: &lt;object&gt; ... ]] -&gt; &lt;string&gt;\n</code></pre> <p>Return the localized translation of the input message. For example, if a German Translations object is found in the current render context:</p> <pre><code>{{ \"Hello, World!\" | t }}\n</code></pre> output<pre><code>Hallo Welt!\n</code></pre> <p>If given, the first and only positional argument is a message context string. It will be used to give translators extra information about where the message is to be used. With the default configuration, keyword arguments <code>plural</code> and <code>count</code> are reserved for specifying a pluralizable message.</p> <pre><code>{{ \"Hello, World!\" | t: plural: 'Hello, Worlds!', count: 2 }}\n</code></pre> output<pre><code>Hallo Welten!\n</code></pre> <p>The remaining keyword arguments are used to populate translatable message variables. If <code>user.name</code> is <code>\"Sue\"</code>:</p> <pre><code>{{ \"Hello, %(you)s\" | t: you: user.name }}\n</code></pre> output<pre><code>Hallo Sue!\n</code></pre>"},{"location":"optional_filters/#unit","title":"unit","text":"<pre><code>&lt;number&gt; | unit: &lt;string&gt;\n  [, denominator: &lt;number&gt;]\n  [, denominator_unit: &lt;string&gt;]\n  [, length: &lt;string&gt;]\n  [, format: &lt;string&gt;]\n</code></pre> <p>Return the input number formatted with the given units according to the current locale. The first, required positional argument is a CLDR measurement unit code.</p> <pre><code>{{ 12 | unit: 'length-meter' }}\n</code></pre> output<pre><code>12 meters\n</code></pre>"},{"location":"optional_filters/#length","title":"length","text":"<p><code>length</code> can be one of \"short\", \"long\" or \"narrow\", defaulting to \"long\".</p> <pre><code>{{ 12 | unit: 'length-meter' }}\n{{ 12 | unit: 'length-meter', length: 'short' }}\n{{ 12 | unit: 'length-meter', length: 'long' }}\n{{ 12 | unit: 'length-meter', length: 'narrow' }}\n</code></pre> output<pre><code>12 meters\n12 m\n12 meters\n12m\n</code></pre> <p>Or, if the current locale is set to <code>fr</code>.</p> <pre><code>{% with locale:\"fr\" %}\n  {{ 12 | unit: 'length-meter' }}\n  {{ 12 | unit: 'length-meter', length: 'short' }}\n  {{ 12 | unit: 'length-meter', length: 'long' }}\n  {{ 12 | unit: 'length-meter', length: 'narrow' }}\n{% endwith %}\n</code></pre> output<pre><code>12\u00a0m\u00e8tres\n12\u202fm\n12\u00a0m\u00e8tres\n12m\n</code></pre>"},{"location":"optional_filters/#format","title":"format","text":"<p><code>format</code> is an optional decimal format string, described in the Locale Data Markup Language specification (LDML).</p> <pre><code>{{ 12 | unit: 'length-meter', format: '#,##0.00' }}\n</code></pre> output<pre><code>12.00 meters\n</code></pre>"},{"location":"optional_filters/#compound-units","title":"Compound Units","text":"<p>If a <code>denominator</code> and/or <code>denominator_unit</code> is given, the value will be formatted as a compound unit.</p> <pre><code>{{ 150 | unit: 'kilowatt', denominator_unit: 'hour' }}\n{{ 32.5 | unit: 'ton', denominator: 15, denominator_unit: 'hour' }}\n</code></pre> output<pre><code>150 kilowatts per hour\n32.5 tons per 15 hours\n</code></pre> <p>Or, if the current locale is set to <code>fi</code>.</p> <pre><code>{% with locale:\"fi\" %}\n  {{ 150 | unit: 'kilowatt', denominator_unit: 'hour' }}\n  {{ 32.5 | unit: 'ton', denominator: 15, denominator_unit: 'hour' }}\n{% endwith %}\n</code></pre> output<pre><code>150 kilowattia / tunti\n32,5 am. tonnia/15 tuntia\n</code></pre>"},{"location":"optional_tags/","title":"Extra tags","text":"<p>The tags described on this page are not enabled by default. You can enable all extra tags and filters, or import and register just the tags you need individually using <code>Environment.add_tag()</code>.</p> <p>If we were to register all extra tags manually, it would look like this.</p> <pre><code>from liquid import Environment\nfrom liquid.extra import BlockTag\nfrom liquid.extra import CallTag\nfrom liquid.extra import ExtendsTag\nfrom liquid.extra import MacroTag\nfrom liquid.extra import TranslateTag\nfrom liquid.extra import WithTag\n\nenv = Environment()\nenv.add_tag(BlockTag)\nenv.add_tag(ExtendsTag)\nenv.add_tag(MacroTag)\nenv.add_tag(CallTag)\nenv.add_tag(TranslateTag)\nenv.add_tag(WithTag)\n</code></pre>"},{"location":"optional_tags/#extends","title":"extends","text":"<pre><code>{% extends &lt;template name&gt; %}\n</code></pre> <p>Together with the <code>block</code> tag, the <code>extends</code> tag allows you to inherit content and Liquid markup from parent templates and define blocks that can be overridden by child templates.</p> <p>In this example <code>page.html</code> inherits from <code>base.html</code> and overrides the <code>content</code> block. As <code>page.html</code> does not define a <code>footer</code> block, the footer from <code>base.html</code> is used.</p> base.html<pre><code>&lt;body&gt;\n  &lt;div id=\"content\"&gt;{% block content required %}{% endblock %}&lt;/div&gt;\n  &lt;div id=\"footer\"&gt;{% block footer %}Default footer{% endblock %}&lt;/div&gt;\n&lt;/body&gt;\n</code></pre> page.html<pre><code>{% extends 'base.html' %}\n{% block content %}Hello, {{ you }}!{% endblock %}\n</code></pre>"},{"location":"optional_tags/#block","title":"block","text":"<pre><code>{% block &lt;name&gt; [required] %} &lt;Liquid markup&gt; {% endblock [&lt;name&gt;] %}\n</code></pre> <p>Every <code>block</code> tag must have a name that is unique to the template. <code>endblock</code> tags can include a name too. If given, the <code>endblock</code> name must match the name given at the start of the block.</p> <p>If the optional <code>required</code> argument is given, the block must be overridden by a child template, otherwise a <code>RequiredBlockError</code> will be raised.</p> <pre><code>&lt;body&gt;\n  &lt;div id=\"content\"&gt;\n    {% block content %}\n      {% block title %}\n        &lt;h1&gt;Some Title&lt;/h1&gt;\n      {% endblock title %}\n    {% endblock content %}\n  &lt;/div&gt;\n  &lt;div id=\"footer\"&gt;\n    {% block footer %}\n      Default footer\n    {% endblock footer %}\n  &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"optional_tags/#super-blocks","title":"Super blocks","text":"<p>A <code>block</code> object is available inside every <code>{% block %}</code> tag. It has just one property, <code>super</code>. If a <code>{% block %}</code> is overriding a parent block, <code>{{ block.super }}</code> will render the parent's implementation of that block.</p> <p>In this example we use <code>{{ block.super }}</code> in the <code>footer</code> block to output the base template's footer with a year appended to it.</p> base<pre><code>&lt;head&gt;\n  {% block head %}{% endblock %}\n&lt;head&gt;\n&lt;body&gt;\n  &lt;div id=\"content\"&gt;{% block content required %}{% endblock %}&lt;/div&gt;\n  &lt;div id=\"footer\"&gt;{% block footer %}Default footer{% endblock %}&lt;/div&gt;\n&lt;/body&gt;\n</code></pre> child<pre><code>{% extends \"base\" %}\n{% block content %}Hello, World!{% endblock %}\n{% block footer %}{{ block.super }} - 2025{% endblock %}\n</code></pre> output<pre><code>&lt;body&gt;\n  &lt;div id=\"content\"&gt;Hello, World!&lt;/div&gt;\n  &lt;div id=\"footer\"&gt;Default footer - 2025&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"optional_tags/#macro-and-call","title":"macro and call","text":"<pre><code>{% macro &lt;name&gt; [[,] [ &lt;identifier&gt;[: &lt;expression&gt;]] ... ] %}\n  &lt;liquid markup&gt;\n{% endmacro %}\n</code></pre> <pre><code>{% call &lt;name&gt; [[,] [ &lt;identifier&gt;[: &lt;expression&gt;]] ... ] %}\n</code></pre> <p>The <code>macro</code> tag defines a parameterized block that can later be called using the <code>call</code> tag.</p> <p>A macro is like defining a function. You define a parameter list, possibly with default values, that are expected to be provided by a <code>call</code> tag. A macro tag's block has its own scope including its arguments and template global variables, just like the <code>render</code> tag.</p> <p>Note that argument defaults are bound late. They are evaluated when a call expression is evaluated, not when the macro is defined.</p> <pre><code>{% macro 'price' product, on_sale: false %}\n  &lt;div class=\"price-wrapper\"&gt;\n  {% if on_sale %}\n    &lt;p&gt;Was {{ product.regular_price | prepend: '$' }}&lt;/p&gt;\n    &lt;p&gt;Now {{ product.price | prepend: '$' }}&lt;/p&gt;\n  {% else %}\n    &lt;p&gt;{{ product.price | prepend: '$' }}&lt;/p&gt;\n  {% endif %}\n  &lt;/div&gt;\n{% endmacro %}\n\n{% call 'price' products[0], on_sale: true %}\n{% call 'price' products[1] %}\n</code></pre> <p>Excess arguments passed to <code>call</code> are collected into variables called <code>args</code> and <code>kwargs</code>, so variadic macros a possible too.</p> <pre><code>{% macro 'foo' %}\n  {% for arg in args %}\n    - {{ arg }}\n  {% endfor %}\n\n  {% for arg in kwargs %}\n    - {{ arg.0 }} =&gt; {{ arg.1 }}\n  {% endfor %}\n{% endmacro %}\n\n{% call 'foo' 42, 43, 99, a: 3.14, b: 2.71828 %}\n</code></pre>"},{"location":"optional_tags/#translate","title":"translate","text":"<pre><code>{% translate\n    [context: &lt;string&gt;]\n    [, count: &lt;number&gt;]\n    [, &lt;identifier&gt;: &lt;object&gt; ] ... %}\n  &lt;text,variable&gt; ...\n[ {% plural %} &lt;text,variable&gt; ... ]\n{% endtranslate %}\n</code></pre> <p>The <code>translate</code> tag defines text to be translated into another language. Said text can contain placeholders for variables. These placeholders look like Liquid output statements, but can't use dotted or bracketed property syntax or filters.</p> <p>If a German translations object is found in the current render context, this example would output <code>Hallo Welt!</code>.</p> <pre><code>{% translate %}\n  Hello, World!\n{% endtranslate %}\n</code></pre> <p>If a <code>{% plural %}</code> block follows the message text and the special <code>count</code> argument is considered plural, the <code>{% plural %}</code> block will be rendered instead. Again, with a German translations object, this example would render <code>Hallo Welten!</code>.</p> <pre><code>{% translate count: 2 %}\n  Hello, World!\n{% plural %}\n  Hello, Worlds!\n{% endtranslate %}\n</code></pre> <p>Keyword arguments are used to add (or shadow existing) variables.</p> <pre><code>{% translate you: 'Sue' %}\n  Hello, {{ you }}!\n{% endtranslate %}\n</code></pre>"},{"location":"optional_tags/#with","title":"with","text":"<pre><code>{% with &lt;identifier&gt;: &lt;expression&gt; [, &lt;identifier&gt;: &lt;expression&gt; ... ] %}\n  &lt;liquid markup&gt;\n{% endwith %}\n</code></pre> <p>The <code>with</code> tag extends the template namespace with block scoped variables. These variables have the potential to shadow global variables or variables assigned with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> <pre><code>{% with p: collection.products.first %}\n  {{ p.title }}\n{% endwith %}\n\n{% with a: 1, b: 3.4 %}\n  {{ a }} + {{ b }} = {{ a | plus: b }}\n{% endwith %}\n</code></pre>"},{"location":"render_context/","title":"Render context data","text":"<p>The result of rendering a template depends on the context in which it is rendered. That is, available variables and their values, and options set on the bound Environment.</p> <p>Template global variables are those added to a render context by application developers. From a template author's perspective, globals are read-only and are available to all templates, including those rendered with the <code>{% render %}</code> tag.</p> <p>Template local variables are those defined by template authors using <code>{% assign %}</code> and <code>{% capture %}</code>. Local variables can mask names defined in the global namespace, but never change them.</p> <p>Named counters created with <code>{% increment %}</code> and <code>{% decrement %}</code> have their own namespace. Outside of <code>increment</code> or <code>decrement</code>, Liquid will look in the counters namespace last, after locals and globals.</p>"},{"location":"render_context/#environment-globals","title":"Environment globals","text":"<p>The <code>Environment</code> constructor accepts an optional <code>globals</code> argument, which should be a dictionary mapping variable names to their values. These variables get pinned to the environment and will be automatically merged with other variables for every template rendered from that environment.</p> <pre><code>from liquid import Environment\n\nenv = Environment(globals={\"site_name\": \"MySite\"})\n\ntemplate = env.from_string(\"\"\"\\\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{{ site_name }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;/html&gt;\n\"\"\")\n\nprint(template.render())\n</code></pre> output<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;MySite&lt;/title&gt;\n&lt;/head&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"render_context/#template-globals","title":"Template globals","text":"<p>Similar to Environment globals, you can pin global variables to a template when calling <code>from_string()</code> or <code>get_template()</code>. Global variables set on a template will be merged with any set on its environment and added to each render context automatically.</p> <p>If environment and template globals have conflicting names, template variables take priority over environment variables.</p> <pre><code>from liquid import Environment\n\nenv = Environment(globals={\"site_name\": \"MySite\"})\n\nsource = \"\"\"\\\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{{ site_name }} - {{ page.name }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;/html&gt;\n\"\"\"\n\ntemplate = env.from_string(source, globals={\"page\": {\"name\": \"Blog\"}})\nprint(template.render())\n</code></pre> output<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;MySite - Blog&lt;/title&gt;\n&lt;/head&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"render_context/#render-arguments","title":"Render arguments","text":"<p>Keyword arguments passed to <code>BoundTemplate.render()</code> are also added to the global namespace, although, unlike environment and template globals, they do not persist between calls to <code>render()</code>.</p> <p><code>render()</code> keyword arguments take priority over environment and template globals.</p> <pre><code>from liquid import Environment\n\nenv = Environment(globals={\"site_name\": \"MySite\"})\n\nsource = \"\"\"\\\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;{{ site_name }} - {{ page.name }}&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;p&gt;Hello, {{ user.name }}&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\ntemplate = env.from_string(source, globals={\"page\": {\"name\": \"Blog\"}})\nprint(template.render(user = {\"name\": \"Sally\"}))\n</code></pre> output<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;MySite - Blog&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;p&gt;Hello, Sally&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"render_context/#matter","title":"Matter","text":"<p>Matter variables are those pinned to a <code>Template</code> by a template loader. They could be from a front matter loader or extra meta data from a database loader.</p> <p>These, too, are merged into the global namespace, taking priority over template globals, but not <code>render()</code> keyword arguments.</p>"},{"location":"rendering_templates/","title":"Rendering templates","text":""},{"location":"rendering_templates/#as-simple-as-possible","title":"As simple as possible","text":"<p>For one-off templates using nothing but the default tags and filters, and without the possibility of including, rendering or extending other templates, use the package-level <code>render()</code> function.</p> <p>It takes template source text as a string and any number of keyword arguments that will be available to templates as variables. <code>render()</code> returns a string.</p> <pre><code>from liquid import render\n\nresult = render(\"Hello, {{ you }}!\", you=\"World\")\n</code></pre> <p>If you want to render the same template multiple times with different data, use the package-level <code>parse()</code> function. It takes template source text as a string, an optional name for the template and an optional dictionary of variables to attach to the template. An instance of <code>BoundTemplate</code> with a <code>render()</code> method is returned.</p> <pre><code>from liquid import parse\n\ntemplate = parse(\"Hello, {{ you }}!\")\nresult = template.render(you=\"World\")\nanother_result = template.render(you=\"Liquid\")\n</code></pre>"},{"location":"rendering_templates/#common-configuration","title":"Common configuration","text":"<p>Often, at a minimum, you'll want to configure a template loader that reads template source text from a file system. Doing this will tell the template engine where to look for templates when including, rendering or extending other templates.</p> <pre><code>from liquid import Environment\nfrom liquid import CachingFileSystemLoader\n\nenv = Environment(\n    loader=CachingFileSystemLoader(\"path/to/templates\", ext=\".html\"),\n)\n</code></pre> <p>Now, if there's a file called \"main.html\" in \"/path/to/templates/\", we can use <code>env.get_template()</code> to load and parse it, along with any templates it includes, renders or extends.</p> <pre><code># ... continued from above\ntemplate = env.get_template(\"main.html\")\ndata = {\"foo\": 42, \"bar\": \"hello\"}\nresult = render(**data)\n</code></pre> <p>See Liquid environments for more information about configuring an <code>Environment</code> and loading templates for details of the built-in template loaders.</p>"},{"location":"static_analysis/","title":"Static template analysis","text":"<p>Instances of <code>BoundTemplate</code>, as returned by <code>parse()</code>, <code>from_string()</code> and <code>get_template()</code>, include several methods for inspecting a template's variable, tag a filter usage, without rendering the template.</p> <p>By default, all of these methods will try to load and analyze included, rendered and extended templates too. Set the <code>include_partials</code> keyword only argument to <code>False</code> to disable automatic loading and analysis of partial/parent templates.</p>"},{"location":"static_analysis/#variables","title":"Variables","text":"<p><code>variables()</code> and <code>variables_async()</code> return a list of distinct variables used in the template, without path segments. The list will include variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>, or are in scope from <code>{% for %}</code> tags.</p> <pre><code>from liquid import parse\n\nsource = \"\"\"\\\nHello, {{ you }}!\n{% assign x = 'foo' | upcase %}\n\n{% for ch in x %}\n    - {{ ch }}\n{% endfor %}\n\nGoodbye, {{ you.first_name | capitalize }} {{ you.last_name }}\nGoodbye, {{ you.first_name }} {{ you.last_name }}\n\"\"\"\n\ntemplate = parse(source)\nprint(template.variables())\n</code></pre> output<pre><code>['you', 'x', 'ch']\n</code></pre>"},{"location":"static_analysis/#variable-paths","title":"Variable paths","text":"<p><code>variable_paths()</code> and <code>variable_paths_async()</code> return a list of variables used in the template, including all path segments. The list will include variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>, or are in scope from <code>{% for %}</code> tags.</p> <pre><code># ... continued from above\n\nprint(template.variable_paths())\n</code></pre> output<pre><code>['you.first_name', 'you', 'you.last_name', 'x', 'ch']\n</code></pre>"},{"location":"static_analysis/#variable-segments","title":"Variable segments","text":"<p><code>variable_segments()</code> and <code>variable_segments_async()</code> return a list of variables used in the template, each as a list of segments. The list will include variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>, or are in scope from <code>{% for %}</code> tags.</p> <pre><code># ... continued from above\n\nprint(template.variable_segments())\n</code></pre> output<pre><code>[\n    [\"you\", \"last_name\"],\n    [\"you\"],\n    [\"you\", \"first_name\"],\n    [\"ch\"],\n    [\"x\"],\n]\n</code></pre>"},{"location":"static_analysis/#global-variables","title":"Global variables","text":"<p><code>global_variables()</code> and <code>global_variables_async()</code> return a list of variables used in the template, without path segments and excluding variables that are local to the template.</p> <pre><code># ... continued from above\n\nprint(template.global_variables())\n</code></pre> output<pre><code>['you']\n</code></pre>"},{"location":"static_analysis/#global-variable-paths","title":"Global variable paths","text":"<p><code>global_variable_paths()</code> and <code>global_variable_paths_async()</code> return a list of variables used in the template, with path segments and excluding variables that are local to the template.</p> <pre><code># ... continued from above\n\nprint(template.global_variable_paths())\n</code></pre> output<pre><code>['you', 'you.first_name', 'you.last_name']\n</code></pre>"},{"location":"static_analysis/#global-variable-segments","title":"Global variable segments","text":"<p><code>global_variable_segments()</code> and <code>global_variable_segments_async()</code> return a list of variables used in the template, each as a list of segments, excluding variables that are local to the template.</p> <pre><code># ... continued from above\n\nprint(template.global_variable_segments())\n</code></pre> output<pre><code>[\n    ['you', 'last_name'],\n    ['you', 'first_name'],\n    ['you'],\n]\n</code></pre>"},{"location":"static_analysis/#filter-names","title":"Filter names","text":"<p><code>filter_names()</code> and <code>filter_names_async()</code> return names of filters used in the template.</p> <pre><code># ... continued from above\n\nprint(template.filter_names())\n</code></pre> output<pre><code>['upcase', 'capitalize']\n</code></pre>"},{"location":"static_analysis/#tag-names","title":"Tag names","text":"<p><code>tag_names()</code> and <code>tag_names_async()</code> return the names of tags used in the template.</p> <pre><code># ... continued from above\n\nprint(template.tag_names())\n</code></pre> output<pre><code>['assign', 'for']\n</code></pre>"},{"location":"static_analysis/#variable-tag-and-filter-locations","title":"Variable, tag and filter locations","text":"<p><code>analyze()</code> and <code>analyze_async()</code> return an instance of <code>TemplateAnalysis</code>. It contains all of the information provided by the methods described above, but includes the location of each variable, tag and filter, each of which can appear many times across many templates.</p>"},{"location":"syntax/","title":"Liquid Syntax","text":"<p>Liquid is a template language, where source text (the template) contains placeholders for variables, conditional expressions for including or excluding blocks of text, and loops for repeating blocks of text. Plus other syntax for manipulating variables and combining multiple templates into a single output.</p> <p>Output text is the result of rendering a template given some data model. It is that data model that provides the variables and objects referenced in a template's expressions.</p> <p>Liquid is most commonly used with HTML or Markdown, but can be used with any text-based content. Consider this example template.</p> <pre><code>&lt;main&gt;\n  &lt;h2&gt;{{ page_heading | default: \"Welcome to Our Benchmark Test\" }}&lt;/h2&gt;\n  &lt;p&gt;{{ intro_text | default: \"This is a dynamically generated page.\" }}&lt;/p&gt;\n\n  {% # About us section }\n  &lt;section&gt;\n    &lt;h3&gt;About Us&lt;/h3&gt;\n    {% if site_description %}\n      &lt;p&gt;{{ site_description }}&lt;/p&gt;\n    {% endif %}\n  &lt;section&gt;\n\n  &lt;section&gt;\n    &lt;h3&gt;Items List&lt;/h3&gt;\n    {% assign items_size = items | size %}\n    {% if items_size &gt; 0 %}\n      {% for item in items %}\n        &lt;div class=\"item\"&gt;\n          &lt;h4&gt;{{ item.title | capitalize }}&lt;/h4&gt;\n          &lt;p&gt;{{ item.description | escape }}&lt;/p&gt;\n          &lt;p&gt;Price: {{ item.price | ceil }} USD&lt;/p&gt;\n\n          {% if item.price &gt; 50 %}\n            &lt;p&gt;This is a premium item.&lt;/p&gt;\n            {% else %}\n            &lt;p&gt;This is a budget-friendly item.&lt;/p&gt;\n          {% endif %}\n        &lt;/div&gt;\n      {% endfor %}\n    {% else %}\n      &lt;p&gt;No items are available at the moment.&lt;/p&gt;\n    {% endif %}\n  &lt;/section&gt;\n&lt;/main&gt;\n</code></pre>"},{"location":"syntax/#output","title":"Output","text":"<p><code>{{ site_description }}</code> and <code>{{ item.title | capitalize }}</code> are examples of output statements. Expressions surrounded by double curly braces, <code>{{</code> and <code>}}</code>, will be evaluated and the result inserted into the output text.</p>"},{"location":"syntax/#filters","title":"Filters","text":"<p><code>capitalize</code> in <code>{{ item.title | capitalize }}</code> and <code>ceil</code> in <code>{{ item.price | ceil }}</code> are examples of filters. Filters modify the expression to their left prior to output or assignment.</p>"},{"location":"syntax/#tags","title":"Tags","text":"<p><code>{% if site_description %}</code>, <code>{% endif %}</code> and <code>{% assign items_size = items | size %}</code> are examples of tags. After the start tag delimiter (<code>{%</code>) there must be a tag name. Everything up to the closing tag delimiter (<code>%}</code>) is the tags's expression.</p> <p>Not all tags accept an expression, but all tag must have a name.</p> <p>Together <code>{% if site_description %}</code> and <code>{% endif %}</code> form a block tag. Block tags have an opening tag, some Liquid in between, and an end tag. In the case of the <code>if tag</code>, the block is only rendered if the tag's expression evaluates to true.</p> <p><code>{% assign items_size = items | size %}</code> is an inline tag. It does not have an end tag and it does not output anything, although some inline tags do produce an output.</p>"},{"location":"syntax/#comments","title":"Comments","text":"<p><code>{% # About us section %}</code> is an example of a comment. Text between <code>{% #</code> and <code>%}</code> will not be parsed or rendered.</p>"},{"location":"syntax/#content","title":"Content","text":"<p><code>&lt;main&gt;</code> and <code>\\n    &lt;h3&gt;About Us&lt;/h3&gt;</code> are examples of template content. That's anything not inside <code>{%</code> and <code>%}</code> or <code>{{</code> and <code>}}</code>. With the exception of whitespace control, template content is output unchanged.</p>"},{"location":"syntax/#whitespace-control","title":"Whitespace control","text":"<p>By default, all whitespace immediately before and after a tag is preserved. This can result in a lot of unwanted whitespace.</p> <pre><code>&lt;ul&gt;\n{% for x in (1..4) %}\n  &lt;li&gt;{{ x }}&lt;/li&gt;\n{% endfor %}\n&lt;/ul&gt;\n</code></pre> output<pre><code>&lt;ul&gt;\n\n  &lt;li&gt;1&lt;/li&gt;\n\n  &lt;li&gt;2&lt;/li&gt;\n\n  &lt;li&gt;3&lt;/li&gt;\n\n  &lt;li&gt;4&lt;/li&gt;\n\n&lt;/ul&gt;\n</code></pre> <p>We can include a <code>-</code> at the start or end of a tag or output markup to strip preceding or trailing whitespace.</p> <pre><code>&lt;ul&gt;\n{% for x in (1..4) -%}\n  &lt;li&gt;{{ x }}&lt;/li&gt;\n{% endfor -%}\n&lt;/ul&gt;\n</code></pre> output<pre><code>&lt;ul&gt;\n&lt;li&gt;1&lt;/li&gt;\n&lt;li&gt;2&lt;/li&gt;\n&lt;li&gt;3&lt;/li&gt;\n&lt;li&gt;4&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> <p>Note</p> <p>Fine grained control over when to remove newlines vs indentation is not a standard feature of Liquid templates.</p>"},{"location":"tag_reference/","title":"Default tags","text":"<p>All the tags described here are enabled by default in Python Liquid.</p>"},{"location":"tag_reference/#comments","title":"Comments","text":"<p>Comments can be used to add documentation to your templates or \"comment out\" chunks of Liquid markup and text so that it wont be rendered.</p>"},{"location":"tag_reference/#block-comments","title":"Block comments","text":"<pre><code>{% comment %} ... {% endcomment %}\n</code></pre> <p>Block comments start with the <code>comment</code> tag and end with the <code>endcomment</code> tag. It is OK for comment text to contain matching <code>comment</code>/<code>endcomment</code> or <code>raw</code>/<code>endraw</code> pairs, but is a syntax error if <code>comment</code> or <code>raw</code> tags are unbalanced.</p> <pre><code>{% comment %}This is a comment{% endcomment %}\n{% comment %}\n    Comments can\n    span\n    multiple lines\n{% endcomment %}\n</code></pre>"},{"location":"tag_reference/#inline-comments","title":"Inline comments","text":"<pre><code>{% # ... %}\n</code></pre> <p>An inline comment is a tag called <code>#</code>. Everything after the hash up to the end tag delimiter (<code>%}</code>) is comment text. Text can span multiple lines, but each line must start with a <code>#</code>.</p> <pre><code>{% # This is a comment %}\n{%-\n  # Comments can span multiple lines,\n  # but every line must start with a hash.\n-%}\n</code></pre> <p>Inside liquid tags, any line starting with a hash will be considered a comment.</p> <pre><code>{% liquid\n  # This is a comment\n  echo \"Hello\"\n%}\n</code></pre>"},{"location":"tag_reference/#output","title":"Output","text":"<pre><code>{{ &lt;expression&gt; }}\n</code></pre> <p>An expression surrounded by double curly braces, <code>{{</code> and <code>}}</code>, is an output statement. When rendered, the expression will be evaluated and the result inserted into the output text.</p> <p>In this example the expression is a variable, which will be resolved to a value and the value's string representation will output, but output statements can contain any primitive expression.</p> <pre><code>Hello, {{ you }}!\n</code></pre>"},{"location":"tag_reference/#primitive-expressions","title":"Primitive expressions","text":"Primitive expression Examples Boolean literal <code>true</code> or <code>false</code> Null literal <code>null</code> or <code>nil</code> Integer literal <code>123</code> Float literal <code>1.23</code> String literal <code>\"Hello\"</code> or <code>'Hello'</code> Range <code>(1..5)</code> or <code>(x..y)</code> A path to a variable <code>foo</code> or <code>foo.bar</code> or <code>foo.bar[0]</code> or <code>foo[\"some thing\"].bar</code>"},{"location":"tag_reference/#filters","title":"Filters","text":"<pre><code>{{ &lt;expression&gt; | &lt;filter&gt; [| &lt;filter&gt; ...] }}\n</code></pre> <p>Values can be modified prior to output using filters. Filters are applied to an expression using the pipe symbol (<code>|</code>), followed by the filter's name and, possibly, some filter arguments. Filter arguments appear after a colon (<code>:</code>) and are separated by commas (<code>,</code>).</p> <p>Multiple filters can be chained together, effectively piping the output of one filter into the input of another. See the filter reference for details of all built in filters.</p> <pre><code>{{ user_name | upcase }}\n{{ 42 | plus: 7 | modulo: 3 }}\n</code></pre>"},{"location":"tag_reference/#assign","title":"assign","text":"<pre><code>{% assign &lt;identifier&gt; = &lt;expression&gt; %}\n</code></pre> <p>The <code>assign</code> tag is used to define and initialize new variables or reassign existing variables.</p> <pre><code>{% assign foo = \"bar\" %}\nfoo is equal to {{ foo }}.\n\n{% assign foo = 42 %}\nfoo is now equal to {{ foo }}.\n</code></pre> <p>The expression on the right-hand side of the assignment operator (<code>=</code>) follows the syntax described in Output above. It can be any primitive expression and it can include filters.</p>"},{"location":"tag_reference/#capture","title":"capture","text":"<pre><code>{% capture &lt;identifier&gt; %} &lt;liquid markup&gt; {% endcapture %}\n</code></pre> <p>The <code>capture</code> tag evaluates the contents of its block and saves the resulting string as a new variable, or reassigns an existing variable, without immediately rendering it.</p> <pre><code>{% capture welcome_message %}\n  Hello, {{ customer.name }}! Welcome to our store.\n{% endcapture %}\n\n{{ welcome_message }}\n</code></pre> <p>In some cases, it can be easier to use a template string.</p> <pre><code>{% assign welcome_message = \"Hello, ${ customer.name }! Welcome to our store.\" %}\n</code></pre>"},{"location":"tag_reference/#case","title":"case","text":"<pre><code>{% case &lt;expression&gt; %}\n  [ {% when &lt;expression&gt; %} &lt;liquid markup&gt; ] ...\n  [ {% else %} &lt;liquid markup&gt; ]\n{% endcase %}\n</code></pre> <p>The <code>case</code> tag evaluates an expression, matching the result against one or more <code>when</code> clauses. In the event of a match, the <code>when</code> block is rendered. The <code>else</code> clause is rendered if no <code>when</code> clauses match the <code>case</code> expression.</p> <pre><code>{% assign day = \"Monday\" %}\n\n{% case day %}\n  {% when \"Monday\" %}\n    Start of the work week!\n  {% when \"Friday\" %}\n    It's almost the weekend!\n  {% when \"Saturday\" or \"Sunday\" %}\n    Enjoy your weekend!\n  {% else %}\n    Just another weekday.\n{% endcase %}\n</code></pre>"},{"location":"tag_reference/#cycle","title":"cycle","text":"<pre><code>{% cycle [ &lt;string or identifier&gt;: ] &lt;expression&gt; [, &lt;expression&gt; ... ] %}\n</code></pre> <p>Render the next item in an iterator, initializing it and rendering the first value if it does not yet exist. When the items are exhausted, the iterator starts again from the beginning.</p> <pre><code>{% cycle 'odd', 'even' %}\n{% cycle 'odd', 'even' %}\n{% cycle 'odd', 'even' %}\n</code></pre> <p>You can give <code>cycle</code> a name to further distinguish multiple iterators with the same items.</p> <pre><code>{% cycle 'odd', 'even' %}\n{% cycle 'odd', 'even' %}\n{% cycle inner: 'odd', 'even' %}\n</code></pre>"},{"location":"tag_reference/#decrement","title":"decrement","text":"<pre><code>{% decrement &lt;identifier&gt; %}\n</code></pre> <p>The <code>decrement</code> tag renders the next value in a named counter, reducing the count by one each time. If a counter with the given name does not already exist, it is created automatically and initialized to zero, before subtracting 1 and outputting <code>-1</code>.</p> <pre><code>{% decrement some %}\n{% decrement thing %}\n{% decrement thing %}\n</code></pre>"},{"location":"tag_reference/#echo","title":"echo","text":"<pre><code>{% echo &lt;expression&gt; %}\n</code></pre> <p>The <code>echo</code> tag is equivalent to output statements, an expression surrounded by <code>{{</code> and <code>}}</code>, just in tag form. It is mostly used inside <code>{% liquid %}</code> tags where plain output statements are not allowed.</p> <pre><code>Hello, {% echo you %}!\nHello, {{ you }}!\n\n{% liquid\n  for product in collection.products\n    echo product.title | capitalize\n  endfor\n%}\n</code></pre> <p>Just like output statements and the <code>assign</code> tag, the expression can be any primitive expression and it can include filters.</p> <pre><code>{% echo \"bar\" | upcase if x else \"baz\" | capitalize %}\n\n{% liquid\n  for product in collection.products\n    echo product.title | capitalize\n  endfor\n%}\n</code></pre>"},{"location":"tag_reference/#for","title":"for","text":"<pre><code>{% for &lt;identifier&gt; in &lt;expression&gt;\n    [ limit: &lt;expression&gt; ] [ offset: &lt;expression&gt; ] [ reversed ] %}\n  &lt;liquid markup&gt;\n  [ {% else %} &lt;liquid markup&gt; ]\n{% endfor %}\n</code></pre> <p>The <code>for</code> tag renders its block once for each item in an iterable object, like an array/list or mapping/dict/hash. If the iterable is empty and an <code>else</code> block given, it will be rendered instead.</p> <pre><code>{% for product in collection %}\n    - {{ product.title }}\n{% else %}\n    No products available\n{% endfor %}\n</code></pre> <p>Range expression are often used with the <code>for</code> tag to loop over increasing integers.</p> <pre><code>{% for i in (1..4) %}\n    {{ i }}\n{% endfor %}\n</code></pre>"},{"location":"tag_reference/#limit","title":"limit","text":"<p>If a <code>limit</code> argument is given, the loop will stop after the specified number of iterations.</p> <pre><code>{% for product in collection.products limit: 2 %}\n    - {{ product.title }}\n{% endfor %}\n</code></pre>"},{"location":"tag_reference/#offset","title":"offset","text":"<p>If an <code>offset</code> argument is given, it should be an integer specifying how many items to skip before starting the loop.</p> <pre><code>{% for product in collection.products limit: 2 %}\n    - {{ product.title }}\n{% endfor %}\n</code></pre> <p><code>offset</code> can also be given the special value <code>\"continue\"</code>, in which case the loop will start from where a previous loop with the same iterable left off.</p> <pre><code>{% for product in collection.products limit: 2 %}\n    - {{ product.title }}\n{% endfor %}\n\n{% for product in collection.products offset: continue %}\n    - {{ product.title }}!\n{% endfor %}\n</code></pre>"},{"location":"tag_reference/#reversed","title":"reversed","text":"<p>If the reversed flag is given, the target iterable will be iterated in reverse order.</p> <pre><code>{% for product in collection.products reversed %}\n    - {{ product.title }}\n{% endfor %}\n</code></pre>"},{"location":"tag_reference/#break","title":"break","text":"<p>You can exit a loop early using the <code>break</code> tag.</p> <pre><code>{% for product in collection.products %}\n    {% if product.title == \"Shirt\" %}\n        {% break %}\n    {% endif %}\n    - {{ product.title }}\n{% endfor %}\n</code></pre>"},{"location":"tag_reference/#continue","title":"continue","text":"<p>You can skip all or part of a loop iteration with the <code>continue</code> tag.</p> <pre><code>{% for product in collection.products %}\n    {% if product.title == \"Shirt\" %}\n        {% continue %}\n    {% endif %}\n    - {{ product.title }}\n{% endfor %}\n</code></pre>"},{"location":"tag_reference/#forloop","title":"forloop","text":"<p>A <code>forloop</code> object is available inside every <code>for</code> tag block.</p> Property Description Type <code>name</code> The loop variable name and target identifier, separated by a hyphen. string <code>length</code> The length of the sequence being iterated. integer <code>index</code> The 1-base index of the current iteration. integer <code>index0</code> The 0-base index of the current iteration. integer <code>rindex</code> The 1-base index of the current iteration counting from the end. integer <code>rindex0</code> The 0-base index of the current iteration counting from the end. integer <code>first</code> <code>true</code> if the current iteration is the first, <code>false</code> otherwise. bool <code>last</code> <code>true</code> is the current iteration is the last, <code>false</code> otherwise. bool <code>parentloop</code> the <code>forloop</code> object of an enclosing <code>for</code> loop. forloop <pre><code>{% for product in collection.products %}\n    {% if forloop.first %}\n      &lt;b&gt;{{ product.title }}&lt;/b&gt; - {{ forloop.index0 }}\n    {% else %}\n      {{ product.title }} - {{ forloop.index0 }}\n    {% endif %}\n{% endfor %}\n</code></pre>"},{"location":"tag_reference/#if","title":"if","text":"<pre><code>{% if &lt;expression&gt; %}\n  &lt;liquid markup&gt;\n  [ {% elsif &lt;expression&gt; %} &lt;liquid markup&gt; [ {% elsif &lt;expression&gt; %} ... ]]\n  [ {% else %} &lt;liquid markup&gt; ... ]\n{% endif %}\n</code></pre> <p>The <code>if</code> tag conditionally renders its block if its expression evaluates to be truthy. Any number of <code>elsif</code> blocks can be given to add alternative conditions, and an <code>else</code> block is used as a default if no preceding conditions were truthy.</p> <pre><code>{% if product.title == \"OK Hat\" %}\n  This hat is OK.\n{% elsif product.title == \"Rubbish Tie\" %}\n  This tie is rubbish.\n{% else %}\n  Not sure what this is.\n{% endif %}\n</code></pre>"},{"location":"tag_reference/#conditional-expressions","title":"Conditional expressions","text":"<p>Any primitive expression can be tested for truthiness, like <code>{% if some_variable %}</code>, or you can use a combination of the following operators. Only <code>false</code>, <code>nil</code>/<code>null</code> and the special undefined object are falsy in Liquid.</p> Operator Description Example <code>==</code> Equals <code>product.title == \"Nice Shoes\"</code> <code>!=</code> Not equals <code>user.name != \"anonymous\"</code> <code>&gt;</code> Greater than <code>product.was_price &gt; product.price</code> <code>&lt;</code> Less than <code>collection.products.size &lt; 10</code> <code>&gt;=</code> Greater than or equal to <code>user.age &gt;= 18</code> <code>&lt;=</code> Less than or equal to <code>basket.size &lt;= 0</code> <code>and</code> Logical and <code>x and y</code> <code>or</code> Logical or <code>x or y</code>"},{"location":"tag_reference/#operator-precedence","title":"Operator precedence","text":"<p>In Liquid, <code>and</code> and <code>or</code> operators are right associative. Where <code>true and false and false or true</code> is equivalent to <code>(true and (false and (false or true)))</code>, evaluating to <code>false</code>. Python, on the other hand, would parse the same expression as <code>(((true and false) and false) or true)</code>, evaluating to <code>true</code>.</p>"},{"location":"tag_reference/#include","title":"include","text":"<pre><code>{% include &lt;template name&gt;\n    [ ( with | for ) &lt;expression&gt; [ as &lt;identifier&gt; ]]\n    [[,] &lt;identifier&gt;: &lt;expression&gt; [, [&lt;identifier&gt;: &lt;expression&gt; ... ]]]\n%}\n</code></pre> <p>The <code>include</code> tag loads and renders a named template, inserting the resulting text in its place. The name of the template to include can be a string literal or a variable resolving to a string. When rendered, the included template will share the same scope as the current template.</p> <pre><code>{% include \"snippets/header.html\" %}\n</code></pre>"},{"location":"tag_reference/#with","title":"with","text":"<p>Using the optional <code>with</code> syntax, we can bind a value to a variable that will be in scope for the included template. By default, that variable will be the name of the included template. Alternatively we can specify the variable to use with the <code>as</code> keyword followed by an identifier.</p> <p>Here, the template named <code>greeting</code> will have access to a variable called <code>greeting</code> with the value <code>\"Hello\"</code>.</p> <pre><code>{% assign greetings = \"Hello,Goodbye\" | split: \",\" %}\n{% include \"greeting\" with greetings.first %}\n</code></pre>"},{"location":"tag_reference/#for_1","title":"for","text":"<p>If an array-like object it given following the <code>for</code> keyword, the named template will be rendered once for each item in the sequence and, like <code>with</code> above, the item value will be bound to a variable named after the included template.</p> <p>In this example the template named <code>greeting</code> will be rendered once with the variable <code>greeting</code> set to <code>\"Hello\"</code> and once with the variable <code>greeting</code> set to <code>\"Goodbye\"</code>.</p> <pre><code>{% assign greetings = \"Hello, Goodbye\" | split: \", \" %}\n{% include \"greeting\" for greetings as greeting %}\n</code></pre>"},{"location":"tag_reference/#keyword-arguments","title":"Keyword arguments","text":"<p>Additional keyword arguments given to the <code>include</code> tag will be added to the included template's scope, then go out of scope after the included template has been rendered.</p> <pre><code>{% include \"partial_template\" greeting: \"Hello\", num: 3, skip: 2 %}\n</code></pre>"},{"location":"tag_reference/#increment","title":"increment","text":"<pre><code>{% increment &lt;identifier&gt; %}\n</code></pre> <p>The <code>increment</code> tag renders the next value in a named counter, increasing the count by one each time. If a counter with the given name does not already exist, it is created automatically and initialized to zero, which is output before adding <code>1</code>.</p> <pre><code>{% increment some %}\n{% increment thing %}\n{% increment thing %}\n</code></pre>"},{"location":"tag_reference/#liquid","title":"liquid","text":"<pre><code>{% liquid\n  &lt;tag name&gt; [&lt;expression&gt;]\n  [ &lt;tag name&gt; [&lt;expression&gt;]]\n  ...\n%}\n</code></pre> <p>The <code>liquid</code> tag encloses line statements, where each line starts with a tag name and is followed by the tag's expression. Expressions inside <code>liquid</code> tags must fit on one line as we use <code>\\n</code> as a delimiter indicating the end of the expression.</p> <p>Note that output statement syntax (<code>{{ &lt;expression&gt; }}</code>) is not allowed inside <code>liquid</code> tags, so you must use the <code>echo</code> tag instead.</p> <pre><code>{% liquid\n  assign username = \"Brian\"\n\n  if username\n    echo \"Hello, \" | append: username\n  else\n    echo \"Hello, user\"\n  endif\n\n  for i in (1..3)\n    echo i\n  endfor\n%}\n</code></pre> <p>Also, inside <code>liquid</code> tags, any line starting with a hash will be considered a comment.</p> <pre><code>{% liquid\n  # This is a comment\n  echo \"Hello\"\n%}\n</code></pre>"},{"location":"tag_reference/#raw","title":"raw","text":"<pre><code>{% raw %} &lt;text&gt; {% endraw %}\n</code></pre> <p>Any text between <code>{% raw %}</code> and <code>{% endraw %}</code> will not be interpreted as Liquid markup, but output as plain text instead.</p> <pre><code>{% raw %}\n  This will be rendered {{verbatim}}, with the curly brackets.\n{% endraw %}\n</code></pre>"},{"location":"tag_reference/#render","title":"render","text":"<pre><code>{% render &lt;string&gt;\n    [ ( with | for ) &lt;expression&gt; [ as &lt;identifier&gt; ]]\n    [[,] &lt;identifier&gt;: &lt;expression&gt; [, [&lt;identifier&gt;: &lt;expression&gt; ... ]]]\n%}\n</code></pre> <p>The <code>render</code> tag loads and renders a named template, inserting the resulting text in its place. The name of the template to include must be a string literal. When rendered, the included template will have its onw scope, without variables define in the calling template.</p> <pre><code>{% render \"snippets/header.html\" %}\n</code></pre>"},{"location":"tag_reference/#with_1","title":"with","text":"<p>Using the optional <code>with</code> syntax, we can bind a value to a variable that will be in scope for the rendered template. By default, that variable will be the name of the rendered template. Alternatively we can specify the variable to use with the <code>as</code> keyword followed by an identifier.</p> <p>Here, the template named <code>greeting</code> will have access to a variable called <code>greeting</code> with the value <code>\"Hello\"</code>.</p> <pre><code>{% assign greetings = \"Hello,Goodbye\" | split: \",\" %}\n{% render \"greeting\" with greetings.first %}\n</code></pre>"},{"location":"tag_reference/#for_2","title":"for","text":"<p>If an array-like object it given following the <code>for</code> keyword, the named template will be rendered once for each item in the sequence and, like <code>with</code> above, the item value will be bound to a variable named after the rendered template.</p> <p>In this example the template named <code>greeting</code> will be rendered once with the variable <code>greeting</code> set to <code>\"Hello\"</code> and once with the variable <code>greeting</code> set to <code>\"Goodbye\"</code>.</p> <pre><code>{% assign greetings = \"Hello, Goodbye\" | split: \", \" %}\n{% render \"greeting\" for greetings as greeting %}\n</code></pre>"},{"location":"tag_reference/#keyword-arguments_1","title":"Keyword arguments","text":"<p>Additional keyword arguments given to the <code>render</code> tag will be added to the rendered template's scope, then go out of scope after the it has been rendered.</p> <pre><code>{% render \"partial_template\" greeting: \"Hello\", num: 3, skip: 2 %}\n</code></pre>"},{"location":"tag_reference/#tablerow","title":"tablerow","text":"<pre><code>{% tablerow &lt;identifier&gt; in &lt;expression&gt;\n    [ cols: &lt;expression&gt; ] [ limit: &lt;expression&gt; ] [ offset: &lt;expression&gt; ] %}\n  &lt;liquid markup&gt;\n{% endtablerow %}\n</code></pre> <p>The <code>tablerow</code> tag renders HTML <code>&lt;tr&gt;</code> and <code>&lt;td&gt;</code> elements for each item in an iterable. Text inside <code>&lt;td&gt;</code> elements will be the result of rendering the tag's block.</p> data<pre><code>{\n  \"collection\": {\n    \"products\": [\n      { \"title\": \"Cool Shirt\" },\n      { \"title\": \"Alien Poster\" },\n      { \"title\": \"Batman Poster\" },\n      { \"title\": \"Bullseye Shirt\" },\n      { \"title\": \"Another Classic Vinyl\" },\n      { \"title\": \"Awesome Jeans\" }\n    ]\n  }\n}\n</code></pre> template<pre><code>&lt;table&gt;\n{% tablerow product in collection.products %}\n  {{ product.title }}\n{% endtablerow %}\n&lt;/table&gt;\n</code></pre> output<pre><code>&lt;table&gt;\n  &lt;tr class=\"row1\"&gt;\n    &lt;td class=\"col1\"&gt;Cool Shirt&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Alien Poster&lt;/td&gt;\n    &lt;td class=\"col3\"&gt;Batman Poster&lt;/td&gt;\n    &lt;td class=\"col4\"&gt;Bullseye Shirt&lt;/td&gt;\n    &lt;td class=\"col5\"&gt;Another Classic Vinyl&lt;/td&gt;\n    &lt;td class=\"col6\"&gt;Awesome Jeans&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"tag_reference/#cols","title":"cols","text":"<p>By default, <code>tablerow</code> will output one row with one column for each item in the sequence. Use the <code>cols</code> parameter to set the number of columns.</p> template<pre><code>{% tablerow product in collection.products cols:2 %}\n  {{ product.title }}\n{% endtablerow %}\n</code></pre> output<pre><code>&lt;table&gt;\n  &lt;tr class=\"row1\"&gt;\n    &lt;td class=\"col1\"&gt;Cool Shirt&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Alien Poster&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr class=\"row2\"&gt;\n    &lt;td class=\"col1\"&gt;Batman Poster&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Bullseye Shirt&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr class=\"row3\"&gt;\n    &lt;td class=\"col1\"&gt;Another Classic Vinyl&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Awesome Jeans&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"tag_reference/#limit_1","title":"limit","text":"<p>If <code>limit</code> is specified, the <code>tablerow</code> loop will stop after the given number of iterations.</p> template<pre><code>&lt;table&gt;\n{% tablerow product in collection.products limit:2 %}\n  {{ product.title }}\n{% endtablerow %}\n&lt;/table&gt;\n</code></pre> output<pre><code>&lt;table&gt;\n  &lt;tr class=\"row1\"&gt;\n    &lt;td class=\"col1\"&gt;Cool Shirt&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Alien Poster&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"tag_reference/#offset_1","title":"offset","text":"<p>If <code>offset</code> is specified, the <code>tablerow</code> loop will start at the given index in the sequence.</p> template<pre><code>&lt;table&gt;\n{% tablerow product in collection.products offset:4 %}\n  {{ product.title }}\n{% endtablerow %}\n&lt;/table&gt;\n</code></pre> output<pre><code>&lt;table&gt;\n  &lt;tr class=\"row1\"&gt;\n    &lt;td class=\"col1\"&gt;Another Classic Vinyl&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Awesome Jeans&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"tag_reference/#tablerowloop","title":"tablerowloop","text":"<p>A <code>tablerowloop</code> object is available inside every <code>tablerow</code> block.</p> Property Description Type <code>length</code> The length of the sequence being iterated integer <code>index</code> The 1-base index of the current iteration integer <code>index0</code> The 0-base index of the current iteration integer <code>rindex</code> The 1-base index of the current iteration counting from the end integer <code>rindex0</code> The 0-base index of the current iteration counting from the end integer <code>first</code> <code>true</code> if the current iteration is the first, <code>false</code> otherwise bool <code>last</code> <code>true</code> is the current iteration is the last, <code>false</code> otherwise bool <code>col</code> The 1-based column number integer <code>col0</code> The 0-based column number integer <code>col_first</code> <code>true</code> if the current column is the first column, <code>false</code> otherwise integer <code>col_last</code> <code>true</code> if the current column is the last column, <code>false</code> otherwise integer <code>row</code> The current row number of the table integer template<pre><code>{% tablerow product in collection.products cols:2 %}\n  {{ product.title }} - {{ tablerowloop.col0 }}\n{% endtablerow %}\n</code></pre> output<pre><code>&lt;table&gt;\n  &lt;tr class=\"row1\"&gt;\n    &lt;td class=\"col1\"&gt;Cool Shirt - 0&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Alien Poster - 1&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr class=\"row2\"&gt;\n    &lt;td class=\"col1\"&gt;Batman Poster - 0&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Bullseye Shirt&lt; - 1/td&gt;&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr class=\"row3\"&gt;\n    &lt;td class=\"col1\"&gt;Another Classic Vinyl - 0&lt;/td&gt;\n    &lt;td class=\"col2\"&gt;Awesome Jeans - 1&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"tag_reference/#unless","title":"unless","text":"<pre><code>{% unless &lt;expression&gt; %}\n  &lt;liquid markup&gt;\n  [ {% elsif &lt;expression&gt; %} &lt;liquid markup&gt; [ {% elsif &lt;expression&gt; %} ... ]]\n  [ {% else %} &lt;liquid markup&gt; ... ]\n{% endif %}\n</code></pre> <p>The <code>unless</code> tag conditionally renders its block if its expression evaluates to be falsy. Any number of elsif blocks can be given to add alternative conditions, and an else block is used as a default if none of preceding conditions were met.</p> <pre><code>{% unless product.title == \"OK Hat\" %}\n  This hat is OK.\n{% elsif product.title == \"Rubbish Tie\" %}\n  This tie is rubbish.\n{% else %}\n  Not sure what this is.\n{% endif %}\n</code></pre> <p>Otherwise <code>unless</code> behaves the same as <code>if</code>. See Conditional expressions.</p>"},{"location":"variables_and_drops/","title":"Variables, types and drops","text":"<p>Liquid primitive types map to Python types according to the following table. You can, for example, compare a Liquid string to a Python string directly with <code>{% if var == \"thing\" %}</code>, where <code>var</code> is a global variable containing a Python string.</p> <p>Note that Liquid has weak typing. Anywhere a particular type is expected, Liquid will implicitly try to convert a value to that type if needed.</p> Primitive type Python type Example Liquid literal BooleanLiteral bool <code>true</code> or <code>false</code> NullLiteral None <code>null</code> or <code>nil</code> IntegerLiteral int <code>123</code> FloatLiteral float <code>1.23</code> StringLiteral str <code>\"Hello\"</code> or <code>'Hello'</code> RangeLiteral <code>(1..5)</code> or <code>(x..y)</code>"},{"location":"variables_and_drops/#sequences-and-mappings","title":"Sequences and mappings","text":"<p>Anywhere an array-like value is expected, like the left-hand side of the <code>join</code> filter, Liquid will accept any Python Sequence, not just a list.</p> <p>In the case of a Mapping, like a dict, a <code>{% for %}</code> loop will iterator over mapping items, whereas a sequence filter will add the mapping to a single element sequence and iterate over that.</p> <pre><code>from collections.abc import Sequence\nfrom liquid import render\n\n\nclass MySequence(Sequence[int]):\n    def __init__(self, items: list[int]):\n        self.items = items\n\n    def __getitem__(self, key: int) -&gt; int:\n        return self.items[key] * 2\n\n    def __len__(self) -&gt; int:\n        return len(self.items)\n\n\ndata = {\n    \"sequences\": [\n        MySequence([1, 2, 3]),\n        [\"a\", \"b\", \"c\"],\n        (True, False),\n        {\"x\": 4, \"y\": 5, \"z\": 6},\n    ]\n}\n\nsource = \"\"\"\\\n{% for sequence in sequences -%}\n    {% for item in sequence %}\n        - {{ item -}}\n    {% endfor %}\n{% endfor %}\n\"\"\"\n\nprint(render(source, **data))\n</code></pre> output<pre><code>        - 2\n        - 4\n        - 6\n\n        - a\n        - b\n        - c\n\n        - true\n        - false\n\n        - ('x', 4)\n        - ('y', 5)\n        - ('z', 6)\n</code></pre>"},{"location":"variables_and_drops/#paths-to-variables","title":"Paths to variables","text":"<p>When referenced in a template, a variable is best viewed as a path to a value, where each path has one or more segments. Segments can be property names separated by dots (<code>foo.bar</code>), array indexes using bracket notation (<code>store.products[1]</code>) or bracketed property names for situations where the property name is held in a variable or contains reserved characters (<code>product.variant[var]</code> or <code>products[\"something with spaces\"]</code>)</p> <p>Python Liquid uses <code>__getitem__</code> internally for resolving property names and accessing items in a sequence. So, if your data is some combination of dictionaries and lists, for example, templates can reference objects as follows.</p> data<pre><code>{\n  \"products\": [\n    {\n      \"title\": \"Some Shoes\",\n      \"available\": 5,\n      \"colors\": [\"blue\", \"red\"]\n    },\n    {\n      \"title\": \"A Hat\",\n      \"available\": 2,\n      \"colors\": [\"grey\", \"brown\"]\n    }\n  ]\n}\n</code></pre> template<pre><code>{{ products[0].title }}\n{{ products[-2]['available'] }}\n{{ products.last.title }}\n{{ products.first.colors | join: ', ' }}\n</code></pre> output<pre><code>Some Shoes\n5\nA Hat\nblue, red\n</code></pre> <p>Attempting to access properties from a Python class or class instance will not work.</p> <pre><code>from liquid import Template\n\nclass Product:\n    def __init__(self, title, colors):\n        self.title = title\n        self.colors = colors\n\nproducts = [\n    Product(title=\"Some Shoes\", colors=[\"blue\", \"red\"]),\n    Product(title=\"A Hat\", colors=[\"grey\", \"brown\"]),\n]\n\nTemplate(\"{{ products.first.title }}!\").render(products=products)\n</code></pre> output<pre><code>!\n</code></pre>"},{"location":"variables_and_drops/#drops","title":"Drops","text":"<p>A drop (as in \"drop of liquid\") is an instance of a Python class that implements the Sequence or Mapping interface, or other magic methods.</p> <p>We use the Mapping interface to force ourselves to be explicit about which properties are exposed to template authors.</p> <pre><code>from collections import abc\nfrom typing import Any\n\nfrom liquid import Environment\nfrom liquid import StrictUndefined\nfrom liquid import render\n\n\nclass User(abc.Mapping[str, Any]):\n    def __init__(\n        self,\n        first_name: str,\n        last_name: str,\n        perms: list[str],\n    ):\n        self.first_name = first_name\n        self.last_name = last_name\n        self.perms = perms or []\n\n        self._keys = [\n            \"first_name\",\n            \"last_name\",\n            \"is_admin\",\n            \"name\",\n        ]\n\n    def __getitem__(self, k):\n        if k in self._keys:\n            return getattr(self, k)\n        raise KeyError(k)\n\n    def __iter__(self):\n        return iter(self._keys)\n\n    def __len__(self):\n        return len(self._keys)\n\n    def __str__(self):\n        return f\"User(first_name='{self.first_name}', last_name='{self.last_name}')\"\n\n    @property\n    def is_admin(self):\n        return \"admin\" in self.perms\n\n    @property\n    def name(self):\n        return f\"{self.first_name} {self.last_name}\"\n\n\nuser = User(\"John\", \"Smith\", [\"admin\"])\n\nprint(render(\"{{ user.first_name }}\", user=user))  # John\nprint(render(\"{{ user.name }}\", user=user))  # John Smith\nprint(render(\"{{ user.is_admin }}\", user=user))  # true\n\n\nstrict_env = Environment(undefined=StrictUndefined)\nprint(strict_env.from_string(\"{{ user.perms[0] }}\").render(user=user))\n# liquid.exceptions.UndefinedError: user.perms is undefined\n#   -&gt; '{{ user.perms[0] }}' 1:3\n#   |\n# 1 | {{ user.perms[0] }}\n#   |    ^^^^ user.perms is undefined\n</code></pre>"},{"location":"variables_and_drops/#drop-wrapper","title":"Drop wrapper","text":"<p>For convenience, you could implement a drop wrapper for data access objects, while still being explicit about which properties to expose.</p> <pre><code>class Drop(abc.Mapping):\n    def __init__(obj, keys):\n        self.obj = obj\n        self.keys = keys\n\n    def __getitem__(self, k):\n        # Delegate attribute access to self.obj only if `k` is in `self.keys`.\n        if k in self.keys:\n            return getattr(obj, k)\n        raise KeyError(k)\n\n    def __iter__(self):\n        return iter(self.keys)\n\n    def __len__(self):\n        return len(self.keys)\n</code></pre>"},{"location":"variables_and_drops/#__liquid__","title":"<code>__liquid__</code>","text":"<p>If a drop implements the special <code>__liquid__()</code> method, Liquid will use the result of calling <code>__liquid__()</code> when resolving a variable path or segment. This is useful for situations where you need your Python object to act as an array index, or to be compared to a primitive data type, for example.</p> <pre><code>from liquid import parse\n\nclass IntDrop:\n    def __init__(self, val: int):\n        self.val = val\n\n    def __int__(self) -&gt; int:\n        return self.val\n\n    def __str__(self) -&gt; str:\n        return \"one\"\n\n    def __liquid__(self) -&gt; int:\n        return self.val\n\n\ntemplate = parse(\n    \"{% if my_drop &lt; 10 %}\"\n    \"{{ my_drop }} \"\n    \"{% endif %}\"\n    \"{{ some_array[my_drop] }}\"\n)\n\ncontext_data = {\n    \"my_drop\": IntDrop(1),\n    \"some_array\": [\"a\", \"b\", \"c\"],\n}\n\nprint(template.render(**context_data))  # one b\n</code></pre>"},{"location":"variables_and_drops/#__html__","title":"<code>__html__</code>","text":"<p>When HTML auto-escaping is enabled, an object can be output as an HTML-safe string by implementing the special <code>__html__()</code> method.</p> <pre><code>from liquid import Environment\n\n\nclass ListDrop:\n    def __init__(self, somelist):\n        self.items = somelist\n\n    def __str__(self):\n        return f\"ListDrop({self.items})\"\n\n    def __html__(self):\n        lis = \"\\n\".join(f\"  &lt;li&gt;{item}&lt;/li&gt;\" for item in self.items)\n        return f\"&lt;ul&gt;\\n{lis}\\n&lt;/ul&gt;\"\n\n\nenv = Environment(auto_escape=True)\ntemplate = env.from_string(r\"{{ products }}\")\nprint(template.render(products=ListDrop([\"Shoe\", \"Hat\", \"Ball\"])))\n</code></pre> output<pre><code>&lt;ul&gt;\n  &lt;li&gt;Shoe&lt;/li&gt;\n  &lt;li&gt;Hat&lt;/li&gt;\n  &lt;li&gt;Ball&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>"},{"location":"variables_and_drops/#__getitem_async__","title":"<code>__getitem_async__</code>","text":"<p>If an instance of a drop that implements <code>__getitem_async__()</code> appears in a <code>render_async()</code> context, <code>__getitem_async__()</code> will be awaited instead of calling <code>__getitem__()</code>.</p> <pre><code>class AsyncCollection(abc.Mapping):\n    def __init__(self, val):\n        self.keys = [\"products\"]\n        self.cached_products = []\n\n    def __len__(self):\n        return 1\n\n    def __iter__(self):\n        return iter(self[\"products\"])\n\n    async def __aiter__(self):\n        # Note that Liquid's built-in `for` loop does not yet support async iteration.\n        return iter(self.__getitem_async__(\"products\"))\n\n    def __getitem__(self, k):\n        if not self.cached_products:\n            # Blocking IO here\n            self.cached_products = get_stuff_from_database()\n        return self.cache_products\n\n    async def __getitem_async__(self, k):\n        if not self.cached_products:\n            # Do async IO here.\n            self.cached_products = await get_stuff_from_database_async()\n        return self.cache_products\n</code></pre>"},{"location":"variables_and_drops/#other-magic-methods","title":"Other magic methods","text":"<p>Other Python magic methods will work with Liquid filters and special properties too.</p> <pre><code>from liquid import Environment\n\nenv = Environment()\n\nclass Foo:\n    def __int__(self):\n        return 7\n\n    def __str__(self):\n        return \"Bar\"\n\n    def __len__(self):\n        return 5\n\n\ntemplate = env.from_string(\n    \"\"\"\\\n{{ foo }}\n{{ foo | plus: 2 }}\n{{ foo.size }}\n\"\"\"\n)\n\nprint(template.render(foo=Foo()))\n</code></pre> output<pre><code>Bar\n9\n5\n</code></pre>"},{"location":"variables_and_drops/#undefined-variables","title":"Undefined variables","text":"<p>At render time, if a variable can not be resolved, and instance of <code>Undefined</code> is used instead. We can customize template rendering behavior by implementing some of Python's \"magic\" methods on a subclass of <code>Undefined</code>.</p>"},{"location":"variables_and_drops/#default-undefined","title":"Default undefined","text":"<p>All operations on the default <code>Undefined</code> type are silently ignored and, when rendered, it produces an empty string. For example, you can access properties and iterate an undefined variable without error.</p> <pre><code>Hello {{ nosuchthing }}\n{% for thing in nosuchthing %}\n    {{ thing }}\n{% endfor %}\n</code></pre> output<pre><code>Hello\n</code></pre>"},{"location":"variables_and_drops/#strict-undefined","title":"Strict undefined","text":"<p>When <code>StrictUndefined</code> is passed as the <code>undefined</code> argument to an <code>Environment</code>, any operation on an undefined variable will raise an <code>UndefinedError</code>.</p> <pre><code>from liquid import Environment, StrictUndefined\n\nenv = Environment(undefined=StrictUndefined)\ntemplate = env.from_string(\"Hello {{ nosuchthing }}\")\ntemplate.render()\n# liquid.exceptions.UndefinedError: 'nosuchthing' is undefined\n#   -&gt; 'Hello {{ nosuchthing }}' 1:9\n#   |\n# 1 | Hello {{ nosuchthing }}\n#   |          ^^^^^^^^^^^ 'nosuchthing' is undefined\n</code></pre>"},{"location":"variables_and_drops/#falsy-strict-undefined","title":"Falsy strict undefined","text":"<p><code>FalsyStrictUndefined</code> is the same as <code>StrictUndefined</code>, but can be tested for truthiness and equality without raising an exception.</p> <pre><code>from liquid import Environment\nfrom liquid import FalsyStrictUndefined\n\nenv = Environment(undefined=FalsyStrictUndefined)\ntemplate = env.from_string(\"{% if nosuchthing %}foo{% else %}bar{% endif %}\")\nprint(template.render())  # bar\n</code></pre>"},{"location":"api/ast/","title":"AST","text":""},{"location":"api/ast/#liquid.Node","title":"liquid.Node","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all nodes in a parse tree.</p>"},{"location":"api/ast/#liquid.Node.blank","title":"blank  <code>instance-attribute</code>","text":"<pre><code>blank = True\n</code></pre> <p>If True, indicates that the node, when rendered, produces no output text or only whitespace.</p> <p>The output node (<code>{{ something }}</code>) and echo tag are exception. Even if they evaluate to an empty or blank string, they are not considered \"blank\".</p>"},{"location":"api/ast/#liquid.Node.block_scope","title":"block_scope","text":"<pre><code>block_scope() -&gt; Iterable[Identifier]\n</code></pre> <p>Return variables this node adds to the node's block scope.</p>"},{"location":"api/ast/#liquid.Node.children","title":"children","text":"<pre><code>children(\n    static_context: RenderContext,\n    *,\n    include_partials: bool = True\n) -&gt; Iterable[Node]\n</code></pre> <p>Return this node's children.</p>"},{"location":"api/ast/#liquid.Node.children_async","title":"children_async  <code>async</code>","text":"<pre><code>children_async(\n    static_context: RenderContext,\n    *,\n    include_partials: bool = True\n) -&gt; Iterable[Node]\n</code></pre> <p>An async version of <code>children()</code>.</p>"},{"location":"api/ast/#liquid.Node.expressions","title":"expressions","text":"<pre><code>expressions() -&gt; Iterable[Expression]\n</code></pre> <p>Return this node's expressions.</p>"},{"location":"api/ast/#liquid.Node.partial_scope","title":"partial_scope","text":"<pre><code>partial_scope() -&gt; Partial | None\n</code></pre> <p>Return information about a partial template loaded by this node.</p>"},{"location":"api/ast/#liquid.Node.raise_for_disabled","title":"raise_for_disabled","text":"<pre><code>raise_for_disabled(disabled_tags: Collection[str]) -&gt; None\n</code></pre> <p>Raise a DisabledTagError if this node's type is in the given list.</p>"},{"location":"api/ast/#liquid.Node.render","title":"render","text":"<pre><code>render(context: RenderContext, buffer: TextIO) -&gt; int\n</code></pre> <p>Check disabled tags before delegating to <code>render_to_output</code>.</p>"},{"location":"api/ast/#liquid.Node.render_async","title":"render_async  <code>async</code>","text":"<pre><code>render_async(context: RenderContext, buffer: TextIO) -&gt; int\n</code></pre> <p>An async version of <code>liquid.ast.Node.render</code>.</p>"},{"location":"api/ast/#liquid.Node.render_to_output","title":"render_to_output  <code>abstractmethod</code>","text":"<pre><code>render_to_output(\n    context: RenderContext, buffer: TextIO\n) -&gt; int\n</code></pre> <p>Render this node to the output buffer.</p>"},{"location":"api/ast/#liquid.Node.render_to_output_async","title":"render_to_output_async  <code>async</code>","text":"<pre><code>render_to_output_async(\n    context: RenderContext, buffer: TextIO\n) -&gt; int\n</code></pre> <p>An async version of <code>liquid.ast.Node.render_to_output</code>.</p>"},{"location":"api/ast/#liquid.Node.template_scope","title":"template_scope","text":"<pre><code>template_scope() -&gt; Iterable[Identifier]\n</code></pre> <p>Return variables this node adds to the template local scope.</p>"},{"location":"api/ast/#liquid.BlockNode","title":"liquid.BlockNode","text":"<p>               Bases: <code>Node</code></p> <p>A parse tree node representing a sequence of statements.</p>"},{"location":"api/ast/#liquid.BlockNode.children","title":"children","text":"<pre><code>children(\n    static_context: RenderContext,\n    *,\n    include_partials: bool = True\n) -&gt; Iterable[Node]\n</code></pre> <p>Return this node's children.</p>"},{"location":"api/ast/#liquid.BlockNode.render_to_output","title":"render_to_output","text":"<pre><code>render_to_output(\n    context: RenderContext, buffer: TextIO\n) -&gt; int\n</code></pre> <p>Render the node to the output buffer.</p>"},{"location":"api/ast/#liquid.BlockNode.render_to_output_async","title":"render_to_output_async  <code>async</code>","text":"<pre><code>render_to_output_async(\n    context: RenderContext, buffer: TextIO\n) -&gt; int\n</code></pre> <p>Render the node to the output buffer.</p>"},{"location":"api/ast/#liquid.ConditionalBlockNode","title":"liquid.ConditionalBlockNode","text":"<p>               Bases: <code>Node</code></p> <p>A node containing a sequence of statements and a conditional expression.</p>"},{"location":"api/ast/#liquid.ConditionalBlockNode.children","title":"children","text":"<pre><code>children(\n    static_context: RenderContext,\n    *,\n    include_partials: bool = True\n) -&gt; Iterable[Node]\n</code></pre> <p>Return this node's children.</p>"},{"location":"api/ast/#liquid.ConditionalBlockNode.expressions","title":"expressions","text":"<pre><code>expressions() -&gt; Iterable[Expression]\n</code></pre> <p>Return this node's expressions.</p>"},{"location":"api/ast/#liquid.ConditionalBlockNode.render_to_output","title":"render_to_output","text":"<pre><code>render_to_output(\n    context: RenderContext, buffer: TextIO\n) -&gt; int\n</code></pre> <p>Render the node to the output buffer.</p>"},{"location":"api/ast/#liquid.ConditionalBlockNode.render_to_output_async","title":"render_to_output_async  <code>async</code>","text":"<pre><code>render_to_output_async(\n    context: RenderContext, buffer: TextIO\n) -&gt; int\n</code></pre> <p>Render the node to the output buffer.</p>"},{"location":"api/ast/#liquid.ast.Partial","title":"liquid.ast.Partial","text":"<p>Partial template meta data.</p> PARAMETER DESCRIPTION <code>name</code> <p>An expression resolving to the name associated with the partial template.</p> <p> TYPE: <code>Expression</code> </p> <code>scope</code> <p>The kind of scope the partial template should have when loaded.</p> <p> TYPE: <code>PartialScope</code> </p> <code>in_scope</code> <p>Names that will be added to the partial template scope.</p> <p> TYPE: <code>Iterable[Identifier]</code> </p>"},{"location":"api/ast/#liquid.ast.PartialScope","title":"liquid.ast.PartialScope","text":"<p>               Bases: <code>Enum</code></p> <p>The kind of scope a partial template should have when loaded.</p>"},{"location":"api/builtin/","title":"Builtin","text":""},{"location":"api/builtin/#liquid.builtin.register","title":"liquid.builtin.register","text":"<pre><code>register(env: Environment) -&gt; None\n</code></pre> <p>Register all built-in tags and filters with an environment.</p>"},{"location":"api/convenience/","title":"Convenience functions","text":""},{"location":"api/convenience/#liquid.parse","title":"liquid.parse","text":"<pre><code>parse(source: str) -&gt; BoundTemplate\n</code></pre> <p>Parse template source text using the default environment.</p>"},{"location":"api/convenience/#liquid.render","title":"liquid.render","text":"<pre><code>render(source: str, **data: object) -&gt; str\n</code></pre> <p>Parse and render source text using the default environment.</p>"},{"location":"api/convenience/#liquid.render_async","title":"liquid.render_async  <code>async</code>","text":"<pre><code>render_async(source: str, **data: object) -&gt; str\n</code></pre> <p>Parse and render source text using the default environment.</p>"},{"location":"api/convenience/#liquid.extract_liquid","title":"liquid.extract_liquid","text":"<pre><code>extract_liquid(\n    fileobj: TextIO,\n    keywords: list[str],\n    comment_tags: Optional[list[str]] = None,\n    options: Optional[dict[object, object]] = None,\n) -&gt; Iterator[MessageTuple]\n</code></pre> <p>A babel compatible translation message extraction method for Liquid templates.</p> <p>See https://babel.pocoo.org/en/latest/messages.html</p> <p>Keywords are the names of Liquid filters or tags operating on translatable strings. For a filter to contribute to message extraction, it must also appear as a child of a <code>FilteredExpression</code> and be a <code>TranslatableFilter</code>. Similarly, tags must produce a node that is a <code>TranslatableTag</code>.</p> <p>Where a Liquid comment contains a prefix in <code>comment_tags</code>, the comment will be attached to the translatable filter or tag immediately following the comment. Python Liquid's non-standard shorthand comments are not supported.</p> <p>Options are arguments passed to the <code>liquid.Template</code> constructor with the contents of <code>fileobj</code> as the template's source. Use <code>extract_from_template</code> to extract messages from an existing template bound to an existing environment.</p>"},{"location":"api/environment/","title":"Environment","text":""},{"location":"api/environment/#liquid.Environment","title":"liquid.Environment","text":"<p>Shared configuration from which templates can be loaded and parsed.</p> <p>An <code>Environment</code> is where you might register custom tags and filters, or store global context variables that should be included with every template.</p> PARAMETER DESCRIPTION <code>extra</code> <p>If <code>True</code>, register all extra tags and filters. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tag_start_string</code> <p>The sequence of characters indicating the start of a liquid tag.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{%'</code> </p> <code>tag_end_string</code> <p>The sequence of characters indicating the end of a liquid tag.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'%}'</code> </p> <code>statement_start_string</code> <p>The sequence of characters indicating the start of an output statement.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{{'</code> </p> <code>statement_end_string</code> <p>The sequence of characters indicating the end of an output statement.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'}}'</code> </p> <code>template_comments</code> <p>If <code>True</code>, enable template comments, where, by default, anything between <code>{#</code> and <code>#}</code> is considered a comment.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>comment_start_string</code> <p>The sequence of characters indicating the start of a comment. <code>template_comments</code> must be <code>True</code> for <code>comment_start_string</code> to have any effect.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{#'</code> </p> <code>comment_end_string</code> <p>The sequence of characters indicating the end of a comment.  <code>template_comments</code> must be <code>True</code> for <code>comment_end_string</code> to have any effect.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'#}'</code> </p> <code>tolerance</code> <p>Indicates how tolerant to be of errors. Must be one of <code>Mode.LAX</code>, <code>Mode.WARN</code> or <code>Mode.STRICT</code>.</p> <p> TYPE: <code>Mode</code> DEFAULT: <code>STRICT</code> </p> <code>loader</code> <p>A template loader. If you want to use the builtin \"render\" or \"include\" tags, a loader must be configured.</p> <p> TYPE: <code>Optional[BaseLoader]</code> DEFAULT: <code>None</code> </p> <code>undefined</code> <p>A subclass of <code>Undefined</code> that represents undefined values. Could be one of the built-in undefined types, <code>Undefined</code>, <code>DebugUndefined</code> or <code>StrictUndefined</code>.</p> <p> TYPE: <code>Type[Undefined]</code> DEFAULT: <code>Undefined</code> </p> <code>strict_filters</code> <p>If <code>True</code>, will raise an exception upon finding an undefined filter. Otherwise undefined filters are silently ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>autoescape</code> <p>If <code>True</code>, all render context values will be HTML-escaped before output unless they've been explicitly marked as \"safe\".</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>globals</code> <p>An optional mapping that will be added to the render context of any template loaded from this environment.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/environment/#liquid.Environment.context_depth_limit","title":"context_depth_limit  <code>class-attribute</code>","text":"<pre><code>context_depth_limit: int = 30\n</code></pre> <p>The maximum number of times a render context can be extended or wrapped before raising a <code>ContextDepthError</code>.</p>"},{"location":"api/environment/#liquid.Environment.filters","title":"filters  <code>instance-attribute</code>","text":"<pre><code>filters: dict[str, Callable[..., Any]] = {}\n</code></pre> <p>The environment's filter register, mapping filter names to callables.</p>"},{"location":"api/environment/#liquid.Environment.keyword_assignment","title":"keyword_assignment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keyword_assignment: bool = False\n</code></pre> <p>When <code>True</code> accept <code>=</code> or <code>:</code> as the separator token between argument names and argument values. By default only <code>:</code> is allowed.</p>"},{"location":"api/environment/#liquid.Environment.local_namespace_limit","title":"local_namespace_limit  <code>class-attribute</code>","text":"<pre><code>local_namespace_limit: Optional[int] = None\n</code></pre> <p>The maximum number of bytes (according to <code>sys.getsizeof</code>) allowed in a template's local namespace before a LocalNamespaceLimitError is raised. We only count the size of the namespaces values, not the size of keys/names.</p>"},{"location":"api/environment/#liquid.Environment.logical_not_operator","title":"logical_not_operator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logical_not_operator: bool = False\n</code></pre> <p>When <code>True</code>, allow the use of the logical <code>not</code> operator in logical expressions. Defaults to <code>False</code>.</p>"},{"location":"api/environment/#liquid.Environment.logical_parentheses","title":"logical_parentheses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logical_parentheses: bool = False\n</code></pre> <p>When <code>True</code>, allow the use of parentheses in logical expressions to group terms. Defaults to <code>False.</code></p>"},{"location":"api/environment/#liquid.Environment.loop_iteration_limit","title":"loop_iteration_limit  <code>class-attribute</code>","text":"<pre><code>loop_iteration_limit: Optional[int] = None\n</code></pre> <p>The maximum number of loop iterations allowed before a LoopIterationLimitError is raised.</p>"},{"location":"api/environment/#liquid.Environment.output_stream_limit","title":"output_stream_limit  <code>class-attribute</code>","text":"<pre><code>output_stream_limit: Optional[int] = None\n</code></pre> <p>The maximum number of bytes that can be written to a template's output stream before raising an OutputStreamLimitError.</p>"},{"location":"api/environment/#liquid.Environment.shorthand_indexes","title":"shorthand_indexes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shorthand_indexes: bool = False\n</code></pre> <p>When <code>True</code>, accept indexes without enclosing square brackets in paths to variables. Defaults to <code>False</code>.</p>"},{"location":"api/environment/#liquid.Environment.string_first_and_last","title":"string_first_and_last  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>string_first_and_last: bool = False\n</code></pre> <p>When <code>True</code>, the special <code>first</code> and <code>last</code> properties will return the first and last charters of a string. Otherwise <code>first</code> and <code>last</code> will resolve to Undefined when applied to a string. Defaults to <code>False</code>.</p>"},{"location":"api/environment/#liquid.Environment.string_sequences","title":"string_sequences  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>string_sequences: bool = False\n</code></pre> <p>When <code>True</code>, strings are treated as sequences. That is, characters (Unicode code points) in a string can be looped over and selected by index. Defaults to <code>False</code>.</p>"},{"location":"api/environment/#liquid.Environment.suppress_blank_control_flow_blocks","title":"suppress_blank_control_flow_blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress_blank_control_flow_blocks: bool = True\n</code></pre> <p>When <code>True</code>, don't render control flow blocks that contain only whitespace.</p>"},{"location":"api/environment/#liquid.Environment.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags: dict[str, Tag] = {}\n</code></pre> <p>The environment's tag register, mapping tag names to instances of <code>Tag</code>.</p>"},{"location":"api/environment/#liquid.Environment.template_class","title":"template_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_class: Type[BoundTemplate] = BoundTemplate\n</code></pre> <p>Instances of <code>template_class</code> are returned from <code>from_string</code>, <code>get_template</code> and <code>get_template_async</code>. It should be the <code>BoundTemplate</code> class or a subclass of it.</p>"},{"location":"api/environment/#liquid.Environment.ternary_expressions","title":"ternary_expressions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ternary_expressions: bool = False\n</code></pre> <p>When <code>True</code>, allow the use of ternary expression in output statements, assign tags and echo tags. Defaults to <code>False</code>.</p>"},{"location":"api/environment/#liquid.Environment.add_filter","title":"add_filter","text":"<pre><code>add_filter(name: str, func: Callable[..., Any]) -&gt; None\n</code></pre> <p>Register a filter function with the environment.</p> PARAMETER DESCRIPTION <code>name</code> <p>The filter's name. Does not need to match the function name. This is what you'll use to apply the filter to an expression in a liquid template.</p> <p> TYPE: <code>str</code> </p> <code>func</code> <p>Any callable that accepts at least one argument, the result of the expression the filter is applied to. If the filter needs access to the active environment or render context, use <code>liquid.filer.with_context</code> and/or <code>liquid.filter.with_environment</code> decorators.</p> <p> TYPE: <code>Callable[..., Any]</code> </p>"},{"location":"api/environment/#liquid.Environment.add_tag","title":"add_tag","text":"<pre><code>add_tag(tag: Type[Tag]) -&gt; None\n</code></pre> <p>Register a liquid tag with the environment.</p> <p>Built-in tags are registered for you automatically with every new <code>Environment</code>.</p> PARAMETER DESCRIPTION <code>tag</code> <p>The tag to register.</p> <p> TYPE: <code>Type[Tag]</code> </p>"},{"location":"api/environment/#liquid.Environment.analyze_tags","title":"analyze_tags","text":"<pre><code>analyze_tags(\n    name: str,\n    *,\n    context: Optional[\"RenderContext\"] = None,\n    inner_tags: Optional[InnerTagMap] = None,\n    **kwargs: str\n) -&gt; TagAnalysis\n</code></pre> <p>Audit template tags without parsing source text into an abstract syntax tree.</p> <p>This is useful for identifying unknown, misplaced and unbalanced tags in a template's source text. See also <code>liquid.template.BoundTemplate.analyze</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The template's name or identifier, as you would use with <code>Environment.get_template</code>. Use <code>Environment.analyze_tags_from_string</code> to audit tags in template text without using a template loader.</p> <p> TYPE: <code>str</code> </p> <code>context</code> <p>An optional render context the loader might use to modify the template search space. If given, uses <code>liquid.loaders.BaseLoader.get_source_with_context</code> from the current loader.</p> <p> TYPE: <code>Optional['RenderContext']</code> DEFAULT: <code>None</code> </p> <code>inner_tags</code> <p>A mapping of block tags to a list of allowed \"inner\" tags for the block. For example, <code>{% if %}</code> blocks are allowed to contain <code>{% elsif %}</code> and <code>{% else %}</code> tags.</p> <p> TYPE: <code>Optional[InnerTagMap]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Loader context.</p> <p> TYPE: <code>str</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/environment/#liquid.Environment.analyze_tags_async","title":"analyze_tags_async  <code>async</code>","text":"<pre><code>analyze_tags_async(\n    name: str,\n    *,\n    context: Optional[\"RenderContext\"] = None,\n    inner_tags: Optional[InnerTagMap] = None,\n    **kwargs: str\n) -&gt; TagAnalysis\n</code></pre> <p>An async version of <code>Environment.analyze_tags</code>.</p>"},{"location":"api/environment/#liquid.Environment.analyze_tags_from_string","title":"analyze_tags_from_string","text":"<pre><code>analyze_tags_from_string(\n    source: str,\n    name: str = \"&lt;string&gt;\",\n    *,\n    inner_tags: Optional[InnerTagMap] = None\n) -&gt; TagAnalysis\n</code></pre> <p>Analyze tags in template source text.</p> <p>Unlike template static or contextual analysis, a tag audit does not parse the template source text into an AST, nor does it attempt to load partial templates from <code>{% include %}</code> or <code>{% render %}</code> tags.</p> PARAMETER DESCRIPTION <code>source</code> <p>The source text of the template.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>A name or identifier for the template.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'&lt;string&gt;'</code> </p> <code>inner_tags</code> <p>A mapping of block tags to a list of allowed \"inner\" tags for the block. For example, <code>{% if %}</code> blocks are allowed to contain <code>{% elsif %}</code> and <code>{% else %}</code> tags.</p> <p> TYPE: <code>Optional[InnerTagMap]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/environment/#liquid.Environment.error","title":"error","text":"<pre><code>error(\n    exc: Union[Type[LiquidError], LiquidError],\n    msg: Optional[str] = None,\n    token: Optional[Token] = None,\n) -&gt; None\n</code></pre> <p>Raise, warn or ignore the given exception according to the current mode.</p>"},{"location":"api/environment/#liquid.Environment.from_string","title":"from_string","text":"<pre><code>from_string(\n    source: str,\n    name: str = \"\",\n    path: Optional[Union[str, Path]] = None,\n    globals: Optional[Mapping[str, object]] = None,\n    matter: Optional[Mapping[str, object]] = None,\n) -&gt; BoundTemplate\n</code></pre> <p>Parse the given string as a liquid template.</p> PARAMETER DESCRIPTION <code>source</code> <p>The liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Optional name of the template. Available as <code>Template.name</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>path</code> <p>Optional path or identifier to the origin of the template.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>globals</code> <p>An optional mapping of render context variables attached to the resulting template.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>matter</code> <p>Optional mapping of render context variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/environment/#liquid.Environment.get_template","title":"get_template","text":"<pre><code>get_template(\n    name: str,\n    *,\n    globals: Mapping[str, object] | None = None,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>Load and parse a template using the configured loader.</p> PARAMETER DESCRIPTION <code>name</code> <p>The template's name. The loader is responsible for interpreting the name. It could be the name of a file or some other identifier.</p> <p> TYPE: <code>str</code> </p> <code>globals</code> <p>A mapping of render context variables attached to the resulting template.</p> <p> TYPE: <code>Mapping[str, object] | None</code> DEFAULT: <code>None</code> </p> <code>context</code> <p>An optional render context that can be used to narrow the template source search space.</p> <p> TYPE: <code>RenderContext | None</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Arbitrary arguments that can be used to narrow the template source search space.</p> <p> TYPE: <code>object</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>TemplateNotFound</code> <p>If a template with the given name can not be found.</p>"},{"location":"api/environment/#liquid.Environment.get_template_async","title":"get_template_async  <code>async</code>","text":"<pre><code>get_template_async(\n    name: str,\n    *,\n    globals: Mapping[str, object] | None = None,\n    context: RenderContext | None = None,\n    **kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>get_template()</code>.</p>"},{"location":"api/environment/#liquid.Environment.make_globals","title":"make_globals","text":"<pre><code>make_globals(\n    globals: Optional[Mapping[str, object]] = None,\n) -&gt; dict[str, object]\n</code></pre> <p>Combine environment globals with template globals.</p>"},{"location":"api/environment/#liquid.Environment.parse","title":"parse","text":"<pre><code>parse(\n    source: str,\n    name: str = \"\",\n    path: Optional[Union[str, Path]] = None,\n    globals: Optional[Mapping[str, object]] = None,\n    matter: Optional[Mapping[str, object]] = None,\n) -&gt; BoundTemplate\n</code></pre> <p>Parse the given string as a liquid template.</p> PARAMETER DESCRIPTION <code>source</code> <p>The liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Optional name of the template. Available as <code>Template.name</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>path</code> <p>Optional path or identifier to the origin of the template.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>globals</code> <p>An optional mapping of render context variables attached to the resulting template.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>matter</code> <p>Optional mapping of render context variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/environment/#liquid.Environment.render","title":"render","text":"<pre><code>render(source: str, **data: object) -&gt; str\n</code></pre> <p>Parse and render source text.</p>"},{"location":"api/environment/#liquid.Environment.render_async","title":"render_async  <code>async</code>","text":"<pre><code>render_async(source: str, **data: object) -&gt; str\n</code></pre> <p>Parse and render source text.</p>"},{"location":"api/environment/#liquid.Environment.setup_tags_and_filters","title":"setup_tags_and_filters","text":"<pre><code>setup_tags_and_filters(*, extra: bool = False) -&gt; None\n</code></pre> <p>Add default tags and filters to this environment.</p> <p>If extra is <code>True</code>, register all extra, non-standard tags and filters too.</p>"},{"location":"api/environment/#liquid.Environment.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer() -&gt; Callable[[str], Iterator[Token]]\n</code></pre> <p>Return a tokenizer for this environment.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#liquid.exceptions.LiquidError","title":"liquid.exceptions.LiquidError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all Liquid exceptions.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidError.message","title":"message  <code>property</code>","text":"<pre><code>message: object\n</code></pre> <p>The exception's error message if one was given.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidError.context","title":"context","text":"<pre><code>context() -&gt; Optional[tuple[int, int, str, str, str]]\n</code></pre> <p>Return context information for this error.</p> <p>Returns (line, col, previous line, current line, next line) or None if no context information is available.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidError.detailed_message","title":"detailed_message","text":"<pre><code>detailed_message() -&gt; str\n</code></pre> <p>Return an error message formatted with extra context info.</p>"},{"location":"api/exceptions/#liquid.exceptions.BreakLoop","title":"liquid.exceptions.BreakLoop","text":"<p>               Bases: <code>LiquidInterrupt</code></p> <p>Exception raised when a BreakNode is rendered.</p>"},{"location":"api/exceptions/#liquid.exceptions.ContextDepthError","title":"liquid.exceptions.ContextDepthError","text":"<p>               Bases: <code>ResourceLimitError</code></p> <p>Exception raised when the maximum context depth is reached.</p> <p>Usually indicates recursive use of <code>render</code> or <code>include</code> tags.</p>"},{"location":"api/exceptions/#liquid.exceptions.ContinueLoop","title":"liquid.exceptions.ContinueLoop","text":"<p>               Bases: <code>LiquidInterrupt</code></p> <p>Exception raised when a ContinueNode is rendered.</p>"},{"location":"api/exceptions/#liquid.exceptions.DisabledTagError","title":"liquid.exceptions.DisabledTagError","text":"<p>               Bases: <code>LiquidError</code></p> <p>Exception raised when an attempt is made to render a disabled tag.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidEnvironmentError","title":"liquid.exceptions.LiquidEnvironmentError","text":"<p>               Bases: <code>LiquidError</code></p> <p>An exception raised due to a misconfigured environment.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidInterrupt","title":"liquid.exceptions.LiquidInterrupt","text":"<p>               Bases: <code>Exception</code></p> <p>Loop interrupt exception.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidSyntaxError","title":"liquid.exceptions.LiquidSyntaxError","text":"<p>               Bases: <code>LiquidError</code></p> <p>Exception raised when there is a parser error.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidTypeError","title":"liquid.exceptions.LiquidTypeError","text":"<p>               Bases: <code>LiquidError</code></p> <p>Exception raised when an error occurs at render time.</p>"},{"location":"api/exceptions/#liquid.exceptions.LiquidValueError","title":"liquid.exceptions.LiquidValueError","text":"<p>               Bases: <code>LiquidSyntaxError</code></p> <p>Exception raised when a cast from str to int exceeds the length limit.</p>"},{"location":"api/exceptions/#liquid.exceptions.LocalNamespaceLimitError","title":"liquid.exceptions.LocalNamespaceLimitError","text":"<p>               Bases: <code>ResourceLimitError</code></p> <p>Exception raised when a local namespace limit has been exceeded.</p>"},{"location":"api/exceptions/#liquid.exceptions.LoopIterationLimitError","title":"liquid.exceptions.LoopIterationLimitError","text":"<p>               Bases: <code>ResourceLimitError</code></p> <p>Exception raised when the loop iteration limit has been exceeded.</p>"},{"location":"api/exceptions/#liquid.exceptions.OutputStreamLimitError","title":"liquid.exceptions.OutputStreamLimitError","text":"<p>               Bases: <code>ResourceLimitError</code></p> <p>Exception raised when an output stream limit has been exceeded.</p>"},{"location":"api/exceptions/#liquid.exceptions.RequiredBlockError","title":"liquid.exceptions.RequiredBlockError","text":"<p>               Bases: <code>TemplateInheritanceError</code></p> <p>An exception raised when a required block has not been overridden.</p>"},{"location":"api/exceptions/#liquid.exceptions.ResourceLimitError","title":"liquid.exceptions.ResourceLimitError","text":"<p>               Bases: <code>LiquidError</code></p> <p>Base class for exceptions relating to resource limits.</p>"},{"location":"api/exceptions/#liquid.exceptions.StopRender","title":"liquid.exceptions.StopRender","text":"<p>               Bases: <code>Exception</code></p> <p>Template inheritance interrupt.</p> <p>An interrupt used to signal that <code>BoundTemplate.render_with_context</code> should stop rendering more nodes. This is used by template inheritance tags and is not an error condition.</p>"},{"location":"api/exceptions/#liquid.exceptions.TemplateInheritanceError","title":"liquid.exceptions.TemplateInheritanceError","text":"<p>               Bases: <code>LiquidError</code></p> <p>An exceptions raised when template inheritance tags are used incorrectly.</p> <p>This could occur when parsing a template or at render time.</p>"},{"location":"api/exceptions/#liquid.exceptions.TemplateNotFoundError","title":"liquid.exceptions.TemplateNotFoundError","text":"<p>               Bases: <code>LiquidError</code></p> <p>Exception raised when a template could not be found.</p>"},{"location":"api/exceptions/#liquid.exceptions.UndefinedError","title":"liquid.exceptions.UndefinedError","text":"<p>               Bases: <code>LiquidError</code></p> <p>Exception raised by the StrictUndefined type.</p>"},{"location":"api/exceptions/#liquid.exceptions.UnknownFilterError","title":"liquid.exceptions.UnknownFilterError","text":"<p>               Bases: <code>LiquidError</code></p> <p>Exception raised when a filter lookup fails.</p>"},{"location":"api/expression/","title":"Expression","text":""},{"location":"api/expression/#liquid.expression.Expression","title":"liquid.expression.Expression","text":"<p>               Bases: <code>ABC</code></p> <p>The base class for all built-in expressions.</p>"},{"location":"api/expression/#liquid.expression.Expression.children","title":"children  <code>abstractmethod</code>","text":"<pre><code>children() -&gt; Iterable[Expression]\n</code></pre> <p>Return this expression's child expressions.</p>"},{"location":"api/expression/#liquid.expression.Expression.evaluate","title":"evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate(context: RenderContext) -&gt; object\n</code></pre> <p>Evaluate this expression an return the result.</p>"},{"location":"api/expression/#liquid.expression.Expression.evaluate_async","title":"evaluate_async  <code>async</code>","text":"<pre><code>evaluate_async(context: RenderContext) -&gt; object\n</code></pre> <p>Evaluate this expression asynchronously.</p>"},{"location":"api/expression/#liquid.expression.Expression.scope","title":"scope","text":"<pre><code>scope() -&gt; Iterable[Identifier]\n</code></pre> <p>Return variables this expression adds the scope of any child expressions.</p> <p>Used by lambda expressions only.</p>"},{"location":"api/extra/","title":"Extra","text":""},{"location":"api/extra/#liquid.extra.BaseTranslateFilter","title":"liquid.extra.BaseTranslateFilter","text":"<p>Base class for the default translation filters.</p> PARAMETER DESCRIPTION <code>translations_var</code> <p>The name of a render context variable that resolves to a gettext <code>Translations</code> class. Defaults to <code>\"translations\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'translations'</code> </p> <code>default_translations</code> <p>A fallback translations class to use if <code>translations_var</code> can not be resolves. Defaults to <code>NullTranslations</code>.</p> <p> TYPE: <code>Optional[Translations]</code> DEFAULT: <code>None</code> </p> <code>message_interpolation</code> <p>If <code>True</code> (default), perform printf-style string interpolation on the translated message, using keyword arguments passed to the filter function.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>autoescape_message</code> <p>If <code>True</code> and the current environment has <code>autoescape</code> set to <code>True</code>, the filter's left value will be escaped before translation. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/extra/#liquid.extra.BaseTranslateFilter.format_message","title":"format_message","text":"<pre><code>format_message(\n    context: RenderContext,\n    message_text: str,\n    message_vars: dict[str, Any],\n) -&gt; str\n</code></pre> <p>Return the message string formatted with the given message variables.</p>"},{"location":"api/extra/#liquid.extra.Currency","title":"liquid.extra.Currency","text":"<p>A Liquid filter for formatting currency values.</p> PARAMETER DESCRIPTION <code>currency_code_var</code> <p>The name of a render context variable that resolves to the current currency code. Defaults to <code>\"currency_code\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'currency_code'</code> </p> <code>default_currency_code</code> <p>A fallback currency code if <code>currency_code_var</code> can not be resolved. Defaults to <code>\"USD\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'USD'</code> </p> <code>locale_var</code> <p>The name of a render context variable that resolves to the current locale. Defaults to <code>\"locale\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'locale'</code> </p> <code>default_locale</code> <p>A fallback locale to use if <code>locale_var</code> can not be resolved. Defaults to <code>\"en_US\"</code>.</p> <p> DEFAULT: <code>'en_US'</code> </p> <code>format_var</code> <p>The name of a render context variable that resolves to the current currency format string. Defaults to <code>\"currency_format\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'currency_format'</code> </p> <code>default_format</code> <p>A fallback currency format that is used if <code>format_var</code> can not be resolved. Defaults to <code>None</code>, which means the standard format for the current locale will be used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>currency_digits</code> <p>Indicates if the format should override locale specific trailing digit behavior. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>input_locale_var</code> <p>The name of a render context variable that resolves to a locale suitable for parsing input strings to decimals. Defaults to <code>\"input_locale\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'input_locale'</code> </p> <code>default_input_locale</code> <p>A fallback locale to use if <code>input_locale_var</code> can not be resolved. Defaults to <code>\"en_US\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'en_US'</code> </p>"},{"location":"api/extra/#liquid.extra.Currency.__call__","title":"__call__","text":"<pre><code>__call__(\n    left: object,\n    *,\n    context: RenderContext,\n    group_separator: bool = True\n) -&gt; str\n</code></pre> <p>Apply the filter and return the result.</p>"},{"location":"api/extra/#liquid.extra.DateTime","title":"liquid.extra.DateTime","text":"<p>A Liquid filter for formatting datetime objects.</p> PARAMETER DESCRIPTION <code>timezone_var</code> <p>The name of a render context variable that resolves to a timezone. Defaults to <code>\"timezone\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'timezone'</code> </p> <code>default_timezone</code> <p>A fallback timezone to use if <code>timezone_var</code> can not be resolved. Defaults to <code>\"UTC\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'UTC'</code> </p> <code>locale_var</code> <p>The name of a render context variable that resolves to the current locale. Defaults to <code>\"locale\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'locale'</code> </p> <code>default_locale</code> <p>A fallback locale to use if <code>locale_var</code> can not be resolved. Defaults to <code>\"en_US\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'en_US'</code> </p> <code>format_var</code> <p>The name of a render context variable that resolves to the current datetime format string. Defaults to <code>\"datetime_format\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'datetime_format'</code> </p> <code>default_format</code> <p>A fallback datetime format that is used if <code>format_var</code> can not be resolved. Defaults to <code>\"medium\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'medium'</code> </p> <code>input_timezone_var</code> <p>The name of a render context variable that resolves to a timezone for parsing datetimes entered as strings. Defaults to <code>\"input_timezone\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'input_timezone'</code> </p> <code>default_input_timezone</code> <p>A fallback timezone to use if <code>input_timezone_var</code> can not be resolved. Defaults to <code>\"UTC\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'UTC'</code> </p>"},{"location":"api/extra/#liquid.extra.DateTime.__call__","title":"__call__","text":"<pre><code>__call__(\n    left: object,\n    *,\n    context: RenderContext,\n    format: Optional[str] = None\n) -&gt; str\n</code></pre> <p>Apply the filter and return the result.</p>"},{"location":"api/extra/#liquid.extra.GetText","title":"liquid.extra.GetText","text":"<p>               Bases: <code>BaseTranslateFilter</code>, <code>TranslatableFilter</code></p> <p>A Liquid filter equivalent of <code>gettext.gettext</code>.</p>"},{"location":"api/extra/#liquid.extra.JSON","title":"liquid.extra.JSON","text":"<p>Serialize an object to a JSON formatted string.</p> PARAMETER DESCRIPTION <code>default</code> <p>A function passed to <code>json.dumps</code>. This function is called in the event that the JSONEncoder does not know how to serialize an object. Defaults to <code>None</code>.</p> <p> TYPE: <code>Optional[Callable[[Any], Any]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/extra/#liquid.extra.NGetText","title":"liquid.extra.NGetText","text":"<p>               Bases: <code>BaseTranslateFilter</code>, <code>TranslatableFilter</code></p> <p>A Liquid filter equivalent of <code>gettext.ngettext</code>.</p>"},{"location":"api/extra/#liquid.extra.NGetText.__call__","title":"__call__","text":"<pre><code>__call__(\n    __left: object,\n    __plural: str,\n    __count: object,\n    *,\n    context: RenderContext,\n    **kwargs: Any\n) -&gt; str\n</code></pre> <p>Apply the filter and return the result.</p>"},{"location":"api/extra/#liquid.extra.NPGetText","title":"liquid.extra.NPGetText","text":"<p>               Bases: <code>BaseTranslateFilter</code>, <code>TranslatableFilter</code></p> <p>A Liquid filter equivalent of <code>gettext.npgettext</code>.</p>"},{"location":"api/extra/#liquid.extra.Number","title":"liquid.extra.Number","text":"<p>A Liquid filter for formatting decimal values.</p> PARAMETER DESCRIPTION <code>decimal_quantization_var</code> <p>The name of a render context variable that resolves to the decimal quantization to be used. Defaults to <code>\"decimal_quantization\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'decimal_quantization'</code> </p> <code>default_decimal_quantization</code> <p>A fallback decimal quantization if <code>decimal_quantization_var</code> can not be resolved. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>locale_var</code> <p>The name of a render context variable that resolves to the current locale. Defaults to <code>\"locale\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'locale'</code> </p> <code>default_locale</code> <p>A fallback locale to use if <code>locale_var</code> can not be resolved. Defaults to <code>\"en_US\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'en_US'</code> </p> <code>format_var</code> <p>The name of a render context variable that resolves to the current decimal format string. Defaults to <code>\"decimal_format\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'decimal_format'</code> </p> <code>default_format</code> <p>A fallback decimal format that is used if <code>format_var</code> can not be resolved. Defaults to <code>None</code>, which means the standard format for the current locale will be used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>input_locale_var</code> <p>The name of a render context variable that resolves to a locale suitable for parsing input strings to decimals. Defaults to <code>\"input_locale\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'input_locale'</code> </p> <code>default_input_locale</code> <p>A fallback locale to use if <code>input_locale_var</code> can not be resolved. Defaults to <code>\"en_US\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'en_US'</code> </p>"},{"location":"api/extra/#liquid.extra.Number.__call__","title":"__call__","text":"<pre><code>__call__(\n    left: object,\n    *,\n    context: RenderContext,\n    group_separator: bool = True\n) -&gt; str\n</code></pre> <p>Apply the filter and return the result.</p>"},{"location":"api/extra/#liquid.extra.PGetText","title":"liquid.extra.PGetText","text":"<p>               Bases: <code>BaseTranslateFilter</code>, <code>TranslatableFilter</code></p> <p>A Liquid filter equivalent of <code>gettext.pgettext</code>.</p>"},{"location":"api/extra/#liquid.extra.Translate","title":"liquid.extra.Translate","text":"<p>               Bases: <code>BaseTranslateFilter</code>, <code>TranslatableFilter</code></p> <p>A Liquid filter for translating strings to other languages.</p> <p>Depending on the keyword arguments provided when the resulting filter is called, it could behave like gettext, ngettext, pgettext or npgettext.</p>"},{"location":"api/extra/#liquid.extra.Translate.__call__","title":"__call__","text":"<pre><code>__call__(\n    __left: object,\n    __message_context: object = None,\n    *,\n    context: RenderContext,\n    **kwargs: Any\n) -&gt; str\n</code></pre> <p>Apply the filter and return the result.</p>"},{"location":"api/extra/#liquid.extra.TranslateTag","title":"liquid.extra.TranslateTag","text":"<p>               Bases: <code>Tag</code></p> <p>The built-in \"translate\" tag.</p>"},{"location":"api/extra/#liquid.extra.TranslateTag.parse","title":"parse","text":"<pre><code>parse(stream: TokenStream) -&gt; TranslateNode\n</code></pre> <p>Parse tokens from stream into an AST node.</p>"},{"location":"api/extra/#liquid.extra.TranslateTag.validate_message_block","title":"validate_message_block","text":"<pre><code>validate_message_block(\n    block: Optional[BlockNode],\n) -&gt; Optional[MessageBlock]\n</code></pre> <p>Check that a translation message block does not contain disallowed markup.</p>"},{"location":"api/extra/#liquid.extra.Unit","title":"liquid.extra.Unit","text":"<p>A Liquid filter for formatting units of measurement.</p> PARAMETER DESCRIPTION <code>locale_var</code> <p>The name of a render context variable that resolves to the current locale. Defaults to <code>\"locale\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'locale'</code> </p> <code>default_locale</code> <p>A fallback locale to use if <code>locale_var</code> can not be resolved. Defaults to <code>\"en_US\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'en_US'</code> </p> <code>length_var</code> <p>The name of a render context variable that resolves to a unit format length. Should be one of \"short\", \"long\" or \"narrow\". Defaults to <code>\"long\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'unit_length'</code> </p> <code>default_length</code> <p>A fallback format length to use if <code>length_var</code> can not be resolved.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'long'</code> </p> <code>format_var</code> <p>The name of a render context variable that resolves to a decimal format string. Defaults to <code>\"unit_format\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'unit_format'</code> </p> <code>default_format</code> <p>A fallback decimal format to use if <code>format_var</code> can not be resolved. Defaults to <code>None</code>, meaning the locale's standard decimal format is used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>input_locale_var</code> <p>The name of a render context variable that resolves to a locale suitable for parsing input strings to decimals. Defaults to <code>\"input_locale\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'input_locale'</code> </p> <code>default_input_locale</code> <p>A fallback locale to use if <code>input_locale_var</code> can not be resolved. Defaults to <code>\"en_US\"</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'en_US'</code> </p>"},{"location":"api/filter/","title":"Filter helpers","text":""},{"location":"api/filter/#liquid.filter.decimal_arg","title":"liquid.filter.decimal_arg","text":"<pre><code>decimal_arg(\n    val: Any, default: Union[int, Decimal, None] = None\n) -&gt; Union[int, Decimal]\n</code></pre> <p>Return <code>val</code> as an int or decimal.</p> <p>If <code>val</code> can't be cast to an int or decimal, return <code>default</code>.</p>"},{"location":"api/filter/#liquid.filter.int_arg","title":"liquid.filter.int_arg","text":"<pre><code>int_arg(val: Any, default: Optional[int] = None) -&gt; int\n</code></pre> <p>Return <code>val</code> as an int or <code>default</code> if <code>val</code> can't be cast to an int.</p>"},{"location":"api/filter/#liquid.filter.math_filter","title":"liquid.filter.math_filter","text":"<pre><code>math_filter(_filter: FilterT) -&gt; FilterT\n</code></pre> <p>Raise a <code>FilterArgumentError</code> if the filter value can not be a number.</p>"},{"location":"api/filter/#liquid.filter.num_arg","title":"liquid.filter.num_arg","text":"<pre><code>num_arg(\n    val: Any, default: Optional[NumberT] = None\n) -&gt; NumberT\n</code></pre> <p>Return <code>val</code> as an int or float.</p> <p>If <code>val</code> can't be cast to an int or float, return <code>default</code>.</p>"},{"location":"api/filter/#liquid.filter.sequence_filter","title":"liquid.filter.sequence_filter","text":"<pre><code>sequence_filter(_filter: FilterT) -&gt; FilterT\n</code></pre> <p>A filter function decorator that coerces the left value to sequence.</p> <p>This is intended to mimic the semantics of the reference implementation's <code>InputIterator</code> class.</p>"},{"location":"api/filter/#liquid.filter.string_filter","title":"liquid.filter.string_filter","text":"<pre><code>string_filter(_filter: FilterT) -&gt; FilterT\n</code></pre> <p>A filter function decorator that converts the first argument to a string.</p>"},{"location":"api/filter/#liquid.filter.with_context","title":"liquid.filter.with_context","text":"<pre><code>with_context(_filter: FilterT) -&gt; FilterT\n</code></pre> <p>Pass the active render context to decorated filter functions.</p> <p>If a function is decorated with <code>with_context</code>, that function should accept a <code>context</code> keyword argument, being the active render context.</p> PARAMETER DESCRIPTION <code>_filter</code> <p>The filter function to decorate.</p> <p> TYPE: <code>FilterT</code> </p>"},{"location":"api/filter/#liquid.filter.with_environment","title":"liquid.filter.with_environment","text":"<pre><code>with_environment(_filter: FilterT) -&gt; FilterT\n</code></pre> <p>Pass the active environment to decorated filter functions.</p> <p>If a function is decorated with <code>with_environment</code>, that function should accept an <code>environment</code> keyword argument, being the active environment.</p> PARAMETER DESCRIPTION <code>_filter</code> <p>The filter function to decorate.</p> <p> TYPE: <code>FilterT</code> </p>"},{"location":"api/loaders/","title":"Loaders","text":""},{"location":"api/loaders/#liquid.loader.BaseLoader","title":"liquid.loader.BaseLoader","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all template loaders.</p>"},{"location":"api/loaders/#liquid.loader.BaseLoader.get_source","title":"get_source  <code>abstractmethod</code>","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>Environment</code> attempting to load the template source text.</p> <p> TYPE: <code>Environment</code> </p> <code>template_name</code> <p>A name or identifier for a template's source text.</p> <p> TYPE: <code>str</code> </p> <code>context</code> <p>An optional render context that can be used to narrow the template source search space.</p> <p> TYPE: <code>Optional[RenderContext]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Arbitrary arguments that can be used to narrow the template source search space.</p> <p> TYPE: <code>object</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/loaders/#liquid.loader.BaseLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>An async version of <code>get_source</code>.</p> <p>The default implementation delegates to <code>get_source()</code>.</p>"},{"location":"api/loaders/#liquid.loader.BaseLoader.load","title":"load","text":"<pre><code>load(\n    env: Environment,\n    name: str,\n    *,\n    globals: Optional[Mapping[str, object]] = None,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>Find and parse template source code.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>Environment</code> attempting to load the template source text.</p> <p> TYPE: <code>Environment</code> </p> <code>name</code> <p>A name or identifier for a template's source text.</p> <p> TYPE: <code>str</code> </p> <code>globals</code> <p>A mapping of render context variables attached to the resulting template.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>context</code> <p>An optional render context that can be used to narrow the template source search space.</p> <p> TYPE: <code>Optional[RenderContext]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Arbitrary arguments that can be used to narrow the template source search space.</p> <p> TYPE: <code>object</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/loaders/#liquid.loader.BaseLoader.load_async","title":"load_async  <code>async</code>","text":"<pre><code>load_async(\n    env: Environment,\n    name: str,\n    *,\n    globals: Union[Mapping[str, object], None] = None,\n    context: Union[RenderContext, None] = None,\n    **kwargs: object\n) -&gt; BoundTemplate\n</code></pre> <p>An async version of <code>load()</code>.</p>"},{"location":"api/loaders/#liquid.loader.TemplateSource","title":"liquid.loader.TemplateSource","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A Liquid template source as returned by the <code>get_source</code> method of a <code>loader</code>.</p> ATTRIBUTE DESCRIPTION <code>text</code> <p>The liquid template source code.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The liquid template file name or other string identifying its origin.</p> <p> TYPE: <code>str</code> </p> <code>uptodate</code> <p>Optional callable that will return <code>True</code> if the template is up to date, or <code>False</code> if it needs to be reloaded.</p> <p> TYPE: <code>Union[Callable[[], bool], Callable[[], Awaitable[bool]], None]</code> </p> <code>matter</code> <p>Optional mapping containing variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>Union[dict[str, object], None]</code> </p>"},{"location":"api/loaders/#liquid.FileSystemLoader","title":"liquid.FileSystemLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A loader that loads templates from one or more directories on the file system.</p> PARAMETER DESCRIPTION <code>search_path</code> <p>One or more paths to search.</p> <p> TYPE: <code>Union[str, Path, Iterable[Union[str, Path]]]</code> </p> <code>encoding</code> <p>Encoding to use when opening files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>ext</code> <p>A default file extension. Should include a leading period.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/loaders/#liquid.FileSystemLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid.FileSystemLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid.FileSystemLoader.resolve_path","title":"resolve_path","text":"<pre><code>resolve_path(template_name: str) -&gt; Path\n</code></pre> <p>Return a path to the template identified by template_name.</p> <p>If the search path is a list of paths, returns the first path where template_name exists. If none of the search paths contain template_name, a TemplateNotFound exception is raised.</p>"},{"location":"api/loaders/#liquid.CachingFileSystemLoader","title":"liquid.CachingFileSystemLoader","text":"<p>               Bases: <code>CachingLoaderMixin</code>, <code>FileSystemLoader</code></p> <p>A file system loader that caches parsed templates in memory.</p> PARAMETER DESCRIPTION <code>search_path</code> <p>One or more paths to search.</p> <p> TYPE: <code>Union[str, Path, Iterable[Union[str, Path]]]</code> </p> <code>encoding</code> <p>Open template files with the given encoding.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>ext</code> <p>A default file extension. Should include a leading period.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>auto_reload</code> <p>If <code>True</code>, automatically reload a cached template if it has been updated.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>namespace_key</code> <p>The name of a global render context variable or loader keyword argument that resolves to the current loader \"namespace\" or \"scope\".</p> <p>If you're developing a multi-user application, a good namespace might be <code>uid</code>, where <code>uid</code> is a unique identifier for a user and templates are arranged in folders named for each <code>uid</code> inside the search path.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>capacity</code> <p>The maximum number of templates to hold in the cache before removing the least recently used template.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p>"},{"location":"api/loaders/#liquid.DictLoader","title":"liquid.DictLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A loader that loads templates from a dictionary.</p> PARAMETER DESCRIPTION <code>templates</code> <p>A dictionary mapping template names to template source strings.</p> <p> TYPE: <code>dict[str, str]</code> </p>"},{"location":"api/loaders/#liquid.DictLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get the source, filename and reload helper for a template.</p>"},{"location":"api/loaders/#liquid.CachingDictLoader","title":"liquid.CachingDictLoader","text":"<p>               Bases: <code>CachingLoaderMixin</code>, <code>DictLoader</code></p> <p>A <code>DictLoader</code> that caches parsed templates in memory.</p>"},{"location":"api/loaders/#liquid.PackageLoader","title":"liquid.PackageLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A template loader that reads templates from Python packages.</p> PARAMETER DESCRIPTION <code>package</code> <p>Import name of a package containing Liquid templates.</p> <p> TYPE: <code>Union[str, ModuleType]</code> </p> <code>package_path</code> <p>One or more directories in the package containing Liquid templates.</p> <p> TYPE: <code>Union[str, Iterable[str]]</code> DEFAULT: <code>'templates'</code> </p> <code>encoding</code> <p>Encoding of template files.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>ext</code> <p>A default file extension to use if one is not provided. Should include a leading period.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'.liquid'</code> </p>"},{"location":"api/loaders/#liquid.PackageLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid.PackageLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid.ChoiceLoader","title":"liquid.ChoiceLoader","text":"<p>               Bases: <code>BaseLoader</code></p> <p>A template loader that delegates to other template loaders.</p> PARAMETER DESCRIPTION <code>loaders</code> <p>A list of loaders implementing <code>liquid.loaders.BaseLoader</code>.</p> <p> TYPE: <code>list[BaseLoader]</code> </p>"},{"location":"api/loaders/#liquid.ChoiceLoader.get_source","title":"get_source","text":"<pre><code>get_source(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid.ChoiceLoader.get_source_async","title":"get_source_async  <code>async</code>","text":"<pre><code>get_source_async(\n    env: Environment,\n    template_name: str,\n    *,\n    context: Optional[RenderContext] = None,\n    **kwargs: object\n) -&gt; TemplateSource\n</code></pre> <p>Get source information for a template.</p>"},{"location":"api/loaders/#liquid.CachingChoiceLoader","title":"liquid.CachingChoiceLoader","text":"<p>               Bases: <code>CachingLoaderMixin</code>, <code>ChoiceLoader</code></p> <p>A <code>ChoiceLoader</code> that caches parsed templates in memory.</p> PARAMETER DESCRIPTION <code>loaders</code> <p>A list of loaders implementing <code>liquid.loaders.BaseLoader</code>.</p> <p> TYPE: <code>list[BaseLoader]</code> </p> <code>auto_reload</code> <p>If <code>True</code>, automatically reload a cached template if it has been updated.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>namespace_key</code> <p>The name of a global render context variable or loader keyword argument that resolves to the current loader \"namespace\" or \"scope\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>capacity</code> <p>The maximum number of templates to hold in the cache before removing the least recently used template.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p>"},{"location":"api/loaders/#liquid.CachingLoaderMixin","title":"liquid.CachingLoaderMixin","text":"<p>               Bases: <code>ABC</code>, <code>_CachingLoaderProtocol</code></p> <p>A mixin class that adds caching to a template loader.</p>"},{"location":"api/messages/","title":"Messages","text":""},{"location":"api/messages/#liquid.Translations","title":"liquid.Translations","text":"<p>               Bases: <code>Protocol</code></p> <p>Message catalog interface.</p> <p>An object implementing this protocol is expected to be available in a render context.</p> <p>Could be a <code>GNUTranslations</code> instance from the <code>gettext</code> module, a Babel <code>Translations</code> object, or any object implementing <code>gettext</code>, <code>ngettext</code>, <code>pgettext</code> and <code>npgettext</code> methods.</p>"},{"location":"api/messages/#liquid.Translations.gettext","title":"gettext","text":"<pre><code>gettext(message: str) -&gt; str\n</code></pre> <p>Lookup the message in the catalog.</p>"},{"location":"api/messages/#liquid.Translations.ngettext","title":"ngettext","text":"<pre><code>ngettext(singular: str, plural: str, n: int) -&gt; str\n</code></pre> <p>Do plural-forms message lookup.</p>"},{"location":"api/messages/#liquid.Translations.npgettext","title":"npgettext","text":"<pre><code>npgettext(\n    context: str, singular: str, plural: str, n: int\n) -&gt; str\n</code></pre> <p>Do plural-forms context and message lookup.</p>"},{"location":"api/messages/#liquid.Translations.pgettext","title":"pgettext","text":"<pre><code>pgettext(context: str, message: str) -&gt; str\n</code></pre> <p>Lookup the context and message in the catalog.</p>"},{"location":"api/messages/#liquid.MessageTuple","title":"liquid.MessageTuple","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The tuple expected to be returned from babel extraction methods.</p>"},{"location":"api/messages/#liquid.extract_from_template","title":"liquid.extract_from_template","text":"<pre><code>extract_from_template(\n    template: BoundTemplate,\n    keywords: Union[list[str], dict[str, Any], None] = None,\n    comment_tags: list[str] | None = None,\n) -&gt; Iterator[MessageTuple]\n</code></pre> <p>Extract translation messages from a Liquid template.</p>"},{"location":"api/parser/","title":"Parser","text":""},{"location":"api/parser/#liquid.parser.Parser","title":"liquid.parser.Parser","text":"<p>A Liquid template parser. Create a parse tree from a stream of tokens.</p>"},{"location":"api/parser/#liquid.parser.Parser.parse","title":"parse","text":"<pre><code>parse(stream: TokenStream) -&gt; list[Node]\n</code></pre> <p>Parse tokens from stream into a list of nodes.</p>"},{"location":"api/parser/#liquid.parser.Parser.parse_block","title":"parse_block","text":"<pre><code>parse_block(\n    stream: TokenStream, end: Container[str]\n) -&gt; BlockNode\n</code></pre> <p>Parse tokens from stream until we reach a token in end.</p>"},{"location":"api/render_context/","title":"Render context","text":""},{"location":"api/render_context/#liquid.RenderContext","title":"liquid.RenderContext","text":"<p>A template render context.</p> <p>A new render context is created automatically each time <code>BoundTemplate.render</code> is called, which includes <code>globals</code> set on the bound <code>liquid.Environment</code> and <code>liquid.template.BoundTemplate</code>.</p>"},{"location":"api/render_context/#liquid.RenderContext.assign","title":"assign","text":"<pre><code>assign(key: str, val: Any) -&gt; None\n</code></pre> <p>Add or replace the context variable named key with the value val.</p>"},{"location":"api/render_context/#liquid.RenderContext.copy","title":"copy","text":"<pre><code>copy(\n    namespace: Mapping[str, object],\n    disabled_tags: Optional[list[str]] = None,\n    carry_loop_iterations: bool = False,\n    template: Optional[BoundTemplate] = None,\n    block_scope: bool = False,\n) -&gt; RenderContext\n</code></pre> <p>Return a copy of this render context.</p> <p>Local variables and other state for stateful tags are not copied.</p>"},{"location":"api/render_context/#liquid.RenderContext.cycle","title":"cycle","text":"<pre><code>cycle(key: object, length: int) -&gt; int\n</code></pre> <p>Return the index of the next item in the cycle.</p>"},{"location":"api/render_context/#liquid.RenderContext.decrement","title":"decrement","text":"<pre><code>decrement(name: str) -&gt; int\n</code></pre> <p>Decrement the named counter and return its value.</p>"},{"location":"api/render_context/#liquid.RenderContext.error","title":"error","text":"<pre><code>error(exc: LiquidError) -&gt; None\n</code></pre> <p>Ignore, raise or convert the given exception to a warning.</p>"},{"location":"api/render_context/#liquid.RenderContext.extend","title":"extend","text":"<pre><code>extend(\n    namespace: Mapping[str, object],\n    template: Optional[BoundTemplate] = None,\n) -&gt; Iterator[RenderContext]\n</code></pre> <p>Extend this context with the given read-only namespace.</p>"},{"location":"api/render_context/#liquid.RenderContext.filter","title":"filter","text":"<pre><code>filter(\n    name: str, token: Optional[Token]\n) -&gt; Callable[..., object]\n</code></pre> <p>Return the filter function with given name.</p>"},{"location":"api/render_context/#liquid.RenderContext.get","title":"get","text":"<pre><code>get(\n    path: list[object],\n    *,\n    token: Optional[Token],\n    default: object = UNDEFINED\n) -&gt; object\n</code></pre> <p>Resolve and return path in the current scope.</p> <p>If token is not None, it will be used to give error messages extra contextual information.</p> <p>Returns default is the path is not in scope.</p>"},{"location":"api/render_context/#liquid.RenderContext.get_async","title":"get_async  <code>async</code>","text":"<pre><code>get_async(\n    path: list[object],\n    *,\n    token: Optional[Token],\n    default: object = UNDEFINED\n) -&gt; object\n</code></pre> <p>Resolve and return path in the current scope.</p> <p>If token is not None, it will be used to give error messages extra contextual information.</p> <p>Returns default is the path is not in scope.</p>"},{"location":"api/render_context/#liquid.RenderContext.get_buffer","title":"get_buffer","text":"<pre><code>get_buffer(buf: Optional[TextIO] = None) -&gt; StringIO\n</code></pre> <p>Return a new StringIO object that respects the configured stream limit.</p>"},{"location":"api/render_context/#liquid.RenderContext.get_item","title":"get_item","text":"<pre><code>get_item(obj: Any, key: Any) -&gt; Any\n</code></pre> <p>An item getter used when resolving a Liquid path.</p> <p>Override this to change the behavior of <code>.first</code>, <code>.last</code> and <code>.size</code>.</p>"},{"location":"api/render_context/#liquid.RenderContext.get_item_async","title":"get_item_async  <code>async</code>","text":"<pre><code>get_item_async(obj: Any, key: Any) -&gt; Any\n</code></pre> <p>An async item getter for resolving paths.</p>"},{"location":"api/render_context/#liquid.RenderContext.get_size_of_locals","title":"get_size_of_locals","text":"<pre><code>get_size_of_locals() -&gt; int\n</code></pre> <p>Return the \"size\" or a \"score\" for the current local namespace.</p> <p>This is used by the optional local namespace resource limit. Override <code>get_size_of_locals</code> to customize how the limit is calculated. Be sure to consider <code>self.local_namespace_size_carry</code> when writing a custom implementation of <code>get_size_of_locals</code>.</p> <p>The default implementation uses <code>sys.getsizeof()</code> on each of the local namespace's values. It is not a reliable measure of size in bytes.</p>"},{"location":"api/render_context/#liquid.RenderContext.get_template","title":"get_template","text":"<pre><code>get_template(name: str) -&gt; BoundTemplate\n</code></pre> <p>Load a template from the environment.</p>"},{"location":"api/render_context/#liquid.RenderContext.get_template_async","title":"get_template_async  <code>async</code>","text":"<pre><code>get_template_async(name: str) -&gt; BoundTemplate\n</code></pre> <p>Load a template from the environment asynchronously.</p>"},{"location":"api/render_context/#liquid.RenderContext.ifchanged","title":"ifchanged","text":"<pre><code>ifchanged(val: str) -&gt; bool\n</code></pre> <p>Return True if the <code>ifchanged</code> value has changed.</p>"},{"location":"api/render_context/#liquid.RenderContext.increment","title":"increment","text":"<pre><code>increment(name: str) -&gt; int\n</code></pre> <p>Increment the named counter and return its value.</p>"},{"location":"api/render_context/#liquid.RenderContext.loop","title":"loop","text":"<pre><code>loop(\n    namespace: Mapping[str, object], forloop: ForLoop\n) -&gt; Iterator[RenderContext]\n</code></pre> <p>Just like <code>Context.extend</code>, but keeps track of ForLoop objects too.</p>"},{"location":"api/render_context/#liquid.RenderContext.parentloop","title":"parentloop","text":"<pre><code>parentloop() -&gt; Union[Undefined, object]\n</code></pre> <p>Return the last ForLoop object from the loop stack.</p>"},{"location":"api/render_context/#liquid.RenderContext.raise_for_loop_limit","title":"raise_for_loop_limit","text":"<pre><code>raise_for_loop_limit(length: int = 1) -&gt; None\n</code></pre> <p>Raise a <code>LoopIterationLimitError</code> if loop stack is bigger than the limit.</p>"},{"location":"api/render_context/#liquid.RenderContext.resolve","title":"resolve","text":"<pre><code>resolve(\n    name: str,\n    *,\n    token: Optional[Token] = None,\n    default: object = UNDEFINED\n) -&gt; Any\n</code></pre> <p>Return the object/value at <code>name</code> in the current scope.</p> <p>This is like <code>get</code>, but does a single, top-level lookup rather than a chained lookup from a sequence of keys.</p>"},{"location":"api/render_context/#liquid.RenderContext.stopindex","title":"stopindex","text":"<pre><code>stopindex(key: str, index: Optional[int] = None) -&gt; int\n</code></pre> <p>Set or return the stop index of a for loop.</p>"},{"location":"api/tag/","title":"Tag","text":""},{"location":"api/tag/#liquid.Tag","title":"liquid.Tag","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all built-in and custom template tags.</p>"},{"location":"api/tag/#liquid.Tag.get_node","title":"get_node","text":"<pre><code>get_node(stream: TokenStream) -&gt; Node\n</code></pre> <p>Wraps <code>Tag.parse</code>, possibly returning an <code>IllegalNode</code>.</p>"},{"location":"api/tag/#liquid.Tag.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(stream: TokenStream) -&gt; Node\n</code></pre> <p>Return a parse tree node by parsing tokens from the given stream.</p>"},{"location":"api/template/","title":"Template","text":""},{"location":"api/template/#liquid.BoundTemplate","title":"liquid.BoundTemplate","text":"<p>A liquid template that has been parsed and is bound to a <code>liquid.Environment</code>.</p> <p>You probably don't want to instantiate <code>BoundTemplate</code> directly. Use <code>liquid.Environment.from_string()</code> or <code>liquid.Environment.get_template()</code> instead.</p> PARAMETER DESCRIPTION <code>env</code> <p>The environment this template is bound to.</p> <p> TYPE: <code>Environment</code> </p> <code>nodes</code> <p>The parse tree representing this template.</p> <p> TYPE: <code>list[Node]</code> </p> <code>name</code> <p>Optional name of the template. Defaults to an empty string.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>path</code> <p>Optional origin path or identifier for the template.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>globals</code> <p>An optional mapping of context variables made available every time the resulting template is rendered. Defaults to <code>None</code>.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>matter</code> <p>Optional mapping containing variables associated with the template. Could be \"front matter\" or other meta data.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>uptodate</code> <p>Optional callable that will return <code>True</code> if the template is up to date, or <code>False</code> if it needs to be reloaded. Defaults to <code>None</code>.</p> <p> TYPE: <code>UpToDate</code> DEFAULT: <code>None</code> </p>"},{"location":"api/template/#liquid.BoundTemplate.analyze","title":"analyze","text":"<pre><code>analyze(\n    *, include_partials: bool = True\n) -&gt; TemplateAnalysis\n</code></pre> <p>Statically analyze this template and any included/rendered templates.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, we will try to load partial templates and analyze those templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"api/template/#liquid.BoundTemplate.analyze_async","title":"analyze_async  <code>async</code>","text":"<pre><code>analyze_async(\n    *, include_partials: bool = True\n) -&gt; TemplateAnalysis\n</code></pre> <p>An async version of <code>analyze</code>.</p>"},{"location":"api/template/#liquid.BoundTemplate.filter_names","title":"filter_names","text":"<pre><code>filter_names(*, include_partials: bool = True) -&gt; list[str]\n</code></pre> <p>Return a list of filter names used in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.filter_names_async","title":"filter_names_async  <code>async</code>","text":"<pre><code>filter_names_async(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of filter names used in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.full_name","title":"full_name","text":"<pre><code>full_name() -&gt; str\n</code></pre> <p>Return this template's path, if available, joined with its name.</p>"},{"location":"api/template/#liquid.BoundTemplate.global_variable_paths","title":"global_variable_paths","text":"<pre><code>global_variable_paths(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template including all path segments.</p> <p>Excludes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.global_variable_paths_async","title":"global_variable_paths_async  <code>async</code>","text":"<pre><code>global_variable_paths_async(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template including all path segments.</p> <p>Excludes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.global_variable_segments","title":"global_variable_segments","text":"<pre><code>global_variable_segments(\n    *, include_partials: bool = True\n) -&gt; list[Segments]\n</code></pre> <p>Return a list of variables used in this template, each as a list of segments.</p> <p>Excludes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[Segments]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.global_variable_segments_async","title":"global_variable_segments_async  <code>async</code>","text":"<pre><code>global_variable_segments_async(\n    *, include_partials: bool = True\n) -&gt; list[Segments]\n</code></pre> <p>Return a list of variables used in this template, each as a list of segments.</p> <p>Excludes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[Segments]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.global_variables","title":"global_variables","text":"<pre><code>global_variables(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template without path segments.</p> <p>Excludes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct root segments for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.global_variables_async","title":"global_variables_async  <code>async</code>","text":"<pre><code>global_variables_async(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template without path segments.</p> <p>Excludes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct root segments for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.is_up_to_date","title":"is_up_to_date","text":"<pre><code>is_up_to_date() -&gt; bool\n</code></pre> <p><code>False</code> if the template has bee modified, <code>True</code> otherwise.</p>"},{"location":"api/template/#liquid.BoundTemplate.is_up_to_date_async","title":"is_up_to_date_async  <code>async</code>","text":"<pre><code>is_up_to_date_async() -&gt; bool\n</code></pre> <p>An async version of the <code>is_up_to_date</code> property.</p> <p>If <code>template.uptodate</code> is a coroutine, it wil be awaited. Otherwise it will be called just like <code>is_up_to_date</code></p>"},{"location":"api/template/#liquid.BoundTemplate.make_globals","title":"make_globals","text":"<pre><code>make_globals(\n    render_args: Mapping[str, object],\n) -&gt; Mapping[str, object]\n</code></pre> <p>Return a mapping including render arguments and template globals.</p>"},{"location":"api/template/#liquid.BoundTemplate.make_partial_namespace","title":"make_partial_namespace","text":"<pre><code>make_partial_namespace(\n    partial: bool, render_args: Mapping[str, object]\n) -&gt; Mapping[str, object]\n</code></pre> <p>Return a namespace dictionary.</p> <p>This is used by <code>render_with_context</code> to extend an existing context.</p>"},{"location":"api/template/#liquid.BoundTemplate.render","title":"render","text":"<pre><code>render(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>Render the template with <code>args</code> and <code>kwargs</code> included in the render context.</p> <p>Accepts the same arguments as the <code>dict</code> constructor.</p>"},{"location":"api/template/#liquid.BoundTemplate.render_async","title":"render_async  <code>async</code>","text":"<pre><code>render_async(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>An async version of <code>liquid.template.BoundTemplate.render</code>.</p>"},{"location":"api/template/#liquid.BoundTemplate.render_with_context","title":"render_with_context","text":"<pre><code>render_with_context(\n    context: RenderContext,\n    buffer: TextIO,\n    *args: Any,\n    partial: bool = False,\n    block_scope: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Render the template using an existing context and output buffer.</p> PARAMETER DESCRIPTION <code>context</code> <p>A render context.</p> <p> TYPE: <code>RenderContext</code> </p> <code>buffer</code> <p>File-like object to which rendered text is written.</p> <p> TYPE: <code>TextIO</code> </p> <code>partial</code> <p>If <code>True</code>, indicates that the current template has been included using either a \"render\" or \"include\" tag. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>block_scope</code> <p>If <code>True</code>, indicates that assigns, breaks and continues from this template will not leak into the parent context. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>args</code> <p>Passed to the <code>dict</code> constructor. The resulting dictionary is added to the render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Passed to the <code>dict</code> constructor. The resulting dictionary is added to the render context.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p>"},{"location":"api/template/#liquid.BoundTemplate.render_with_context_async","title":"render_with_context_async  <code>async</code>","text":"<pre><code>render_with_context_async(\n    context: RenderContext,\n    buffer: TextIO,\n    *args: Any,\n    partial: bool = False,\n    block_scope: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>An async version of <code>render_with_context</code>.</p>"},{"location":"api/template/#liquid.BoundTemplate.tag_names","title":"tag_names","text":"<pre><code>tag_names(*, include_partials: bool = True) -&gt; list[str]\n</code></pre> <p>Return a list of tag names used in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.tag_names_async","title":"tag_names_async  <code>async</code>","text":"<pre><code>tag_names_async(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of tag names used in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.variable_paths","title":"variable_paths","text":"<pre><code>variable_paths(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template including all path segments.</p> <p>Includes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> <p>See also global_variable_paths.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.variable_paths_async","title":"variable_paths_async  <code>async</code>","text":"<pre><code>variable_paths_async(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template including all path segments.</p> <p>Includes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> <p>See also global_variable_paths.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.variable_segments","title":"variable_segments","text":"<pre><code>variable_segments(\n    *, include_partials: bool = True\n) -&gt; list[Segments]\n</code></pre> <p>Return a list of variables used in this template, each as a list of segments.</p> <p>Includes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> <p>See global_variable_segments.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[Segments]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.variable_segments_async","title":"variable_segments_async  <code>async</code>","text":"<pre><code>variable_segments_async(\n    *, include_partials: bool = True\n) -&gt; list[Segments]\n</code></pre> <p>Return a list of variables used in this template, each as a list of segments.</p> <p>Includes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> <p>See global_variable_segments.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[Segments]</code> <p>A list of distinct paths for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.variables","title":"variables","text":"<pre><code>variables(*, include_partials: bool = True) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template without path segments.</p> <p>Includes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> <p>See also global_variables.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct root segments for variables in this template.</p>"},{"location":"api/template/#liquid.BoundTemplate.variables_async","title":"variables_async  <code>async</code>","text":"<pre><code>variables_async(\n    *, include_partials: bool = True\n) -&gt; list[str]\n</code></pre> <p>Return a list of variables used in this template without path segments.</p> <p>Includes variables that are local to the template, like those crated with <code>{% assign %}</code> and <code>{% capture %}</code>.</p> <p>See also global_variables.</p> PARAMETER DESCRIPTION <code>include_partials</code> <p>If <code>True</code>, will try to load and find variables in included/rendered templates too.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of distinct root segments for variables in this template.</p>"},{"location":"api/template/#liquid.static_analysis.TemplateAnalysis","title":"liquid.static_analysis.TemplateAnalysis  <code>dataclass</code>","text":"<p>The result of analyzing a template using <code>Template.analyze()</code>.</p> PARAMETER DESCRIPTION <code>variables</code> <p>All referenced variables, whether they are in scope or not. Including references to names such as <code>forloop</code> from the <code>for</code> tag.</p> <p> TYPE: <code>dict[str, list[Variable]]</code> </p> <code>locals</code> <p>Template variables that are added to the template local scope, whether they are subsequently used or not.</p> <p> TYPE: <code>dict[str, list[Variable]]</code> </p> <code>globals</code> <p>Template variables that, on the given line number and \"file\", are out of scope or are assumed to be \"global\". That is, expected to be included by the application developer rather than a template author.</p> <p> TYPE: <code>dict[str, list[Variable]]</code> </p> <code>filters</code> <p>All filters found during static analysis.</p> <p> TYPE: <code>dict[str, list[Span]]</code> </p> <code>tags</code> <p>All tags found during static analysis.</p> <p> TYPE: <code>dict[str, list[Span]]</code> </p>"},{"location":"api/template/#liquid.static_analysis.Variable","title":"liquid.static_analysis.Variable  <code>dataclass</code>","text":"<p>A variable as sequence of segments that make up its path and its location.</p> <p>Variables with the same segments compare equal, regardless of span.</p>"},{"location":"api/template/#liquid.static_analysis.Variable.segments","title":"segments  <code>instance-attribute</code>","text":"<pre><code>segments: Segments\n</code></pre> <p>The variable's segments.</p>"},{"location":"api/template/#liquid.static_analysis.Variable.span","title":"span  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>span: Span = field(hash=False, compare=False)\n</code></pre> <p>The variable's location.</p>"},{"location":"api/template/#liquid.static_analysis.Span","title":"liquid.static_analysis.Span  <code>dataclass</code>","text":"<p>The location of a variable, tag or filter in a template.</p>"},{"location":"api/template/#liquid.static_analysis.Span.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index: int\n</code></pre> <p>A start index into the template source text.</p>"},{"location":"api/template/#liquid.static_analysis.Span.template_name","title":"template_name  <code>instance-attribute</code>","text":"<pre><code>template_name: str\n</code></pre> <p>The template name.</p>"},{"location":"api/template/#liquid.static_analysis.Span.line_col","title":"line_col","text":"<pre><code>line_col(source: str) -&gt; tuple[int, int]\n</code></pre> <p>Return a tuple of (line number, column number) for this span in source.</p>"},{"location":"api/tokens/","title":"Tokens","text":""},{"location":"api/tokens/#liquid.Token","title":"liquid.Token","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A substring into Liquid template source text along with its type.</p>"},{"location":"api/tokens/#liquid.Token.kind","title":"kind  <code>instance-attribute</code>","text":"<pre><code>kind: str\n</code></pre> <p>The type of the token.</p> <p>Could be one of <code>TOKEN_TAG</code>, <code>TOKEN_OUTPUT</code>, <code>TOKEN_EXPRESSION</code> or <code>TOKEN_CONTENT</code> indicating that it is a \"top-level\" token. All other tokens kinds are for tag and output expressions.</p>"},{"location":"api/tokens/#liquid.Token.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: str\n</code></pre> <p>A reference to the template source text from which this token came.</p>"},{"location":"api/tokens/#liquid.Token.start_index","title":"start_index  <code>instance-attribute</code>","text":"<pre><code>start_index: int\n</code></pre> <p>The index into source where this token starts.</p>"},{"location":"api/tokens/#liquid.Token.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str\n</code></pre> <p>The substring associated with this token.</p>"},{"location":"api/tokens/#liquid.Token.is_tag","title":"is_tag","text":"<pre><code>is_tag(name: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if this token is a tag and has the given name.</p>"},{"location":"api/tokens/#liquid.Token.test","title":"test","text":"<pre><code>test(typ: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if this token's type matches the <code>typ</code> argument.</p>"},{"location":"api/tokens/#liquid.TokenStream","title":"liquid.TokenStream","text":"<p>Step through a sequence of tokens.</p>"},{"location":"api/tokens/#liquid.TokenStream.current","title":"current  <code>property</code>","text":"<pre><code>current: Token\n</code></pre> <p>Return the token at the head of the stream without advancing.</p>"},{"location":"api/tokens/#liquid.TokenStream.peek","title":"peek  <code>property</code>","text":"<pre><code>peek: Token\n</code></pre> <p>Look at the next token.</p>"},{"location":"api/tokens/#liquid.TokenStream.eat","title":"eat","text":"<pre><code>eat(typ: str) -&gt; Token\n</code></pre> <p>Consume and return the next token.</p> <p>If the type of the next token is equal to typ, raise an exceptions.</p> <p>This is equivalent to <code>stream.expect(typ)</code> followed by <code>next(stream)</code>.</p>"},{"location":"api/tokens/#liquid.TokenStream.eat_one_of","title":"eat_one_of","text":"<pre><code>eat_one_of(*typ: str) -&gt; Token\n</code></pre> <p>Consume and return the next token.</p> <p>If the type of the next token is equal to typ, raise an exceptions.</p> <p>This is equivalent to <code>stream.expect(typ)</code> followed by <code>next(stream)</code>.</p>"},{"location":"api/tokens/#liquid.TokenStream.expect","title":"expect","text":"<pre><code>expect(typ: str, value: Optional[str] = None) -&gt; Token\n</code></pre> <p>Check the current token in the stream matches the given type and value.</p> <p>Returns the current token if its type matches typ. Raises a <code>LiquidSyntaxError</code> if it doesn't.</p>"},{"location":"api/tokens/#liquid.TokenStream.expect_eos","title":"expect_eos","text":"<pre><code>expect_eos() -&gt; None\n</code></pre> <p>Raise a syntax error if we're not at the end of the stream.</p>"},{"location":"api/tokens/#liquid.TokenStream.expect_peek","title":"expect_peek","text":"<pre><code>expect_peek(typ: str, value: Optional[str] = None) -&gt; Token\n</code></pre> <p>Check the next token in the stream matches the given type and value.</p> <p>Returns the next token if its type matches typ. Raises a <code>LiquidSyntaxError</code> it doesn't.</p>"},{"location":"api/tokens/#liquid.TokenStream.into_inner","title":"into_inner","text":"<pre><code>into_inner(\n    *, tag: Optional[Token] = None, eat: bool = True\n) -&gt; TokenStream\n</code></pre> <p>Return a stream of tokens for the current expression token.</p> <p>If the current token is not an expression, a <code>LiquidSyntaxError</code> is raised.</p> <p>If tag is given, it will be used to add context information to the syntax error, should one be raised.</p> <p>If eat is true (the default), the current token is consumed.</p>"},{"location":"api/tokens/#liquid.TokenStream.next","title":"next","text":"<pre><code>next() -&gt; Token\n</code></pre> <p>Return the next token and advance the iterator.</p>"},{"location":"api/tokens/#liquid.TokenStream.next_token","title":"next_token","text":"<pre><code>next_token() -&gt; Token\n</code></pre> <p>Return the next token and advance the iterator.</p>"},{"location":"api/undefined/","title":"Undefined","text":""},{"location":"api/undefined/#liquid.Undefined","title":"liquid.Undefined","text":"<p>               Bases: <code>Mapping[Any, object]</code></p> <p>The default undefined type.</p> <p>Always evaluates to an empty string. Can be iterated over and indexed without error.</p>"},{"location":"api/undefined/#liquid.Undefined.poke","title":"poke","text":"<pre><code>poke() -&gt; bool\n</code></pre> <p>Prod the type, giving it the opportunity to raise an exception.</p>"},{"location":"api/undefined/#liquid.StrictUndefined","title":"liquid.StrictUndefined","text":"<p>               Bases: <code>Undefined</code></p> <p>An undefined that raises an exception for everything other than <code>repr</code>.</p>"},{"location":"api/undefined/#liquid.DebugUndefined","title":"liquid.DebugUndefined","text":"<p>               Bases: <code>Undefined</code></p> <p>An undefined that returns debug information when rendered.</p>"},{"location":"api/undefined/#liquid.StrictDefaultUndefined","title":"liquid.StrictDefaultUndefined","text":"<p>               Bases: <code>StrictUndefined</code></p> <p>An undefined that plays nicely with the <code>default</code> filter.</p>"},{"location":"api/undefined/#liquid.FalsyStrictUndefined","title":"liquid.FalsyStrictUndefined","text":"<p>               Bases: <code>StrictUndefined</code></p> <p>An strict undefined type that can be tested for truthiness.</p>"}]}